[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-camel-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-camel-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-cluster-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-cluster-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-distributed-data-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-distributed-data-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-fsm-java-lambda\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-fsm-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-java-lambda\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-multi-node-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java-lambda\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-remote-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-remote-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-supervision-java-lambda\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Set current project to akka (in build file:/D:/data/akka-akka/akka-akka-4f9dc51/)
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[success] Total time: 13 s, completed 2020-11-2 22:34:15
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-actor...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-samples...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-protobuf...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-parsing...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-testkit...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-fsm-scala/}akka-sample-fsm-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-osgi...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-main-scala/}akka-sample-main-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-main-java-lambda/}akka-sample-main-java-lambda...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-main-java/}akka-sample-main-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-actor-tests...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-testkit...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-typed-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-kernel...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-slf4j...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-agent...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-fsm-java-lambda/}akka-sample-fsm-java-lambda...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving junit#junit;4.11 ...
[info] Resolving org.hamcrest#hamcrest-core;1.3 ...
[info] Resolving com.novocode#junit-interface;0.10 ...
[info] Resolving junit#junit-dep;4.10 ...
[info] Resolving org.scala-tools.testing#test-interface;0.5 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Scala version was updated by one of library dependencies:
[warn] 	* org.scala-lang:scala-library:2.11.7 -> 2.11.8
[warn] To force scalaVersion, add the following:
[warn] 	ivyScala := ivyScala.value map { _.copy(overrideScalaVersion = true) }
[warn] Run 'evicted' to see detailed eviction warnings
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-supervision-java-lambda/}akka-sample-supervision-java-lambda...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving junit#junit;4.12 ...
[info] Resolving org.hamcrest#hamcrest-core;1.3 ...
[info] Resolving com.novocode#junit-interface;0.11 ...
[info] Resolving org.scala-sbt#test-interface;1.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Scala version was updated by one of library dependencies:
[warn] 	* org.scala-lang:scala-library:2.11.7 -> 2.11.8
[warn] To force scalaVersion, add the following:
[warn] 	ivyScala := ivyScala.value map { _.copy(overrideScalaVersion = true) }
[warn] Run 'evicted' to see detailed eviction warnings
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-core...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-tests...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-query-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-tests-tck...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-persistence-java/}akka-sample-persistence-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.iq80.leveldb#leveldb;0.7 ...
[info] Resolving org.iq80.leveldb#leveldb-api;0.7 ...
[info] Resolving com.google.guava#guava;16.0.1 ...
[info] Resolving org.fusesource.leveldbjni#leveldbjni-all;1.8 ...
[info] Resolving com.typesafe.akka#akka-persistence_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-persistence-scala/}akka-sample-persistence-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.iq80.leveldb#leveldb;0.7 ...
[info] Resolving org.iq80.leveldb#leveldb-api;0.7 ...
[info] Resolving com.google.guava#guava;16.0.1 ...
[info] Resolving org.fusesource.leveldbjni#leveldbjni-all;1.8 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-persistence_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-persistence-java-lambda/}akka-sample-persistence-java-lambda...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.iq80.leveldb#leveldb;0.7 ...
[info] Resolving org.iq80.leveldb#leveldb-api;0.7 ...
[info] Resolving com.google.guava#guava;16.0.1 ...
[info] Resolving org.fusesource.leveldbjni#leveldbjni-all;1.8 ...
[info] Resolving com.typesafe.akka#akka-persistence_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-tck...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-camel...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-multi-node-testkit...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-remote-java/}akka-sample-remote-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-shared...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-camel-scala/}akka-sample-camel-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.apache.camel#camel-jetty;2.10.3 ...
[info] Resolving org.apache.camel#camel-core;2.10.3 ...
[info] Resolving org.apache.camel#camel-http;2.10.3 ...
[info] Resolving org.apache.geronimo.specs#geronimo-servlet_2.5_spec;1.1.2 ...
[info] Resolving commons-httpclient#commons-httpclient;3.1 ...
[info] Resolving commons-logging#commons-logging;1.0.4 ...
[info] Resolving commons-codec#commons-codec;1.6 ...
[info] Resolving org.eclipse.jetty#jetty-server;7.5.4.v20111024 ...
[info] Resolving javax.servlet#servlet-api;2.5 ...
[info] Resolving org.eclipse.jetty#jetty-continuation;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-http;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-io;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-util;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-security;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-servlet;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-servlets;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-client;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-jmx;7.5.4.v20111024 ...
[info] Resolving org.apache.camel#camel-quartz;2.10.3 ...
[info] Resolving org.quartz-scheduler#quartz;1.8.5 ...
[info] Resolving javax.transaction#jta;1.1 ...
[info] Resolving commons-collections#commons-collections;3.2.1 ...
[info] Resolving org.slf4j#slf4j-api;1.7.2 ...
[info] Resolving ch.qos.logback#logback-classic;1.0.7 ...
[info] Resolving ch.qos.logback#logback-core;1.0.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-camel_2.11;2.4.11.2 ...
[info] Resolving org.apache.camel#camel-core;2.13.4 ...
[info] Resolving com.sun.xml.bind#jaxb-impl;2.2.6 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-camel-java/}akka-sample-camel-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.apache.camel#camel-jetty;2.10.3 ...
[info] Resolving org.apache.camel#camel-core;2.10.3 ...
[info] Resolving org.apache.camel#camel-http;2.10.3 ...
[info] Resolving org.apache.geronimo.specs#geronimo-servlet_2.5_spec;1.1.2 ...
[info] Resolving commons-httpclient#commons-httpclient;3.1 ...
[info] Resolving commons-logging#commons-logging;1.0.4 ...
[info] Resolving commons-codec#commons-codec;1.6 ...
[info] Resolving org.eclipse.jetty#jetty-server;7.5.4.v20111024 ...
[info] Resolving javax.servlet#servlet-api;2.5 ...
[info] Resolving org.eclipse.jetty#jetty-continuation;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-http;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-io;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-util;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-security;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-servlet;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-servlets;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-client;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-jmx;7.5.4.v20111024 ...
[info] Resolving org.apache.camel#camel-quartz;2.10.3 ...
[info] Resolving org.quartz-scheduler#quartz;1.8.5 ...
[info] Resolving javax.transaction#jta;1.1 ...
[info] Resolving commons-collections#commons-collections;3.2.1 ...
[info] Resolving org.slf4j#slf4j-api;1.7.2 ...
[info] Resolving ch.qos.logback#logback-classic;1.0.7 ...
[info] Resolving ch.qos.logback#logback-core;1.0.7 ...
[info] Resolving com.typesafe.akka#akka-camel_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving org.apache.camel#camel-core;2.13.4 ...
[info] Resolving com.sun.xml.bind#jaxb-impl;2.2.6 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-remote-scala/}akka-sample-remote-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote-tests...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-multi-node-scala/}akka-sample-multi-node-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-testkit...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-xml-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-jackson-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-spray-json-experimental...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-tests...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-tools...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-distributed-data-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-metrics...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-contrib...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-distributed-data-scala/}akka-sample-distributed-data-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-cluster_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-distributed-data-experimental_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-distributed-data-java/}akka-sample-distributed-data-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-cluster_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-distributed-data-experimental_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-bench-jmh...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-sharding...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-cluster-scala/}akka-sample-cluster-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving io.kamon#sigar-loader;1.6.6-rev002 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-cluster_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-cluster-metrics_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-cluster-tools_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-cluster-java/}akka-sample-cluster-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving io.kamon#sigar-loader;1.6.6-rev002 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-cluster_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-cluster-metrics_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-cluster-tools_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-docs...
[info] Done updating.
[success] Total time: 16 s, completed 2020-11-2 22:34:31
[info] Formatting 20 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-distributed-data-experimental(compile) ...
[info] Formatting 8 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-multi-node-testkit(compile) ...
[info] Formatting 44 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-bench-jmh(compile) ...
[info] Formatting 19 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-camel(compile) ...
[info] Formatting 1 Scala source {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-kernel(compile) ...
[info] Formatting 4 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-osgi(compile) ...
[info] Formatting 31 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-typed-experimental(compile) ...
[info] Formatting 15 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-testkit(compile) ...
[info] Formatting 19 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster(compile) ...
[info] Formatting 37 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence(compile) ...
[info] Formatting 8 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-contrib(compile) ...
[info] Formatting 107 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream(compile) ...
[info] Formatting 156 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-core(compile) ...
[info] Formatting 10 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-metrics(compile) ...
[info] Formatting 6 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-testkit(compile) ...
[info] Formatting 1 Scala source {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-slf4j(compile) ...
[info] Formatting 1 Scala source {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-agent(compile) ...
[info] Formatting 83 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote(compile) ...
[info] Formatting 26 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-parsing(compile) ...
[info] Formatting 8 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-sharding(compile) ...
[info] Formatting 2 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-spray-json-experimental(compile) ...
[info] Formatting 12 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-testkit(compile) ...
[info] Formatting 24 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-query-experimental(compile) ...
[info] Formatting 8 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-tools(compile) ...
[info] Formatting 118 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-experimental(compile) ...
[info] Formatting 1 Scala source {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-xml-experimental(compile) ...
[info] Formatting 145 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-actor(compile) ...
[info] Formatting 10 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-tck(compile) ...
[info] Generating 'FanInShape.scala'
[info] Generating 'FanOutShape.scala'
[info] Generating 'GraphCreate.scala'
[info] Generating 'UnzipWith.scala'
[info] Generating 'ZipWith.scala'
[info] Generating 'GraphApply.scala'
[info] Generating 'UnzipWithApply.scala'
[info] Generating 'ZipWithApply.scala'
[info] Generating 'JavaPathMatchers.scala'
[info] Generating 'ApplyConverterInstances.scala'
[info] Generating 'ConstructFromTupleInstances.scala'
[info] Generating 'TupleAppendOneInstances.scala'
[info] Generating 'TupleFoldInstances.scala'
[info] Generating 'Functions.scala'
[info] Generating 'Tuples.scala'
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 148 Scala sources and 23 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:642: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]     if (actorInstance ne null) {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:770: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]           if (!watchedBy.contains(watcher))
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:788: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]           if (watchedBy.contains(watcher))
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Address.scala:134: [DuplicateIfBranches] If statement branches have the same structure.
[warn]     if (uri eq null) None
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:42: [UseOptionGetOrElse] Use x.getOrElse(...) instead of if (x.isDefined) x.get else ...
[warn]       case (x, Some(window))                 ? retriesInWindowOkay(if (x.isDefined) x.get else 1, window)
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:243: [UndesirableTypeInference] Inferred type Any => akka.actor.SupervisorStrategy.Escalate.type. (This might not be what you've intended)
[warn]   private[akka] val escalateDefault = (_: Any) ? Escalate
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ReflectiveDynamicAccess.scala:32: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val obj = constructor.newInstance(values: _*)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:425: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]             val f = ask(actor, m)(timeout)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:64: [UndesirableTypeInference] Inferred type scala.collection.mutable.Queue[Any]. (This might not be what you've intended)
[warn]     val messages = Queue.empty[Any]
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:64: [UndesirableTypeInference] Inferred type Option[Any]. (This might not be what you've intended)
[warn]         val optionalMessage = if (currentMessage ne null) Some(currentMessage.message) else None
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Dispatcher.scala:112: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]     if (mbox.canBeScheduledForExecution(hasMessageHint, hasSystemMessageHint)) { //This needs to be here to ensure thread safety and no races
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailboxes.scala:170: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => throw new akka.ConfigurationException(scala.StringContext.apply("Mailbox Mapping for [", "] not configured").s(queueType))} can be replaced with .getOrElse(throw new akka.ConfigurationException(scala.StringContext.apply("Mailbox Mapping for [", "] not configured").s(queueType)))
[warn]     mailboxBindings.get(queueType) match {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailboxes.scala:255: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => {

[warn]   val value: Int = Mailboxes.this.stashCapacityFromConfig(dispatcher, mailbox);

[warn]   updateCache(cache, key, value);

[warn]   value

[warn] }} can be replaced with .getOrElse({

[warn]   val value: Int = Mailboxes.this.stashCapacityFromConfig(dispatcher, mailbox);

[warn]   updateCache(cache, key, value);

[warn]   value

[warn] })
[warn]       cache.get(key) match {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:352: [UseOptionExistsNotPatMatch] ... match { Some(x) => false; None => {

[warn]   val removed: ManagedActorClassification.this.ManagedActorClassificationMappings = current.remove(monitored, monitor);

[warn]   val removedMonitors: scala.collection.immutable.TreeSet[akka.actor.ActorRef] = removed.get(monitored);

[warn]   if (monitors.isEmpty.||(monitors.==(removedMonitors)))

[warn]     false

[warn]   else

[warn]     if (ManagedActorClassification.this.mappings.compareAndSet(current, removed))

[warn]       ManagedActorClassification.this.unregisterFromUnsubscriber(monitor, removed.seqNr)

[warn]     else

[warn]       ManagedActorClassification.this.dissociate(monitored, monitor)

[warn] }} can be replaced with .exists({

[warn]   val removed: ManagedActorClassification.this.ManagedActorClassificationMappings = current.remove(monitored, monitor);

[warn]   val removedMonitors: scala.collection.immutable.TreeSet[akka.actor.ActorRef] = removed.get(monitored);

[warn]   if (monitors.isEmpty.||(monitors.==(removedMonitors)))

[warn]     false

[warn]   else

[warn]     if (ManagedActorClassification.this.mappings.compareAndSet(current, removed))

[warn]       ManagedActorClassification.this.unregisterFromUnsubscriber(monitor, removed.seqNr)

[warn]     else

[warn]       ManagedActorClassification.this.dissociate(monitored, monitor)

[warn] })
[warn]     current.backing.get(monitored) match {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:378: [UseOptionForeachNotPatMatch] ... match { Some(x) => refs.foreach[Unit](((x$7: akka.actor.ActorRef) => {

[warn]   <artifact> val qual$1: akka.actor.ScalaActorRef = akka.this.actor.`package`.actorRef2Scala(x$7);

[warn]   <artifact> val x$9: ManagedActorClassification.this.Event = event;

[warn]   <artifact> val x$10: akka.actor.ActorRef = qual$1.!$default$2(x$9);

[warn]   qual$1.!(x$9)(x$10)

[warn] })); None => {} } can be replaced with .foreach(refs.foreach[Unit](((x$7: akka.actor.ActorRef) => {

[warn]   <artifact> val qual$1: akka.actor.ScalaActorRef = akka.this.actor.`package`.actorRef2Scala(x$7);

[warn]   <artifact> val x$9: ManagedActorClassification.this.Event = event;

[warn]   <artifact> val x$10: akka.actor.ActorRef = qual$1.!$default$2(x$9);

[warn]   qual$1.!(x$9)(x$10)

[warn] })))
[warn]     mappings.get.backing.get(classify(event)) match {
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:433: [IdenticalIfElseCondition] This condition has appeared earlier in the if-else chain and will never hold here. (except for side-effecting conditions)
[warn]           else if (monitored.isTerminated) !dissociate(monitored, monitor) else true
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:181: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val response = try Await.result(actor ? InitializeLogger(this), timeout.duration) catch {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:473: [DuplicateIfBranches] If statement branches have the same structure.
[warn]     else if (classOf[Info].isAssignableFrom(eventClass)) InfoLevel
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:474: [DuplicateIfBranches] If statement branches have the same structure.
[warn]     else if (classOf[Debug].isAssignableFrom(eventClass)) DebugLevel
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Dns.scala:32: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => throw new java.net.UnknownHostException(Resolved.this.name)} can be replaced with .getOrElse(throw new java.net.UnknownHostException(Resolved.this.name))
[warn]     def addr: InetAddress = addrOption match {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\InetAddressDnsResolver.scala:17: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => try {

[warn]   val answer: akka.io.Dns.Resolved = Dns.Resolved.apply(name, scala.this.Predef.wrapRefArray[java.net.InetAddress](java.net.InetAddress.getAllByName(name)));

[warn]   InetAddressDnsResolver.this.cache.put(answer, InetAddressDnsResolver.this.positiveTtl);

[warn]   answer

[warn] } catch {

[warn]   case (e @ (_: java.net.UnknownHostException)) => {

[warn]     val answer: akka.io.Dns.Resolved = Dns.Resolved.apply(name, scala.collection.immutable.Seq.empty[Nothing], scala.collection.immutable.Seq.empty[Nothing]);

[warn]     InetAddressDnsResolver.this.cache.put(answer, InetAddressDnsResolver.this.negativeTtl);

[warn]     answer

[warn]   }

[warn] }} can be replaced with .getOrElse(try {

[warn]   val answer: akka.io.Dns.Resolved = Dns.Resolved.apply(name, scala.this.Predef.wrapRefArray[java.net.InetAddress](java.net.InetAddress.getAllByName(name)));

[warn]   InetAddressDnsResolver.this.cache.put(answer, InetAddressDnsResolver.this.positiveTtl);

[warn]   answer

[warn] } catch {

[warn]   case (e @ (_: java.net.UnknownHostException)) => {

[warn]     val answer: akka.io.Dns.Resolved = Dns.Resolved.apply(name, scala.collection.immutable.Seq.empty[Nothing], scala.collection.immutable.Seq.empty[Nothing]);

[warn]     InetAddressDnsResolver.this.cache.put(answer, InetAddressDnsResolver.this.negativeTtl);

[warn]     answer

[warn]   }

[warn] })
[warn]       val answer = cache.cached(name) match {
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SimpleDnsCache.scala:73: [UseExistsNotFilterIsEmpty] Use col.exists(!...) or !col.forall(...) instead of col.filterNot(...).isDefined.
[warn]         if (c.get(name).filterNot(_.isValid(now)).isDefined)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpListener.scala:52: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]   val localAddress =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpListener.scala:41: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]   val localAddress =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:46: [UseOptionForeachNotPatMatch] ... match { Some(x) => try {

[warn]   WithUdpSend.this.pendingSend_=({

[warn]     <artifact> val qual$1: akka.io.Udp.Send = WithUdpSend.this.pendingSend;

[warn]     <artifact> val x$1: java.net.InetSocketAddress = new java.net.InetSocketAddress(r.addr, WithUdpSend.this.pendingSend.target.getPort());

[warn]     <artifact> val x$2: akka.util.ByteString = qual$1.copy$default$1;

[warn]     <artifact> val x$3: akka.io.Udp.Event = qual$1.copy$default$3;

[warn]     qual$1.copy(x$2, x$1, x$3)

[warn]   });

[warn]   WithUdpSend.this.doSend(registration)

[warn] } catch {

[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((e @ _)) => {

[warn]     akka.this.actor.`package`.actorRef2Scala(WithUdpSend.this.sender()).!(akka.io.Udp.CommandFailed.apply(send))(WithUdpSend.this.self);

[warn]     WithUdpSend.this.log.debug("Failure while sending UDP datagram to remote address [{}]: {}", send.target, e);

[warn]     WithUdpSend.this.retriedSend_=(false);

[warn]     WithUdpSend.this.pendingSend_=(null);

[warn]     WithUdpSend.this.pendingCommander_=(null)

[warn]   }

[warn] }; None => {} } can be replaced with .foreach(try {

[warn]   WithUdpSend.this.pendingSend_=({

[warn]     <artifact> val qual$1: akka.io.Udp.Send = WithUdpSend.this.pendingSend;

[warn]     <artifact> val x$1: java.net.InetSocketAddress = new java.net.InetSocketAddress(r.addr, WithUdpSend.this.pendingSend.target.getPort());

[warn]     <artifact> val x$2: akka.util.ByteString = qual$1.copy$default$1;

[warn]     <artifact> val x$3: akka.io.Udp.Event = qual$1.copy$default$3;

[warn]     qual$1.copy(x$2, x$1, x$3)

[warn]   });

[warn]   WithUdpSend.this.doSend(registration)

[warn] } catch {

[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((e @ _)) => {

[warn]     akka.this.actor.`package`.actorRef2Scala(WithUdpSend.this.sender()).!(akka.io.Udp.CommandFailed.apply(send))(WithUdpSend.this.self);

[warn]     WithUdpSend.this.log.debug("Failure while sending UDP datagram to remote address [{}]: {}", send.target, e);

[warn]     WithUdpSend.this.retriedSend_=(false);

[warn]     WithUdpSend.this.pendingSend_=(null);

[warn]     WithUdpSend.this.pendingCommander_=(null)

[warn]   }

[warn] })
[warn]         Dns.resolve(send.target.getHostName)(context.system, self) match {
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:319: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val message = messageFactory(ref.provider.deadLetters)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:324: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val message = messageFactory(ref.provider.deadLetters)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:328: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val message = messageFactory(a)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:336: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val message = messageFactory(sender.asInstanceOf[InternalActorRef].provider.deadLetters)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:412: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val message = messageFactory(ref.provider.deadLetters)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:417: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val message = messageFactory(a)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:425: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val message = messageFactory(sender.asInstanceOf[InternalActorRef].provider.deadLetters)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:595: [UndesirableTypeInference] Inferred type scala.util.Failure[Nothing]. (This might not be what you've intended)
[warn]   private val ActorStopResult = Failure(new ActorKilledException("Stopped"))
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:357: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Nothing]. (This might not be what you've intended)
[warn]   private val timeoutFuture = Future.failed(new TimeoutException("Circuit Breaker Timed out.") with NoStackTrace)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RoundRobin.scala:29: [NumberInstanceOf] Use toInt instead of asInstanceOf[Int].
[warn]       val index = (next.getAndIncrement % size).asInstanceOf[Int]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ScatterGatherFirstCompleted.scala:46: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Nothing]. (This might not be what you've intended)
[warn]       val reply = Future.failed(new TimeoutException("Timeout due to no routees"))
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\TailChopping.scala:87: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]     val f = promise.future
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:367: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]           if (n > 0) {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:221: [YodaConditions] Yoda conditions using you are.
[warn]       if (0 <= index && length > index)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\HashCode.scala:45: [NumberInstanceOf] Use toInt instead of asInstanceOf[Int].
[warn]   def hash(seed: Int, value: Char): Int = firstTerm(seed) + value.asInstanceOf[Int]
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\HashCode.scala:47: [NumberInstanceOf] Use toInt instead of asInstanceOf[Int].
[warn]   def hash(seed: Int, value: Long): Int = firstTerm(seed) + (value ^ (value >>> 32)).asInstanceOf[Int]
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Index.scala:160: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]           if (set.remove(value)) { //If we can remove the value
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:108: [IdenticalCaseBodies] Bodies of 2 neighbouring cases are identical and could be merged.
[warn]         case 4 ? // Float
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:114: [IdenticalCaseBodies] Bodies of 2 neighbouring cases are identical and could be merged.
[warn]         case 6 ? // Double
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:133: [IdenticalCaseBodies] Bodies of 4 neighbouring cases are identical and could be merged.
[warn]         case 12 ? // NameAndType
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:207: [TypeToType] Using toSet on something that is already of type Set.
[warn]     n.subkeys.map(n ? (n.key, n.values.toSet))
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\TypedMultiMap.scala:44: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]     val set = map.get(key) match {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\TypedMultiMap.scala:44: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => scala.this.Predef.Set.empty[Any]} can be replaced with .getOrElse(scala.this.Predef.Set.empty[Any])
[warn]     val set = map.get(key) match {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\TypedMultiMap.scala:64: [UndesirableTypeInference] Inferred type scala.collection.immutable.Set[Any]. (This might not be what you've intended)
[warn]     val s = Set(value)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractProps.scala:57: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         throw new IllegalArgumentException(s"erased Creator types are unsupported, use Props.create(actorClass, creator) instead")
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:522: [SuspiciousMatches] This regex starts with ^ or ends with $. The matches method always matches the entire string.
[warn]   if (!name.matches("""^[a-zA-Z0-9][a-zA-Z0-9-_]*$"""))
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:469: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         prerequisites.eventStream.publish(Debug("DefaultExecutorServiceConfigurator", this.getClass, s"Using passed in ExecutionContext as default executor for this ActorSystem. If you want to use a different executor, please specify one in akka.actor.default-dispatcher.default-executor."))
[warn]                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailboxes.scala:204: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]                     s"which can lead to blocking behaviour when sending messages to this mailbox. " +
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Resizer.scala:66: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         throw new ResizerInitializationException(s"cannot enable both resizer and optimal-size-exploring-resizer", null)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:279: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       if (debug) println(s"LNB:   (skipped)")
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:350: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       if (debug) println(s"LNB:   (skipped)")
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyDuration.scala:42: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         case Duration.MinusInf ? s"-∞ (minus infinity)"
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyDuration.scala:43: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         case Duration.Inf      ? s"∞ (infinity)"
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:71: method init in trait ActorRefProvider references private[akka] class ActorSystemImpl.
[warn] Classes which cannot access ActorSystemImpl may be unable to provide a concrete implementation of init.
[warn]   def init(system: ActorSystemImpl): Unit
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:91: method registerTempActor in trait ActorRefProvider references private[akka] class InternalActorRef.
[warn] Classes which cannot access InternalActorRef may be unable to provide a concrete implementation of registerTempActor.
[warn]   def registerTempActor(actorRef: InternalActorRef, path: ActorPath): Unit
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:107: method actorOf in trait ActorRefProvider references private[akka] class ActorSystemImpl.
[warn] Classes which cannot access ActorSystemImpl may be unable to provide a concrete implementation of actorOf.
[warn]   def actorOf(
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:325: [UnusedParameter] Parameter currentMessage is not used in method mdc.
[warn]   def mdc(currentMessage: Any): MDC = emptyMDC
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:547: [UnusedParameter] Parameters (reason, message) are not used in method preRestart.
[warn]   def preRestart(reason: Throwable, message: Option[Any]): Unit = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:565: [UnusedParameter] Parameter reason is not used in method postRestart.
[warn]   def postRestart(reason: Throwable): Unit = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:159: [UnusedParameter] Parameter o is not used in method writeObject.
[warn]   final protected def writeObject(o: ObjectOutputStream): Unit =
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:660: [UnusedParameter] Parameter source is not used in method processEvent.
[warn]   private[akka] def processEvent(event: Event, source: AnyRef): Unit = {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\RepointableActorRef.scala:118: [UnusedParameter] Parameter old is not used in method newCell.
[warn]   def newCell(old: UnstartedCell): Cell =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\DeathWatch.scala:111: [UnusedParameter] Parameter actor is not used in method unwatchWatchedActors.
[warn]   protected def unwatchWatchedActors(actor: Actor): Unit =
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:188: [UnusedParameter] Parameter actor is not used in method register.
[warn]   protected[akka] def register(actor: ActorCell) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:348: [UnusedParameter] Parameter prerequisites is not used in method createThreadPoolConfigBuilder.
[warn]   protected def createThreadPoolConfigBuilder(config: Config, prerequisites: DispatcherPrerequisites): ThreadPoolConfigBuilder = {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:189: [UnusedParameter] Parameter result is not used in method internal.
[warn]     protected def internal(result: T): Unit = ()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:196: [UnusedParameter] Parameter result is not used in method internal.
[warn]     protected def internal(result: Throwable): T = null.asInstanceOf[T]
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:202: [UnusedParameter] Parameter result is not used in method internal.
[warn]     protected def internal(result: T): Boolean = false
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:212: [UnusedParameter] Parameter result is not used in method internal.
[warn]     protected def internal(result: T): Unit = ()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:367: [UnusedParameter] Parameter parameter is not used in method checkedApply.
[warn]   def checkedApply(parameter: T): R = throw new UnsupportedOperationException("Mapper.checkedApply has not been implemented")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:239: [UnusedParameter] Parameter system is not used in method genString.
[warn]   def genString(t: T, system: ActorSystem): String = genString(t)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Dns.scala:12: [UnusedParameter] Parameter name is not used in method cached.
[warn]   def cached(name: String): Option[Dns.Resolved] = None
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Inet.scala:22: [UnusedParameter] Parameter ds is not used in method beforeDatagramBind.
[warn]     def beforeDatagramBind(ds: DatagramSocket): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Inet.scala:27: [UnusedParameter] Parameter ss is not used in method beforeServerSocketBind.
[warn]     def beforeServerSocketBind(ss: ServerSocket): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Inet.scala:32: [UnusedParameter] Parameter s is not used in method beforeConnect.
[warn]     def beforeConnect(s: Socket): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Inet.scala:38: [UnusedParameter] Parameter s is not used in method afterConnect.
[warn]     def afterConnect(s: Socket): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Inet.scala:52: [UnusedParameter] Parameter s is not used in method afterBind.
[warn]     def afterBind(s: DatagramSocket): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Inet.scala:58: [UnusedParameter] Parameter s is not used in method afterBind.
[warn]     def afterBind(s: ServerSocket): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Inet.scala:64: [UnusedParameter] Parameter s is not used in method afterConnect.
[warn]     def afterConnect(s: DatagramSocket): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnection.scala:56: [UnusedParameter] Parameter address is not used in method doConnect.
[warn]   def doConnect(address: InetSocketAddress): Unit = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:60: [UnusedParameter] Parameter routingLogic is not used in method routingLogicController.
[warn]   def routingLogicController(routingLogic: RoutingLogic): Option[Props] = None
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:80: [UnusedParameter] Parameter other is not used in method withFallback.
[warn]   def withFallback(other: RouterConfig): RouterConfig = this
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:85: [UnusedParameter] Parameter path is not used in method verifyConfig.
[warn]   def verifyConfig(path: ActorPath): Unit = ()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:640: [UnusedParameter] Parameter buffer is not used in method copyToBuffer.
[warn]   def copyToBuffer(buffer: ByteBuffer): Int = throw new UnsupportedOperationException("Method copyToBuffer is not implemented in ByteString")
[warn]       ^
[warn] there were 13 deprecation warnings; re-run with -deprecation for details
[warn] 90 warnings found
[info] Compiling 45 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-protobuf\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-protobuf\src\main\java\akka\protobuf\AbstractParser.java:113:  catch 子句无法访问
[warn]     } catch (IOException e) {
[warn]       ^
[warn] 已捕获到抛出的类型InvalidProtocolBufferException
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-protobuf\src\main\java\akka\protobuf\AbstractParser.java:150:  catch 子句无法访问
[warn]     } catch (IOException e) {
[warn]       ^
[info] Compiling 26 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:120: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val result = buffer(targetIx)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:166: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val temp = buffer(_size - 1)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:177: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val temp = buffer(_size - 1)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:188: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     var temp = buffer(_size - 1)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:202: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     var temp = buffer(_size - 1)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\package.scala:35: [UndesirableTypeInference] Inferred type Array[Any]. (This might not be what you've intended)
[warn]   val EmptyArray = Array.empty[Any]
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:675: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val q"($arg ? $body)" = c.resetLocalAttrs(fTree)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ErrorFormatter.scala:197: [UnusedParameter] Parameter errorIndex is not used in method formatTrace.
[warn]   def formatTrace(trace: RuleTrace, errorIndex: Int): String = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:49: [UnusedParameter] Parameter that is not used in method $tilde.
[warn]   def ~[I2 <: HList, O2 <: HList](that: Rule[I2, O2])(implicit
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:58: [UnusedParameter] Parameter that is not used in method $tilde$bang$tilde.
[warn]   def ~!~[I2 <: HList, O2 <: HList](that: Rule[I2, O2])(implicit
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:68: [UnusedParameter] Parameter that is not used in method $bar.
[warn]   def |[I2 <: I, O2 >: O <: HList](that: Rule[I2, O2]): Rule[I2, O2] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:82: [UnusedParameter] Parameter name is not used in method named.
[warn]   def named(name: String): this.type = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:100: [UnusedParameter] Parameter separator is not used in method $times.
[warn]   def *(separator: Rule0)(implicit l: Lifter[immutable.Seq, I @uncheckedVariance, O @uncheckedVariance]): Rule[l.In, l.OptionalOut] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:112: [UnusedParameter] Parameter separator is not used in method $plus.
[warn]   def +(separator: Rule0)(implicit l: Lifter[immutable.Seq, I @uncheckedVariance, O @uncheckedVariance]): Rule[l.In, l.StrictOut] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLActions.scala:31: [UnusedParameter] Parameter r is not used in method capture.
[warn]   def capture[I <: HList, O <: HList](r: Rule[I, O])(implicit p: Prepend[O, String :: HNil]): Rule[I, p.Out] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLActions.scala:38: [UnusedParameter] Parameter condition is not used in method test.
[warn]   def test(condition: Boolean): Rule0 = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLActions.scala:64: [UnusedParameter] Parameter arg is not used in method run.
[warn]   def run[T](arg: T)(implicit rr: RunResult[T]): rr.Out = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLActions.scala:73: [UnusedParameter] Parameter value is not used in method push.
[warn]   def push[T](value: T)(implicit h: HListable[T]): RuleN[h.Out] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLActions.scala:84: [UnusedParameter] Parameter r is not used in method rule2ActionOperator.
[warn]   implicit def rule2ActionOperator[I <: HList, O <: HList](r: Rule[I, O])(implicit ops: ActionOps[I, O]): ActionOperator[I, O, ops.Out] = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:29: [UnusedParameter] Parameter c is not used in method ch.
[warn]   implicit def ch(c: Char): Rule0 = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:35: [UnusedParameter] Parameter s is not used in method str.
[warn]   implicit def str(s: String): Rule0 = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:41: [UnusedParameter] Parameter p is not used in method predicate.
[warn]   implicit def predicate(p: CharPredicate): Rule0 = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:48: [UnusedParameter] Parameter m is not used in method valueMap.
[warn]   implicit def valueMap[T](m: Map[String, T])(implicit h: HListable[T]): RuleN[h.Out] = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:58: [UnusedParameter] Parameter chars is not used in method anyOf.
[warn]   def anyOf(chars: String): Rule0 = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:68: [UnusedParameter] Parameter chars is not used in method noneOf.
[warn]   def noneOf(chars: String): Rule0 = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:76: [UnusedParameter] Parameter c is not used in method ignoreCase.
[warn]   def ignoreCase(c: Char): Rule0 = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:84: [UnusedParameter] Parameter s is not used in method ignoreCase.
[warn]   def ignoreCase(s: String): Rule0 = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:116: [UnusedParameter] Parameter expected is not used in method fail.
[warn]   def fail(expected: String): Rule0 = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:121: [UnusedParameter] Parameter expected is not used in method failX.
[warn]   def failX[I <: HList, O <: HList](expected: String): Rule[I, O] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:124: [UnusedParameter] Parameter s is not used in method str2CharRangeSupport.
[warn]   implicit def str2CharRangeSupport(s: String): CharRangeSupport = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:34: [UnusedParameter] Parameter r is not used in method optional.
[warn]   def optional[I <: HList, O <: HList](r: Rule[I, O])(implicit l: Lifter[Option, I, O]): Rule[l.In, l.OptionalOut] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:44: [UnusedParameter] Parameter r is not used in method zeroOrMore.
[warn]   def zeroOrMore[I <: HList, O <: HList](r: Rule[I, O])(implicit l: Lifter[immutable.Seq, I, O]): Rule[l.In, l.OptionalOut] with Repeated = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:54: [UnusedParameter] Parameter r is not used in method oneOrMore.
[warn]   def oneOrMore[I <: HList, O <: HList](r: Rule[I, O])(implicit l: Lifter[immutable.Seq, I, O]): Rule[l.In, l.StrictOut] with Repeated = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:61: [UnusedParameter] Parameter r is not used in method $amp.
[warn]   def &(r: Rule[_, _]): Rule0 = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:70: [UnusedParameter] Parameter r is not used in method atomic.
[warn]   def atomic[I <: HList, O <: HList](r: Rule[I, O]): Rule[I, O] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:79: [UnusedParameter] Parameter r is not used in method quiet.
[warn]   def quiet[I <: HList, O <: HList](r: Rule[I, O]): Rule[I, O] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:87: [UnusedParameter] Parameter f is not used in method runSubParser.
[warn]   def runSubParser[I <: HList, O <: HList](f: ParserInput ? Rule[I, O]): Rule[I, O] = `n/a`
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:90: [UnusedParameter] Parameter i is not used in method int2NTimes.
[warn]   implicit def int2NTimes(i: Int): NTimes = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:92: [UnusedParameter] Parameter range is not used in method range2NTimes.
[warn]   implicit def range2NTimes(range: Range): NTimes = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:109: [UnusedParameter] Parameter r is not used in method rule2WithSeparatedBy.
[warn]   implicit def rule2WithSeparatedBy[I <: HList, O <: HList](r: Rule[I, O] with Repeated): WithSeparatedBy[I, O] = `n/a`
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:111: [UnusedParameter] Parameter separator is not used in method separatedBy.
[warn]     def separatedBy(separator: Rule0): Rule[I, O] = `n/a`
[warn]         ^
[warn] there were 12 deprecation warnings; re-run with -deprecation for details
[warn] 42 warnings found
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 115 Scala sources and 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\KillSwitch.scala:70: [UndesirableTypeInference] Inferred type akka.stream.FlowShape[Any,Any]. (This might not be what you've intended)
[warn]     override val shape = FlowShape(Inlet[Any]("KillSwitch.in"), Outlet[Any]("KillSwitch.out"))
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\KillSwitch.scala:91: [UndesirableTypeInference] Inferred type akka.stream.BidiShape[Any,Any,Any,Any]. (This might not be what you've intended)
[warn]     override val shape = BidiShape(
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorRefSourceActor.scala:32: [UndesirableTypeInference] Inferred type akka.stream.impl.Buffer[Any]. (This might not be what you've intended)
[warn]   protected val buffer = if (bufferSize == 0) null else Buffer[Any](bufferSize, maxFixedBufferSize)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ConstantFun.scala:28: [UndesirableTypeInference] Inferred type Any => Long. (This might not be what you've intended)
[warn]   val zeroLong = (_: Any) ? 0L
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ConstantFun.scala:30: [UndesirableTypeInference] Inferred type Any => Long. (This might not be what you've intended)
[warn]   val oneLong = (_: Any) ? 1L
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ConstantFun.scala:32: [UndesirableTypeInference] Inferred type Any => Int. (This might not be what you've intended)
[warn]   val oneInt = (_: Any) ? 1
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ConstantFun.scala:34: [UndesirableTypeInference] Inferred type Any => None.type. (This might not be what you've intended)
[warn]   val none = (_: Any) ? None
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ConstantFun.scala:36: [UndesirableTypeInference] Inferred type (Any, Any) => None.type. (This might not be what you've intended)
[warn]   val two2none = (_: Any, _: Any) ? None
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ExposedPublisherReceive.scala:12: [UndesirableTypeInference] Inferred type List[Any]. (This might not be what you've intended)
[warn]   private var stash = List.empty[Any]
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanIn.scala:178: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val elem = input.dequeueInputElement()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ResizableMultiReaderRingBuffer.scala:21: [YodaConditions] Yoda conditions using you are.
[warn]     Integer.lowestOneBit(maxSize) == maxSize && 0 < maxSize && maxSize <= Int.MaxValue / 2,
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ResizableMultiReaderRingBuffer.scala:24: [YodaConditions] Yoda conditions using you are.
[warn]     Integer.lowestOneBit(initialSize) == initialSize && 0 < initialSize && initialSize <= maxSize,
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:379: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   $anon.this.sendDownstream(p);

[warn]   $anon.this.currentRequest_=(scala.None)

[warn] }; None => {} } can be replaced with .foreach({

[warn]   $anon.this.sendDownstream(p);

[warn]   $anon.this.currentRequest_=(scala.None)

[warn] })
[warn]         currentRequest match {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:424: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]   lazy val accumulated = collector.supplier().get()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:425: [UndesirableTypeInference] Inferred type java.util.function.BiConsumer[Any,T]. (This might not be what you've intended)
[warn]   private lazy val accumulator = collector.accumulator()
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:442: [UndesirableTypeInference] Inferred type java.util.function.BinaryOperator[Any]. (This might not be what you've intended)
[warn]   private lazy val combiner = collector.combiner()
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sources.scala:157: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   $anon.this.enqueueAndSuccess(offer);

[warn]   $anon.this.pendingOffer_=(scala.None)

[warn] }; None => {} } can be replaced with .foreach({

[warn]   $anon.this.enqueueAndSuccess(offer);

[warn]   $anon.this.pendingOffer_=(scala.None)

[warn] })
[warn]           pendingOffer match {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:272: [UnlikelyEquality] Comparing with == on instances of unrelated types ((A, B) => C,(Nothing, Any) => Nothing).
[warn]             if (f == scaladsl.Keep.left) {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:274: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]             } else if (f == scaladsl.Keep.right) {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:274: [UnlikelyEquality] Comparing with == on instances of unrelated types ((A, B) => C,(Any, Nothing) => Nothing).
[warn]             } else if (f == scaladsl.Keep.right) {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:936: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val ret = resolveMaterialized(module.materializedValueComputation, materializedValues, 2)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:956: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val ret = matNode match {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:975: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   val publisher: org.reactivestreams.Publisher[Any] = MaterializerSession.this.publishers.get(upstream);

[warn]   if (publisher.ne(null))

[warn]     MaterializerSession.this.doSubscribe(publisher, subscriberOrVirtual)

[warn]   else

[warn]     ()

[warn] }; None => {} } can be replaced with .foreach({

[warn]   val publisher: org.reactivestreams.Publisher[Any] = MaterializerSession.this.publishers.get(upstream);

[warn]   if (publisher.ne(null))

[warn]     MaterializerSession.this.doSubscribe(publisher, subscriberOrVirtual)

[warn]   else

[warn]     ()

[warn] })
[warn]     currentLayout.upstreams.get(in) match {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:977: [UndesirableTypeInference] Inferred type org.reactivestreams.Publisher[Any]. (This might not be what you've intended)
[warn]         val publisher = publishers.get(upstream)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:987: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   val subscriber: AnyRef = MaterializerSession.this.subscribers.get(downstream);

[warn]   if (subscriber.ne(null))

[warn]     MaterializerSession.this.doSubscribe(publisher, subscriber)

[warn]   else

[warn]     ()

[warn] }; None => {} } can be replaced with .foreach({

[warn]   val subscriber: AnyRef = MaterializerSession.this.subscribers.get(downstream);

[warn]   if (subscriber.ne(null))

[warn]     MaterializerSession.this.doSubscribe(publisher, subscriber)

[warn]   else

[warn]     ()

[warn] })
[warn]     currentLayout.downstreams.get(out) match {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:580: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]         } else if (!tryInit(shell)) {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:182: [UndesirableTypeInference] Inferred type akka.stream.stage.GraphStageWithMaterializedValue[akka.stream.Shape,Any]. (This might not be what you've intended)
[warn]         val stage = stages(i) match {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:190: [UndesirableTypeInference] Inferred type (akka.stream.stage.GraphStageLogic, Any). (This might not be what you've intended)
[warn]         val logicAndMat = stage.createLogicAndMaterializedValue(inheritedAttributes and originalAttributes(i))
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:593: [UndesirableTypeInference] Inferred type akka.stream.stage.GraphStageWithMaterializedValue[akka.stream.Shape,Any]. (This might not be what you've intended)
[warn]             val stage = assembly.stages(activeStage.stageId)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:772: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]     if (Debug) if (queueTail - queueHead > mask) new Exception(s"$Name internal queue full ($queueStatus) + $connection").printStackTrace()
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphStages.scala:119: [UndesirableTypeInference] Inferred type akka.stream.FlowShape[Any,Any]. (This might not be what you've intended)
[warn]     override val shape = FlowShape(in, out)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\IteratorInterpreter.scala:129: [UndesirableTypeInference] Inferred type akka.stream.stage.GraphStageWithMaterializedValue[akka.stream.FlowShape[_, _],Any]. (This might not be what you've intended)
[warn]       val stage = stagesIterator.next()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:199: [UndesirableTypeInference] Inferred type () => Any. (This might not be what you've intended)
[warn]     val wrappedPf = () ? pf.applyOrElse(grab(in), NotApplied)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:201: [UseOptionForeachNotPatMatch] ... match { Some(x) => result match {

[warn]   case Collect.NotApplied => $anon.this.pull[In](Collect.this.in)

[warn]   case (result @ (_: Out @unchecked)) => $anon.this.push[Out](Collect.this.out, result)

[warn] }; None => {} } can be replaced with .foreach(result match {

[warn]   case Collect.NotApplied => $anon.this.pull[In](Collect.this.in)

[warn]   case (result @ (_: Out @unchecked)) => $anon.this.push[Out](Collect.this.out, result)

[warn] })
[warn]     override def onPush(): Unit = withSupervision(wrappedPf) match {
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:629: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   $anon.this.left_=($anon.this.left.-(wight));

[warn]   if ($anon.this.left.>=(0))

[warn]     $anon.this.push[T](LimitWeighted.this.out, elem)

[warn]   else

[warn]     $anon.this.failStage(new akka.stream.StreamLimitReachedException(LimitWeighted.this.n))

[warn] }; None => {} } can be replaced with .foreach({

[warn]   $anon.this.left_=($anon.this.left.-(wight));

[warn]   if ($anon.this.left.>=(0))

[warn]     $anon.this.push[T](LimitWeighted.this.out, elem)

[warn]   else

[warn]     $anon.this.failStage(new akka.stream.StreamLimitReachedException(LimitWeighted.this.n))

[warn] })
[warn]       withSupervision(() ? costFn(elem)) match {
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:956: [UndesirableTypeInference] Inferred type scala.util.Failure[Nothing]. (This might not be what you've intended)
[warn]   val NotYetThere = Failure(new Exception)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:22: [JavaConverters] Consider using the explicit collection.JavaConverters instead of implicit conversions in collection.JavaConversions.
[warn] import scala.collection.JavaConversions._
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSourceStage.scala:97: [UseOptionExistsNotPatMatch] ... match { Some(x) => false; None => {

[warn]   p.complete(scala.util.Success.apply[Unit](()));

[warn]   $anon.this.close_=(scala.None);

[warn]   true

[warn] }} can be replaced with .exists({

[warn]   p.complete(scala.util.Success.apply[Unit](()));

[warn]   $anon.this.close_=(scala.None);

[warn]   true

[warn] })
[warn]           case None ? close match {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:62: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val msg = evt._2
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:205: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val msg = evt._2
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:224: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val msg = evt._2
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:50: [UnlikelyEquality] Comparing with == on instances of unrelated types ((Mat, Mat2) => Mat3,(Nothing, Any) => Nothing).
[warn]         if (combine == Keep.left) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:562: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]             else if (outPendingElem != null) {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Materialization.scala:15: [UndesirableTypeInference] Inferred type (Any, Any) => Any. (This might not be what you've intended)
[warn]   private val _left = (l: Any, r: Any) ? l
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Materialization.scala:16: [UndesirableTypeInference] Inferred type (Any, Any) => Any. (This might not be what you've intended)
[warn]   private val _right = (l: Any, r: Any) ? r
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Materialization.scala:17: [UndesirableTypeInference] Inferred type (Any, Any) => (Any, Any). (This might not be what you've intended)
[warn]   private val _both = (l: Any, r: Any) ? (l, r)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Materialization.scala:18: [UndesirableTypeInference] Inferred type (Any, Any) => akka.NotUsed.type. (This might not be what you've intended)
[warn]   private val _none = (l: Any, r: Any) ? NotUsed
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:169: [AssigningOptionToNull] You probably meant None, not null.
[warn]           var nextElement: Option[T] = null
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:219: [UndesirableTypeInference] Inferred type Array[Any]. (This might not be what you've intended)
[warn]   private[stream] val handlers = Array.ofDim[Any](inCount + outCount)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:386: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val elem = connection.slot
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1148: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val timerKey = scheduled.timerKey
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanOut.scala:314: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]             s"can only handle Tuple2 and akka.japi.Pair!")
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamSubscriptionTimeout.scala:87: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]           s"because exceeding it's subscription-timeout.") with NoStackTrace)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:631: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       builder.append(s"newShells:")
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:805: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         log.error(e, s"Error during postStop in [{}]: {}", assembly.stages(logic.stageId), e.getMessage)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:989: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   override def toString: String = s"OrElse"
[warn]                                   ^
[warn] non-nullary method overrides nullary method
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Transformer.scala:33: [UnusedParameter] Parameter e is not used in method onTermination.
[warn]   def onTermination(e: Option[Throwable]): immutable.Seq[U] = Nil
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\extra\Timed.scala:179: [UnusedParameter] Parameter in is not used in method updateInterval.
[warn]       private def updateInterval(in: T): FiniteDuration = {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:151: [UnusedParameter] Parameter e is not used in method inputOnError.
[warn]   protected def inputOnError(e: Throwable): Unit = {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanIn.scala:117: [UnusedParameter] Parameter input is not used in method onDepleted.
[warn]     def onDepleted(input: Int): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanOut.scala:183: [UnusedParameter] Parameter output is not used in method onCancel.
[warn]     def onCancel(output: Int): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:571: [UnusedParameter] Parameter indent is not used in method registerInternals.
[warn]     def registerInternals(s: Shape, indent: Int): Unit = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:603: [UnusedParameter] Parameter indent is not used in method newGroup.
[warn]     def newGroup(indent: Int): ju.Set[Module] = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:613: [UnusedParameter] Parameter indent is not used in method addModule.
[warn]     def addModule(m: Module, group: ju.Set[Module], inheritedAttributes: Attributes, indent: Int,
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:666: [UnusedParameter] Parameter indent is not used in method wire.
[warn]     def wire(out: OutPort, in: InPort, indent: Int): Unit = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:677: [UnusedParameter] Parameter indent is not used in method rewire.
[warn]     def rewire(oldShape: Shape, newShape: Shape, indent: Int): Unit = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:445: [UnusedParameter] Parameter t is not used in method onRestart.
[warn]     private def onRestart(t: Throwable): Unit = {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\FileIO.scala:64: [UnusedParameter] Parameter options is not used in method toFile.
[warn]   def toFile(f: File, options: util.Set[StandardOpenOption]): javadsl.Sink[ByteString, CompletionStage[IOResult]] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Flow.scala:46: [UnusedParameter] Parameter clazz is not used in method of.
[warn]   def of[T](clazz: Class[T]): javadsl.Flow[T, T, NotUsed] = create[T]()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Flow.scala:1532: [UnusedParameter] Parameter eagerComplete is not used in method mergeMat.
[warn]   def mergeMat[T >: Out, M, M2](
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:35: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T], inputPorts: Int): Graph[UniformFanInShape[T, T], NotUsed] = create(inputPorts)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:52: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T], inputPorts: Int, eagerComplete: Boolean): Graph[UniformFanInShape[T, T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:79: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T], secondaryPorts: Int): Graph[scaladsl.MergePreferred.MergePreferredShape[T], NotUsed] = create(secondaryPorts)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:96: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T], secondaryPorts: Int, eagerComplete: Boolean): Graph[scaladsl.MergePreferred.MergePreferredShape[T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:135: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T], outputCount: Int): Graph[UniformFanOutShape[T, T], NotUsed] = create(outputCount)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:168: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T], outputCount: Int, partitioner: function.Function[T, Int]): Graph[UniformFanOutShape[T, T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:205: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T], outputCount: Int): Graph[UniformFanOutShape[T, T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:214: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T], outputCount: Int, waitForAllDownstreams: Boolean): Graph[UniformFanOutShape[T, T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:309: [UnusedParameter] Parameters (left, right) are not used in method create.
[warn]   def create[A, B](left: Class[A], right: Class[B]): Graph[FanOutShape2[A Pair B, A, B], NotUsed] = create[A, B]()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:340: [UnusedParameter] Parameter clazz is not used in method create.
[warn]   def create[T](clazz: Class[T]): Graph[UniformFanInShape[T, T], NotUsed] = create()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Hub.scala:32: [UnusedParameter] Parameter clazz is not used in method of.
[warn]   def of[T](clazz: Class[T], perProducerBufferSize: Int): Source[T, Sink[T, NotUsed]] = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Hub.scala:85: [UnusedParameter] Parameter clazz is not used in method of.
[warn]   def of[T](clazz: Class[T], bufferSize: Int): Sink[T, Source[T, NotUsed]] = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1231: [UnusedParameter] Parameter b is not used in method importAndGetPort.
[warn]       override def importAndGetPort(b: Builder[_]): Outlet[Out] = j.out
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1236: [UnusedParameter] Parameter b is not used in method importAndGetPortReverse.
[warn]       override def importAndGetPortReverse(b: Builder[_]): Inlet[In] = j.in
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1244: [UnusedParameter] Parameter b is not used in method importAndGetPortReverse.
[warn]       override def importAndGetPortReverse(b: Builder[_]): Inlet[T] = s.in
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1248: [UnusedParameter] Parameter b is not used in method importAndGetPortReverse.
[warn]       override def importAndGetPortReverse(b: Builder[_]): Inlet[I] = f.in
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1336: [UnusedParameter] Parameter b is not used in method importAndGetPort.
[warn]       override def importAndGetPort(b: Builder[_]): Outlet[T] = s.out
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1163: [UnusedParameter] Parameter timerKey is not used in method onTimer.
[warn]   protected def onTimer(timerKey: Any): Unit = ()
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:203: [UnusedParameter] Parameter ctx is not used in method preStart.
[warn]   def preStart(ctx: LifeCtx): Unit = ()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:282: [UnusedParameter] Parameter t is not used in method decide.
[warn]   def decide(t: Throwable): Supervision.Directive = Supervision.Stop
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:707: The outer reference in this type test cannot be checked at run time.
[warn]     final case class Buffering(demand: Long) extends SubscriptionState
[warn]                      ^
[warn] there were 19 deprecation warnings; re-run with -deprecation for details
[warn] 93 warnings found
[info] Compiling 4 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\BundleDelegatingClassLoader.scala:53: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => find(remaining.tail)} can be replaced with .getOrElse(find(remaining.tail))
[warn]       else Option { remaining.head.getResource(name) } match {
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\ActorSystemActivator.scala:112: [UnusedParameter] Parameter context is not used in method getActorSystemName.
[warn]   def getActorSystemName(context: BundleContext): String = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\ActorSystemActivator.scala:124: [UnusedParameter] Parameter context is not used in method getActorSystemConfiguration.
[warn]   def getActorSystemConfiguration(context: BundleContext): Config = ConfigFactory.empty
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\OsgiActorSystemFactory.scala:39: [UnusedParameter] Parameter context is not used in method actorSystemConfig.
[warn]   def actorSystemConfig(context: BundleContext): Config = {
[warn]       ^
[warn] four warnings found
[info] Compiling 12 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:278: [VariableAssignedUnusedValue] Variable intex has an unused value before this reassign.
[warn]           intex = ie
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:61: [UndesirableTypeInference] Inferred type Any => Boolean. (This might not be what you've intended)
[warn]   val FALSE = (x: Any) ? false
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:494: [UseContainsNotExistsEquals] Use obj.contains(o) instead of obj.exists(x$2 == o)
[warn]     assert(obj exists (_ == o), s"found unexpected $o")
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:549: [UseContainsNotExistsEquals] Use recv.contains(x) instead of recv.exists(x == x$3)
[warn]     val missing = obj filterNot (x ? recv exists (x == _))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:550: [UseContainsNotExistsEquals] Use obj.contains(x) instead of obj.exists(x == x$4)
[warn]     val unexpected = recv filterNot (x ? obj exists (x == _))
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:550: [UnlikelyEquality] Comparing with == on instances of unrelated types (AnyRef,T).
[warn]     val unexpected = recv filterNot (x ? obj exists (x == _))
[warn]                                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\SocketUtil.scala:35: method invocation uses reflection
[info]       serverSocket.bind(new InetSocketAddress(hostname, 0))
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\SocketUtil.scala:36: method invocation uses reflection
[info]       (serverSocket, new InetSocketAddress(hostname, serverSocket.getLocalPort))
[info]                                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\SocketUtil.scala:37: method invocation uses reflection
[info]     } collect { case (socket, address) ? socket.close(); address }
[info]                                                      ^
[warn] 6 warnings found
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-java\target\classes...
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-java-lambda\target\classes...
[info] Compiling 4 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-scala\target\classes...
[info] Compiling 3 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-fsm-scala\target\classes...
[info] Compiling 1 Scala source to D:\data\akka-akka\akka-akka-4f9dc51\akka-slf4j\target\classes...
[info] Compiling 1 Scala source to D:\data\akka-akka\akka-akka-4f9dc51\akka-kernel\target\classes...
[info] Compiling 1 Scala source to D:\data\akka-akka\akka-akka-4f9dc51\akka-agent\target\classes...
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 37 Scala sources and 6 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:90: abstract type pattern D is unchecked since it is eliminated by erasure
[warn]     case SnapshotOffer(_, PersistentFSMSnapshot(stateIdentifier, data: D, timeout)) ? startWith(statesMap(stateIdentifier), data, timeout)
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\MessageSerializer.scala:57: non-variable type argument Any in type pattern akka.persistence.fsm.PersistentFSM.PersistentFSMSnapshot[Any] is unchecked since it is eliminated by erasure
[warn]     case p: PersistentFSMSnapshot[Any]  ? persistentFSMSnapshotBuilder(p).build.toByteArray
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistence.scala:239: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply("Unknown plugin actor ", "").s(journalPluginActor))} can be replaced with .getOrElse(throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply("Unknown plugin actor ", "").s(journalPluginActor)))
[warn]     } match {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\AsyncWriteProxy.scala:31: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Nothing]. (This might not be what you've intended)
[warn]   private val storeNotInitialized =
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:83: [TypeToType] Using toString on something that is already of type String.
[warn]       adapterNames(boundAdapter.toString),
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\WriteJournalBase.scala:33: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val payload = repr.payload
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\inmem\InmemJournal.scala:85: [YodaConditions] Yoda conditions using you are.
[warn]     if (Int.MaxValue < l) Int.MaxValue else l.toInt
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbIdMapping.scala:33: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => LeveldbIdMapping.this.writeIdMapping(id, LeveldbIdMapping.this.idMap.size.+(LeveldbIdMapping.this.idOffset))} can be replaced with .getOrElse(LeveldbIdMapping.this.writeIdMapping(id, LeveldbIdMapping.this.idMap.size.+(LeveldbIdMapping.this.idOffset)))
[warn]     idMap.get(id) match {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbStore.scala:155: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => LeveldbStore.this.readHighestSequenceNr(LeveldbStore.this.tagNumericId(tag))} can be replaced with .getOrElse(LeveldbStore.this.readHighestSequenceNr(LeveldbStore.this.tagNumericId(tag)))
[warn]     val n = tagSequenceNr.get(tag) match {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\snapshot\local\LocalSnapshotStore.scala:88: [UseOptionFlatMapNotPatMatch] ... match { Some(x) => scala.util.Try.apply[akka.persistence.serialization.Snapshot](LocalSnapshotStore.this.withInputStream[akka.persistence.serialization.Snapshot](md)({

[warn]   ((inputStream: java.io.InputStream) => LocalSnapshotStore.this.deserialize(inputStream))

[warn] })) match {

[warn]   case (value: akka.persistence.serialization.Snapshot)scala.util.Success[akka.persistence.serialization.Snapshot]((s @ _)) => scala.Some.apply[akka.persistence.SelectedSnapshot](akka.persistence.SelectedSnapshot.apply(md, s.data))

[warn]   case (exception: Throwable)scala.util.Failure[akka.persistence.serialization.Snapshot]((e @ _)) => {

[warn]     LocalSnapshotStore.this.log.error(e, scala.StringContext.apply("Error loading snapshot [", "]").s(md));

[warn]     LocalSnapshotStore.this.load(metadata.init)

[warn]   }

[warn] }; None => None} can be replaced with .flatMap(scala.util.Try.apply[akka.persistence.serialization.Snapshot](LocalSnapshotStore.this.withInputStream[akka.persistence.serialization.Snapshot](md)({

[warn]   ((inputStream: java.io.InputStream) => LocalSnapshotStore.this.deserialize(inputStream))

[warn] })) match {

[warn]   case (value: akka.persistence.serialization.Snapshot)scala.util.Success[akka.persistence.serialization.Snapshot]((s @ _)) => scala.Some.apply[akka.persistence.SelectedSnapshot](akka.persistence.SelectedSnapshot.apply(md, s.data))

[warn]   case (exception: Throwable)scala.util.Failure[akka.persistence.serialization.Snapshot]((e @ _)) => {

[warn]     LocalSnapshotStore.this.log.error(e, scala.StringContext.apply("Error loading snapshot [", "]").s(md));

[warn]     LocalSnapshotStore.this.load(metadata.init)

[warn]   }

[warn] })
[warn]   private def load(metadata: immutable.Seq[SnapshotMetadata]): Option[SelectedSnapshot] = metadata.lastOption match {
[warn]                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\snapshot\local\LocalSnapshotStore.scala:140: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]     if (!dir.isDirectory) {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentView.scala:285: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     override def toString: String = s"replay started"
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:44: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]             log.debug(s"Using EventAdapter: {} for event [{}]", value.getClass.getName, clazz.getName)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentView.scala:347: [UnusedParameter] Parameter receive is not used in method replayCompleted.
[warn]     def replayCompleted(receive: Receive): Unit = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:455: [UnusedParameter] Parameter source is not used in method processEvent.
[warn]   private[akka] def processEvent(event: Event, source: AnyRef): Unit = {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:748: [UnusedParameter] Parameter predicate is not used in method matchEvent.
[warn]   final def matchEvent[ET, DT <: D](eventType: Class[ET], dataType: Class[DT], predicate: TypedPredicate2[ET, DT], apply: Apply2[ET, DT, State]): FSMStateFunctionBuilder[S, D, E] =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbIdMapping.scala:70: [UnusedParameter] Parameter id is not used in method newPersistenceIdAdded.
[warn]   protected def newPersistenceIdAdded(id: String): Unit = ()
[warn]                 ^
[warn] there were three deprecation warnings; re-run with -deprecation for details
[warn] 18 warnings found
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 156 Scala sources and 126 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:43: [UnextendedSealedTrait] This sealed trait is never extended
[warn]   sealed trait StateResult // phantom type for ensuring soundness of our parsing method setup
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:408: [UnextendedSealedTrait] This sealed trait is never extended
[warn]   private[http] sealed trait WithoutKnownLength extends HttpEntity {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:186: [UnextendedSealedTrait] This sealed trait is never extended
[warn] sealed trait RequestEntity extends HttpEntity with jm.RequestEntity with ResponseEntity {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\OutgoingConnectionBlueprint.scala:312: [DuplicateIfBranches] If statement branches have the same structure.
[warn]           if (waitingForMethod) completeStage()
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:90: [UseOptionForeachNotPatMatch] ... match { Some(x) => HttpMessageParser.this.emit(x); None => {} } can be replaced with .foreach(HttpMessageParser.this.emit(x))
[warn]     completionHandling() match {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpResponseParser.scala:72: [UseOptionForeachNotPatMatch] ... match { Some(x) => HttpResponseParser.this.emit(x); None => {} } can be replaced with .foreach(HttpResponseParser.this.emit(x))
[warn]     completionHandling() match {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpResponseParser.scala:109: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => HttpResponseParser.this.settings.customStatusCodes.apply(code).getOrElse[akka.http.scaladsl.model.StatusCode](badStatusCode)} can be replaced with .getOrElse(HttpResponseParser.this.settings.customStatusCodes.apply(code).getOrElse[akka.http.scaladsl.model.StatusCode](badStatusCode))
[warn]         case _ ? StatusCodes.getForKey(code) match {
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\RenderSupport.scala:71: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.util.ByteString,Any]. (This might not be what you've intended)
[warn]     val messageBytes =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:633: [UndesirableTypeInference] Inferred type akka.stream.Graph[akka.stream.FlowShape[akka.http.impl.engine.ws.FrameEvent,akka.http.impl.engine.ws.FrameEvent],Any]. (This might not be what you've intended)
[warn]         val frameHandler = handlerFlow match {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\Masking.scala:47: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => throw new ProtocolException("Frame wasn\'t masked")} can be replaced with .getOrElse(throw new ProtocolException("Frame wasn\'t masked"))
[warn]     def extractMask(header: FrameHeader): Int = header.mask match {
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:80: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]   def `IMF-fixdate` = rule { // mixture of the spec-ed `IMF-fixdate` and `rfc850-date`
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:442: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => akka.http.scaladsl.model.HttpMethod.custom(s)} can be replaced with .getOrElse(akka.http.scaladsl.model.HttpMethod.custom(s))
[warn]       HttpMethods.getForKey(s) match {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentTypeHeader.scala:32: [UseOptionGetOrElse] Use charset.getOrElse(...) instead of if (charset.isDefined) charset.get else ...
[warn]             val cs = if (charset.isDefined) charset.get else HttpCharsets.`UTF-8`
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:110: [DuplicateIfBranches] If statement branches have the same structure.
[warn]   val (dispatch, ruleNames) = DynamicRuleDispatch[HeaderParser, HttpHeader :: HNil](
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:65: [ContainsTypeMismatch] Seq[(String, String)].contains(String) will probably return false, since the collection and target element are of unrelated types.
[warn]   def `link-media-type` = rule { `media-type` ~> ((mt, st, pm) ? getMediaType(mt, st, pm contains "charset", pm.toMap)) }
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:39: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]   private def `base64-padding` = rule {
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\settings\ServerSettingsImpl.scala:43: [YodaConditions] Yoda conditions using you are.
[warn]   require(0 < maxConnections, "max-connections must be > 0")
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\settings\ServerSettingsImpl.scala:45: [YodaConditions] Yoda conditions using you are.
[warn]   require(0 < responseHeaderSizeHint, "response-size-hint must be > 0")
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\settings\ServerSettingsImpl.scala:46: [YodaConditions] Yoda conditions using you are.
[warn]   require(0 < backlog, "backlog must be > 0")
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\DateTime.scala:184: [UseIfExpression] Assign the result of the if expression to variable s directly.
[warn]     if (s >= 0) s /= 1000 // seconds since 1 Jan 1970
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:36: [TypeToType] Using toFloat on something that is already of type Float.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:63: [TypeToType] Using toFloat on something that is already of type Float.
[warn]   def withQValue(qValue: Float): HttpCharsetRange = HttpCharsetRange(this, qValue.toFloat)
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:648: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.util.ByteString,Any]. (This might not be what you've intended)
[warn]         val (newData, whenCompleted) = StreamUtils.captureTermination(x.data)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:651: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.http.scaladsl.model.HttpEntity.ChunkStreamPart,Any]. (This might not be what you've intended)
[warn]         val (newChunks, whenCompleted) = StreamUtils.captureTermination(x.chunks)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:654: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.util.ByteString,Any]. (This might not be what you've intended)
[warn]         val (newData, whenCompleted) = StreamUtils.captureTermination(x.data)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:657: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.util.ByteString,Any]. (This might not be what you've intended)
[warn]         val (newData, whenCompleted) = StreamUtils.captureTermination(x.data)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaType.scala:51: [TypeToType] Using toFloat on something that is already of type Float.
[warn]   def withQValue(qValue: Float): MediaRange = MediaRange(this, qValue.toFloat)
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:62: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.http.scaladsl.model.HttpEntity.ChunkStreamPart,Any]. (This might not be what you've intended)
[warn]     val chunks =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:707: [InvariantCondition] This condition will always cause the same return value.
[warn]       if (port != 0 && defaultPorts(scheme) == port) 0 else port
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\ByteRange.scala:50: [YodaConditions] Yoda conditions using you are.
[warn]     require(0 <= offset, "offset must be >= 0")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\ByteRange.scala:60: [YodaConditions] Yoda conditions using you are.
[warn]     require(0 <= length, "length must be >= 0")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:30: [TypeToType] Using toFloat on something that is already of type Float.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:50: [TypeToType] Using toFloat on something that is already of type Float.
[warn]   def withQValue(qValue: Float): HttpEncodingRange = HttpEncodingRange(this, qValue.toFloat)
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:40: [TypeToType] Using toFloat on something that is already of type Float.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:65: [TypeToType] Using toFloat on something that is already of type Float.
[warn]   def withQValue(qValue: Float) = LanguageRange(this, qValue.toFloat)
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameEventRenderer.scala:42: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]             if (!lastPart) throw new IllegalStateException(s"Frame data complete but `lastPart` flag not set")
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\WebSocket.scala:75: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]           else if (inMessage) failStage(new ProtocolException(s"Truncated message, peer closed connection in the middle of message."))
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:256: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]           s"Please use only the provided factories in akka.http.javadsl.model.Http")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:524: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]           s"WebSocket requests must use either 'ws' or 'wss'")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:89: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       s"You can configure this by setting `akka.http.[server|client].parsing.max-content-length` or calling `HttpEntity.withSizeLimit` " +
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:90: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       s"before materializing the dataBytes stream."
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpHeader.scala:84: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]           ParsingResult.Error(info.left.get.withSummaryPrepended(s"Illegal HTTP header value"))
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpHeader.scala:86: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     } else ParsingResult.Error(ErrorInfo(s"Illegal HTTP header name", name))
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\Handshake.scala:67: [UnusedParameter] Parameter hostHeaderPresent is not used in method websocketUpgrade.
[warn]     def websocketUpgrade(headers: List[HttpHeader], hostHeaderPresent: Boolean): OptionVal[UpgradeToWebSocket] = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\MessageToFrameRenderer.scala:20: [UnusedParameter] Parameter serverSide is not used in method create.
[warn]   def create(serverSide: Boolean): Flow[Message, FrameStart, NotUsed] = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\SocketOptionSettings.scala:15: [UnusedParameter] Parameter root is not used in method fromSubConfig.
[warn]   def fromSubConfig(root: Config, c: Config): immutable.Seq[SocketOption] = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\StreamUtils.scala:111: [UnusedParameter] Parameter elem is not used in method splitAndPush.
[warn]         def splitAndPush(elem: ByteString): Unit = {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:278: [UnusedParameter] Parameter log is not used in method _outgoingTlsConnectionLayer.
[warn]   private def _outgoingTlsConnectionLayer(host: String, port: Int, localAddress: Option[InetSocketAddress],
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:359: [UnusedParameter] Parameter charset is not used in method apply.
[warn]     def apply(string: String, charset: Charset = UTF8, mode: Uri.ParsingMode = Uri.ParsingMode.Relaxed): Host =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:710: [UnusedParameter] Parameter scheme is not used in method verifyPath.
[warn]   private[http] def verifyPath(path: Path, scheme: String, host: Host): Path = {
[warn]                     ^
[warn] there were 6 deprecation warnings; re-run with -deprecation for details
[warn] 51 warnings found
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\java\akka\http\javadsl\model\HttpEntities.java:92:  [unchecked] 未经检查的转换
[warn]         return (akka.stream.scaladsl.Source<ByteString,Object>)javaSource.asScala();
[warn]                                                                                  ^
[info] Compiling 83 Scala sources and 7 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\DefaultFailureDetectorRegistry.scala:24: [UseOptionForallNotPatMatch] ... match { Some(x) => true; None => r.isAvailable} can be replaced with .forall(r.isAvailable)
[warn]   final override def isAvailable(resource: A): Boolean = resourceToFailureDetector.get.get(resource) match {
[warn]                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\DefaultFailureDetectorRegistry.scala:29: [UseOptionExistsNotPatMatch] ... match { Some(x) => false; None => r.isMonitoring} can be replaced with .exists(r.isMonitoring)
[warn]   final override def isMonitoring(resource: A): Boolean = resourceToFailureDetector.get.get(resource) match {
[warn]                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:978: [UseOptionForeachNotPatMatch] ... match { Some(x) => if (msg.reliableDeliveryEnabled)

[warn]   {

[warn]     EndpointReader.this.ackedReceiveBuffer_=(EndpointReader.this.ackedReceiveBuffer.receive(msg));

[warn]     EndpointReader.this.deliverAndAck()

[warn]   }

[warn] else

[warn]   EndpointReader.this.msgDispatch.dispatch(msg.recipient, msg.recipientAddress, msg.serializedMessage, msg.senderOption); None => {} } can be replaced with .foreach(if (msg.reliableDeliveryEnabled)

[warn]   {

[warn]     EndpointReader.this.ackedReceiveBuffer_=(EndpointReader.this.ackedReceiveBuffer.receive(msg));

[warn]     EndpointReader.this.deliverAndAck()

[warn]   }

[warn] else

[warn]   EndpointReader.this.msgDispatch.dispatch(msg.recipient, msg.recipientAddress, msg.serializedMessage, msg.senderOption))
[warn]       msgOption match {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteDaemon.scala:183: [UndesirableTypeInference] Inferred type (List[String], Any). (This might not be what you've intended)
[warn]       val (concatenatedChildNames, m) = {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteDaemon.scala:183: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val (concatenatedChildNames, m) = {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteSettings.scala:35: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => throw new akka.ConfigurationException("Logging level must be one of (on, off, debug, info, warning, error)")} can be replaced with .getOrElse(throw new akka.ConfigurationException("Logging level must be one of (on, off, debug, info, warning, error)"))
[warn]     case other ? Logging.levelFor(other) match {
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteWatcher.scala:140: [TypeToType] Using toSet on something that is already of type Set.
[warn]         watchingNodes = watchingNodes.size)(watchSet, watchingNodes.toSet)
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteWatcher.scala:203: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   watchers.-=(watcher);

[warn]   if (watchers.isEmpty)

[warn]     {

[warn]       RemoteWatcher.this.log.debug("Cleanup self watch of [{}]", watchee.path);

[warn]       RemoteWatcher.this.context.unwatch(watchee);

[warn]       RemoteWatcher.this.removeWatchee(watchee)

[warn]     }

[warn]   else

[warn]     ()

[warn] }; None => {} } can be replaced with .foreach({

[warn]   watchers.-=(watcher);

[warn]   if (watchers.isEmpty)

[warn]     {

[warn]       RemoteWatcher.this.log.debug("Cleanup self watch of [{}]", watchee.path);

[warn]       RemoteWatcher.this.context.unwatch(watchee);

[warn]       RemoteWatcher.this.removeWatchee(watchee)

[warn]     }

[warn]   else

[warn]     ()

[warn] })
[warn]     watching.get(watchee) match {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteWatcher.scala:220: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   watchees.-=(watchee);

[warn]   if (watchees.isEmpty)

[warn]     {

[warn]       RemoteWatcher.this.log.debug("Unwatched last watchee of node: [{}]", watcheeAddress);

[warn]       RemoteWatcher.this.unwatchNode(watcheeAddress)

[warn]     }

[warn]   else

[warn]     ()

[warn] }; None => {} } can be replaced with .foreach({

[warn]   watchees.-=(watchee);

[warn]   if (watchees.isEmpty)

[warn]     {

[warn]       RemoteWatcher.this.log.debug("Unwatched last watchee of node: [{}]", watcheeAddress);

[warn]       RemoteWatcher.this.unwatchNode(watcheeAddress)

[warn]     }

[warn]   else

[warn]     ()

[warn] })
[warn]     watcheeByNodes.get(watcheeAddress) match {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:870: [UseContainsNotExistsEquals] Use col.contains(withHandle) instead of col.exists(handle == withHandle)
[warn]     if (pendingReadHandoffs.get(takingOverFrom).exists(handle ? handle == withHandle))
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:132: [AssigningOptionToNull] You probably meant None, not null.
[warn]   private var uniqueRemoteAddressValueCache: Option[UniqueAddress] = null
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:167: [UseOptionExistsNotPatMatch] ... match { Some(x) => false; None => AssociationState.this.isQuarantined(a.uid)} can be replaced with .exists(AssociationState.this.isQuarantined(a.uid))
[warn]     uniqueRemoteAddressValue match {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:249: [UseOptionForeachNotPatMatch] ... match { Some(x) => FlushOnShutdown.this.remaining_=(FlushOnShutdown.this.remaining.+[Int](scala.this.Predef.ArrowAssoc[akka.remote.UniqueAddress](address).→[Int](acksExpected))); None => {} } can be replaced with .foreach(FlushOnShutdown.this.remaining_=(FlushOnShutdown.this.remaining.+[Int](scala.this.Predef.ArrowAssoc[akka.remote.UniqueAddress](address).→[Int](acksExpected))))
[warn]         a.associationState.uniqueRemoteAddressValue() match {
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:198: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Nothing]. (This might not be what you've intended)
[warn]     val f2 = after(timeout, transport.system.scheduler)(Future.failed(e))
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:272: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   Association.this.cancelIdleTimer();

[warn]   Association.this.log.debug("Incarnation {} of association to [{}] with new UID [{}] (old UID [{}])", newState.incarnation, peer.address, peer.uid, old.uid);

[warn]   Association.this.clearInboundCompression(old.uid)

[warn] }; None => {} } can be replaced with .foreach({

[warn]   Association.this.cancelIdleTimer();

[warn]   Association.this.log.debug("Incarnation {} of association to [{}] with new UID [{}] (old UID [{}])", newState.incarnation, peer.address, peer.uid, old.uid);

[warn]   Association.this.clearInboundCompression(old.uid)

[warn] })
[warn]                 current.uniqueRemoteAddressValue() match {
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:753: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => {

[warn]   val newAssociation: akka.remote.artery.Association = AssociationRegistry.this.createAssociation.apply(remoteAddress);

[warn]   val newMap: scala.collection.immutable.Map[akka.actor.Address,akka.remote.artery.Association] = currentMap.updated[akka.remote.artery.Association](remoteAddress, newAssociation);

[warn]   if (AssociationRegistry.this.associationsByAddress.compareAndSet(currentMap, newMap))

[warn]     {

[warn]       newAssociation.associate();

[warn]       newAssociation

[warn]     }

[warn]   else

[warn]     AssociationRegistry.this.association(remoteAddress)

[warn] }} can be replaced with .getOrElse({

[warn]   val newAssociation: akka.remote.artery.Association = AssociationRegistry.this.createAssociation.apply(remoteAddress);

[warn]   val newMap: scala.collection.immutable.Map[akka.actor.Address,akka.remote.artery.Association] = currentMap.updated[akka.remote.artery.Association](remoteAddress, newAssociation);

[warn]   if (AssociationRegistry.this.associationsByAddress.compareAndSet(currentMap, newMap))

[warn]     {

[warn]       newAssociation.associate();

[warn]       newAssociation

[warn]     }

[warn]   else

[warn]     AssociationRegistry.this.association(remoteAddress)

[warn] })
[warn]     currentMap.get(remoteAddress) match {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorder.scala:427: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]       if (status eq Running) {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:79: [DuplicateIfBranches] If statement branches have the same structure.
[warn]         None
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\SystemMessageDelivery.scala:283: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => 1L} can be replaced with .getOrElse(1L)
[warn]             val expectedSeqNo = sequenceNumbers.get(ackReplyTo) match {
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\TestStage.scala:33: [UseOptionExistsNotPatMatch] ... match { Some(x) => false; None => destinations.apply(to)} can be replaced with .exists(destinations.apply(to))
[warn]     state.get.blackholes.get(from) match {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\CompressionTable.scala:19: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => -1} can be replaced with .getOrElse(-1)
[warn]     dictionary.get(value) match {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\DecompressionTable.scala:37: [UndesirableTypeInference] Inferred type akka.remote.artery.compress.DecompressionTable[Nothing]. (This might not be what you've intended)
[warn]   private[this] val _empty = DecompressionTable(0, 0, Array.empty)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:94: [UseOptionForeachNotPatMatch] ... match { Some(x) => a.increment(address, ref, n.toLong); None => {} } can be replaced with .foreach(a.increment(address, ref, n.toLong))
[warn]     actorRefsIn(originUid) match {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:118: [UseOptionForeachNotPatMatch] ... match { Some(x) => a.increment(address, manifest, n.toLong); None => {} } can be replaced with .foreach(a.increment(address, manifest, n.toLong))
[warn]     classManifestsIn(originUid) match {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:159: [UseOptionForeachNotPatMatch] ... match { Some(x) => inbound.runNextTableAdvertisement(); None => {} } can be replaced with .foreach(inbound.runNextTableAdvertisement())
[warn]     _actorRefsIns.values().asScala.foreach {
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:168: [UseOptionForeachNotPatMatch] ... match { Some(x) => inbound.runNextTableAdvertisement(); None => {} } can be replaced with .foreach(inbound.runNextTableAdvertisement())
[warn]     _classManifestsIns.values().asScala.foreach {
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MiscMessageSerializer.scala:147: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val messageId = payloadSupport.deserializePayload(identifyProto.getMessageId)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MiscMessageSerializer.scala:153: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val correlationId = payloadSupport.deserializePayload(actorIdentityProto.getCorrelationId)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:65: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => {

[warn]   val unCachedParsingMethod: java.lang.reflect.Method = if (method.eq(null))

[warn]     clazz.getDeclaredMethod("parseFrom", (ProtobufSerializer.ARRAY_OF_BYTE_ARRAY: _*))

[warn]   else

[warn]     method;

[warn]   if (ProtobufSerializer.this.parsingMethodBindingRef.compareAndSet(parsingMethodBinding, parsingMethodBinding.updated[java.lang.reflect.Method](clazz, unCachedParsingMethod)))

[warn]     unCachedParsingMethod

[warn]   else

[warn]     parsingMethod(unCachedParsingMethod)

[warn] }} can be replaced with .getOrElse({

[warn]   val unCachedParsingMethod: java.lang.reflect.Method = if (method.eq(null))

[warn]     clazz.getDeclaredMethod("parseFrom", (ProtobufSerializer.ARRAY_OF_BYTE_ARRAY: _*))

[warn]   else

[warn]     method;

[warn]   if (ProtobufSerializer.this.parsingMethodBindingRef.compareAndSet(parsingMethodBinding, parsingMethodBinding.updated[java.lang.reflect.Method](clazz, unCachedParsingMethod)))

[warn]     unCachedParsingMethod

[warn]   else

[warn]     parsingMethod(unCachedParsingMethod)

[warn] })
[warn]           parsingMethodBinding.get(clazz) match {
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:88: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => {

[warn]   val unCachedtoByteArrayMethod: java.lang.reflect.Method = if (method.eq(null))

[warn]     clazz.getMethod("toByteArray")

[warn]   else

[warn]     method;

[warn]   if (ProtobufSerializer.this.toByteArrayMethodBindingRef.compareAndSet(toByteArrayMethodBinding, toByteArrayMethodBinding.updated[java.lang.reflect.Method](clazz, unCachedtoByteArrayMethod)))

[warn]     unCachedtoByteArrayMethod

[warn]   else

[warn]     toByteArrayMethod(unCachedtoByteArrayMethod)

[warn] }} can be replaced with .getOrElse({

[warn]   val unCachedtoByteArrayMethod: java.lang.reflect.Method = if (method.eq(null))

[warn]     clazz.getMethod("toByteArray")

[warn]   else

[warn]     method;

[warn]   if (ProtobufSerializer.this.toByteArrayMethodBindingRef.compareAndSet(toByteArrayMethodBinding, toByteArrayMethodBinding.updated[java.lang.reflect.Method](clazz, unCachedtoByteArrayMethod)))

[warn]     unCachedtoByteArrayMethod

[warn]   else

[warn]     toByteArrayMethod(unCachedtoByteArrayMethod)

[warn] })
[warn]       toByteArrayMethodBinding.get(clazz) match {
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\SystemMessageSerializer.scala:26: [UseOptionForeachNotPatMatch] ... match { Some(x) => builder.setCauseData(SystemMessageSerializer.this.serializeThrowable(throwable)); None => {} } can be replaced with .foreach(builder.setCauseData(SystemMessageSerializer.this.serializeThrowable(throwable)))
[warn]         failure match {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AbstractTransportAdapter.scala:35: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply("There is no registered transport adapter provider with name: [", "]").s(name))} can be replaced with .getOrElse(throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply("There is no registered transport adapter provider with name: [", "]").s(name)))
[warn]   def getAdapterProvider(name: String): TransportAdapterProvider = adaptersTable.get(name) match {
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AbstractTransportAdapter.scala:193: [UndesirableTypeInference] Inferred type scala.collection.immutable.Queue[Any]. (This might not be what you've intended)
[warn]   private var delayedEvents = immutable.Queue.empty[Any]
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\FailureInjectorTransportAdapter.scala:106: [UseOptionForeachNotPatMatch] ... match { Some(x) => listener.notify(FailureInjectorTransportAdapter.this.interceptInboundAssociation(ev)); None => {} } can be replaced with .foreach(listener.notify(FailureInjectorTransportAdapter.this.interceptInboundAssociation(ev)))
[warn]     case _ ? upstreamListener match {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:301: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]               new IllegalStateException(s"Error encountered while processing system message " +
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:990: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         new OversizedPayloadException(s"Discarding oversized payload received: " +
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:763: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         log.error(cause, s"{} failed after shutdown. {}", streamName, cause.getMessage)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:682: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         log.error(cause, s"{} to [{}] failed after shutdown. {}", streamName, remoteAddress, cause.getMessage)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Handshake.scala:243: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]               s"Dropping message [{}] from unknown system with UID [{}]. " +
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:218: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     s"LruBoundedCache(" +
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:198: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     log.debug(s"Advertise {} compression [{}] to [{}#{}]", Logging.simpleName(getClass), table, outboundContext.remoteAddress,
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:219: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     log.debug(s"Advertise {} compression [{}] to [{}#{}]", Logging.simpleName(getClass), table, outboundContext.remoteAddress,
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:475: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       s"This could happen if this node has started a new ActorSystem bound to the same address as previously, " +
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:476: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       s"and previous messages from a remote system were still in flight (using an old compression table). " +
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:477: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       s"The remote system is expected to drop the compression table and this system will advertise a new one.")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaProtocolTransport.scala:421: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]                 s"Association attempt with mismatching cookie from [{}]. Expected [{}] but received [{}].",
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaProtocolTransport.scala:424: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]               log.warning(s"Association attempt with mismatching cookie from [{}].", info.origin)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaProtocolTransport.scala:510: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       stop(FSM.Failure(TimeoutReason(s"No response from remote. " +
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:114: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     s"Setting 'maximum-frame-size' must be at least 32000 bytes")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\MessageSerializer.scala:88: [UnusedParameter] Parameters (system, originUid) are not used in method deserializeForArtery.
[warn]   def deserializeForArtery(system: ExtendedActorSystem, originUid: Long, serialization: Serialization,
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteTransport.scala:80: [UnusedParameter] Parameter cmd is not used in method managementCommand.
[warn]   def managementCommand(cmd: Any): Future[Boolean] = { Future.successful(false) }
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\MetadataEnvelopeSerializer.scala:50: [UnusedParameter] Parameters (system, originUid) are not used in method deserialize.
[warn]   def deserialize(system: ExtendedActorSystem, originUid: Long, serialization: Serialization,
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:370: [UnusedParameter] Parameter remoteAddress is not used in method increment.
[warn]   def increment(remoteAddress: Address, value: T, n: Long): Unit = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ActorRefResolveCache.scala:47: [UnusedParameter] Parameter provider is not used in method threadLocalCache.
[warn]   def threadLocalCache(provider: RemoteActorRefProvider): ActorRefResolveCache =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\Transport.scala:143: [UnusedParameter] Parameter cmd is not used in method managementCommand.
[warn]   def managementCommand(cmd: Any): Future[Boolean] = { Future.successful(false) }
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyHelpers.scala:16: [UnusedParameter] Parameters (ctx, e) are not used in method onConnect.
[warn]   protected def onConnect(ctx: ChannelHandlerContext, e: ChannelStateEvent): Unit = ()
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyHelpers.scala:18: [UnusedParameter] Parameters (ctx, e) are not used in method onDisconnect.
[warn]   protected def onDisconnect(ctx: ChannelHandlerContext, e: ChannelStateEvent): Unit = ()
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyHelpers.scala:20: [UnusedParameter] Parameters (ctx, e) are not used in method onOpen.
[warn]   protected def onOpen(ctx: ChannelHandlerContext, e: ChannelStateEvent): Unit = ()
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyHelpers.scala:22: [UnusedParameter] Parameters (ctx, e) are not used in method onMessage.
[warn]   protected def onMessage(ctx: ChannelHandlerContext, e: MessageEvent): Unit = ()
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyHelpers.scala:24: [UnusedParameter] Parameters (ctx, e) are not used in method onException.
[warn]   protected def onException(ctx: ChannelHandlerContext, e: ExceptionEvent): Unit = ()
[warn]                 ^
[warn] there were 19 deprecation warnings; re-run with -deprecation for details
[warn] 61 warnings found
[info] Compiling 6 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\target\classes...
[info] Compiling 31 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorContext.scala:170: [UseOptionExistsNotPatMatch] ... match { Some(x) => false; None => inbox.ref.==(child)} can be replaced with .exists(inbox.ref.==(child))
[warn]     _children.get(child.path.name) match {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:450: [UndesirableTypeInference] Inferred type Any => akka.typed.Behavior[Nothing]. (This might not be what you've intended)
[warn]   private[akka] val _unhandledFunction = (_: Any) ? Unhandled[Nothing]
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:459: [UndesirableTypeInference] Inferred type Any => Unit. (This might not be what you've intended)
[warn]   private[akka] val _unitFunction = (_: Any) ? ()
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorContextAdapter.scala:17: [UndesirableTypeInference] Inferred type akka.typed.ActorSystem[Nothing]. (This might not be what you've intended)
[warn]   override val system = ActorSystemAdapter(ctx.system)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:405: [UndesirableTypeInference] Inferred type akka.typed.ActorRef[Any]. (This might not be what you've intended)
[warn]     val dlm = system.deadLetters
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:114: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]         if (!watchedBy.contains(watcher))
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:123: [MergeNestedIfs] These two nested ifs can be merged into one.
[warn]         if (watchedBy.contains(watcher))
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:201: [ContainsTypeMismatch] Seq[(akka.typed.ActorRef[akka.typed.Logger.Command], akka.typed.ActorRef[akka.event.Logging.LogEvent])].contains(EventStreamImpl.this.StandardOutLogger) will probably return false, since the collection and target element are of unrelated types.
[warn]     if (!(loggers contains StandardOutLogger)) {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorSystemImpl.scala:80: [SuspiciousMatches] This regex starts with ^ or ends with $. The matches method always matches the entire string.
[warn]   if (!name.matches("""^[a-zA-Z0-9][a-zA-Z0-9-_]*$"""))
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:44: [UnusedParameter] Parameter ctx is not used in method postProcess.
[warn]     private def postProcess(ctx: ActorContext[U], behv: Behavior[T]): Behavior[U] =
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:276: [UnusedParameter] Parameter ctx is not used in method setBehavior.
[warn]       private def setBehavior(ctx: ActorContext[T], b: Behavior[T]): Unit =
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\PropsAdapter.scala:12: [UnusedParameter] Parameter deploy is not used in method apply.
[warn]   def apply(b: Behavior[_], deploy: DeploymentConfig): a.Props = new a.Props(a.Deploy(), classOf[ActorAdapter[_]], (b: AnyRef) :: Nil)
[warn]       ^
[warn] 12 warnings found
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-supervision-java-lambda\target\classes...
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-fsm-java-lambda\target\classes...
[info] Compiling 19 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:14: [JavaConverters] Consider using the explicit collection.JavaConverters instead of implicit conversions in collection.JavaConversions.
[warn] import scala.collection.JavaConversions._
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:23: [TypeToType] Using toMap on something that is already of type Map.
[warn]   def this(body: Any, headers: Map[String, Any]) = this(body, headers.toMap, Map.empty[String, DataHandler])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\CamelExchangeAdapter.scala:81: [JavaConverters] Consider using the explicit collection.JavaConverters instead of implicit conversions in collection.JavaConversions.
[warn]     import scala.collection.JavaConversions._
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\CamelExchangeAdapter.scala:97: [JavaConverters] Consider using the explicit collection.JavaConverters instead of implicit conversions in collection.JavaConversions.
[warn]     import scala.collection.JavaConversions._
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\component\ActorComponent.scala:162: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]       val async = try actorFor(endpoint.path).ask(messageFor(exchange))(Timeout(endpoint.replyTimeout)) catch { case NonFatal(e) ? Future.failed(e) }
[warn]           ^
[warn] there were two deprecation warnings; re-run with -deprecation for details
[warn] 6 warnings found
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 4 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-scala\target\classes...
[warn] there was one deprecation warning; re-run with -deprecation for details
[warn] one warning found
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java-lambda\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java-lambda\src\main\java\sample\persistence\ViewExample.java:46:  [deprecation] akka.persistence中的AbstractPersistentView已过时
[warn]   public static class ExampleView extends AbstractPersistentView {
[warn]                                           ^
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java\target\classes...
[info] 注: D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java\src\main\java\sample\persistence\PersistentViewExample.java使用或覆盖了已过时的 API。
[info] 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。
[info] Compiling 10 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalSpec.scala:221: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]           case WriteMessageSuccess(PersistentImpl(payload, 6L, Pid, _, _, Actor.noSender, WriterUuid), _) ? payload should be(s"b-6")
[warn]                                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalSpec.scala:228: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]           case WriteMessageSuccess(PersistentImpl(payload, 8L, Pid, _, _, Actor.noSender, WriterUuid), _) ? payload should be(s"b-8")
[warn]                                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:72: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(4), s"s-5")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:76: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(2), s"s-3")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:78: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(2), s"s-3")), 13))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:82: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(2), s"s-3")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:84: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(2), s"s-3")), 13))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:97: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(1), s"s-2")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:113: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(3), s"s-4")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:127: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(3), s"s-4")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:131: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       snapshotStore.tell(SaveSnapshot(md, s"s-5-modified"), senderProbe.ref)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalSpec.scala:58: [UnusedParameter] Parameter pid is not used in method preparePersistenceId.
[warn]   def preparePersistenceId(pid: String): Unit = ()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalSpec.scala:69: [UnusedParameter] Parameter confirms is not used in method replayedMessage.
[warn]   def replayedMessage(snr: Long, deleted: Boolean = false, confirms: Seq[String] = Nil): ReplayedMessage =
[warn]       ^
[warn] 13 warnings found
[info] Formatting 31 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster(test) ...
[info] Formatting 28 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence(test) ...
[info] Formatting 87 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote(test) ...
[info] Formatting 17 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-distributed-data-experimental(test) ...
[info] Formatting 11 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-testkit(test) ...
[info] Formatting 23 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-testkit(test) ...
[info] Formatting 145 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-tests(test) ...
[info] Formatting 6 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote-tests(test) ...
[info] Formatting 111 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-actor-tests(test) ...
[info] Compiling 123 Scala sources and 5 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\marshalling\Marshaller.scala:60: [UndesirableTypeInference] Inferred type akka.http.scaladsl.marshalling.Marshaller[A,Nothing]. (This might not be what you've intended)
[warn]     val scalaMarshaller = m.asScalaCastOutput
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\marshalling\Marshaller.scala:65: [UndesirableTypeInference] Inferred type akka.http.scaladsl.marshalling.Marshaller[A,Nothing]. (This might not be what you've intended)
[warn]     val scalaMarshaller = m.asScalaCastOutput
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\Rejections.scala:359: [MergeMaps] Merge these two map operations.
[warn]     val s1: Set[Alternative] = supportedContentTypes.asScala.map(_.asScala).map(ct ? ContentNegotiator.Alternative(ct)).toSet
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\Rejections.scala:360: [MergeMaps] Merge these two map operations.
[warn]     val s2: Set[Alternative] = supportedMediaTypes.asScala.map(_.asScala).map(mt ? ContentNegotiator.Alternative(mt)).toSet
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FramedEntityStreamingDirectives.scala:69: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.util.ByteString,Any]. (This might not be what you've intended)
[warn]         val bytes = entity.dataBytes
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\RangeDirectives.scala:88: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.util.ByteString,Any]. (This might not be what you've intended)
[warn]             val bytes = entity.dataBytes.via(flow)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:99: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[BP,Any]. (This might not be what you've intended)
[warn]                     val bodyParts = entity.dataBytes
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\PredefinedFromStringUnmarshallers.scala:68: [UndesirableTypeInference] Inferred type PartialFunction[Throwable,Nothing]. (This might not be what you've intended)
[warn]       catch numberFormatError(string, target)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\StrictForm.scala:67: Invalid implicitNotFound message for trait FieldUnmarshaller in object Field:

[warn] Missing argument `msg` on implicitNotFound annotation.
[warn]     sealed trait FieldUnmarshaller[T] {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\marshalling\Marshaller.scala:42: [UnusedParameter] Parameter target is not used in method downcast.
[warn]   def downcast[A, B1, B2 <: B1](m: Marshaller[A, B2], target: Class[B1]): Marshaller[A, B1] = m.asInstanceOf[Marshaller[A, B1]]
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\DebuggingDirectives.scala:35: [UnusedParameter] Parameter level is not used in method logRequest.
[warn]   def logRequest(marker: String, level: LogLevel, inner: Supplier[Route]): Route = RouteAdapter {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\DebuggingDirectives.scala:58: [UnusedParameter] Parameter level is not used in method logResult.
[warn]   def logResult(marker: String, level: LogLevel, inner: Supplier[Route]): Route = RouteAdapter {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\HeaderDirectives.scala:84: [UnusedParameter] Parameter clazz is not used in method magnetForModeledCustomHeader.
[warn]     def magnetForModeledCustomHeader(clazz: Class[T]): HeaderMagnet[T] = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\HeaderDirectives.scala:176: [UnusedParameter] Parameter u is not used in method fromUnitForModeledCustomHeader.
[warn]   implicit def fromUnitForModeledCustomHeader[T <: ModeledCustomHeader[T], H <: ModeledCustomHeaderCompanion[T]](u: Unit)(implicit tag: ClassTag[T], companion: ModeledCustomHeaderCompanion[T]): HeaderMagnet[T] =
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\HeaderDirectives.scala:205: [UnusedParameter] Parameter u is not used in method fromUnitNormalHeader.
[warn]   implicit def fromUnitNormalHeader[T <: HttpHeader](u: Unit)(implicit tag: ClassTag[T]): HeaderMagnet[T] =
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\ClassMagnet.scala:22: [UnusedParameter] Parameter u is not used in method fromUnit.
[warn]   implicit def fromUnit[T](u: Unit)(implicit tag: ClassTag[T]): ClassMagnet[T] = ClassMagnet(tag)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\TupleOps.scala:18: [UnusedParameter] Parameter op is not used in method foldLeft.
[warn]   def foldLeft[In](zero: In)(op: BinaryPolyFunc)(implicit fold: FoldLeft[In, T, op.type]): fold.Out = fold(zero, tuple)
[warn]       ^
[warn] there were 6 deprecation warnings; re-run with -deprecation for details
[warn] 18 warnings found
[info] Compiling 8 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:544: [UseExistsNotFindIsDefined] Use clients.exists(...) instead of clients.find(...).isDefined.
[warn]       if (clients.find(_.name == n.name).isDefined) throw new DuplicateNode(d, n)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:563: [UseExistsNotFindIsDefined] Use !clients.exists(...) instead of clients.find(...).isEmpty.
[warn]       else if (clients.find(_.fsm == sender()).isEmpty)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:284: [UseExistsNotFilterIsEmpty] Use col.forall(...) instead of col.filterNot(...).isEmpty.
[warn]           testConductor.getNodes.await.filterNot(_ == myself).isEmpty
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:236: [SuspiciousMatches] This regex starts with ^ or ends with $. The matches method always matches the entire string.
[warn]     val s = Thread.currentThread.getStackTrace map (_.getClassName) drop 1 dropWhile (_ matches ".*MultiNodeSpec.?$")
[warn]                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\PerfFlamesSupport.scala:25: [UnusedParameter] Parameter time is not used in method runPerfFlames.
[warn]   def runPerfFlames(nodes: RoleName*)(delay: FiniteDuration, time: FiniteDuration = 15.seconds): Unit = {
[warn]       ^
[warn] 5 warnings found
[info] Compiling 8 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-remote-scala\target\classes...
[info] Compiling 6 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-remote-java\target\classes...
[info] Compiling 19 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterDaemon.scala:468: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   ClusterCoreDaemon.this.context.stop(s);

[warn]   ClusterCoreDaemon.this.seedNodeProcess_=(scala.None)

[warn] }; None => {} } can be replaced with .foreach({

[warn]   ClusterCoreDaemon.this.context.stop(s);

[warn]   ClusterCoreDaemon.this.seedNodeProcess_=(scala.None)

[warn] })
[warn]     seedNodeProcess match {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:379: [UseOptionMapNotPatMatch] ... match { Some(x) => Some(EWMA.apply(value, alpha)); None => None} can be replaced with .map(EWMA.apply(value, alpha))
[warn]   private def ceateEWMA(value: Double, decayFactor: Option[Double]): Option[EWMA] = decayFactor match {
[warn]                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:546: [UseOptionForeachNotPatMatch] ... match { Some(x) => scala.this.Predef.require(0.0.<=(x).&&(x.<=(1.0)), scala.StringContext.apply("cpuCombined must be between [0.0 - 1.0], was [", "]").s(x)); None => {} } can be replaced with .foreach(scala.this.Predef.require(0.0.<=(x).&&(x.<=(1.0)), scala.StringContext.apply("cpuCombined must be between [0.0 - 1.0], was [", "]").s(x)))
[warn]     cpuCombined match {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Reachability.scala:107: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => 0L} can be replaced with .getOrElse(0L)
[warn]   private def currentVersion(observer: UniqueAddress): Long = versions.get(observer) match {
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Reachability.scala:264: [ReflexiveComparison] Same expression on both sides of the comparison.
[warn]       records.size == other.records.size && versions == versions &&
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:254: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   val routeeProps: akka.actor.Props = ClusterRouterPoolActor.this.cell.routeeProps;

[warn]   val deploy: akka.actor.Deploy = {

[warn]     <artifact> val x$6: com.typesafe.config.Config = com.typesafe.config.ConfigFactory.empty();

[warn]     <artifact> val x$7: akka.routing.RouterConfig = routeeProps.routerConfig;

[warn]     <artifact> val x$8: akka.remote.RemoteScope = akka.remote.RemoteScope.apply(target);

[warn]     <artifact> val x$9: String = akka.actor.Deploy.apply$default$1;

[warn]     <artifact> val x$10: String = akka.actor.Deploy.apply$default$5;

[warn]     <artifact> val x$11: String = akka.actor.Deploy.apply$default$6;

[warn]     akka.actor.Deploy.apply(x$9, x$6, x$7, x$8, x$10, x$11)

[warn]   };

[warn]   val routee: akka.routing.Routee = ClusterRouterPoolActor.this.pool.newRoutee(routeeProps.withDeploy(deploy), ClusterRouterPoolActor.this.context);

[warn]   ClusterRouterPoolActor.this.cell.addRoutee(routee);

[warn]   doAddRoutees()

[warn] }; None => {} } can be replaced with .foreach({

[warn]   val routeeProps: akka.actor.Props = ClusterRouterPoolActor.this.cell.routeeProps;

[warn]   val deploy: akka.actor.Deploy = {

[warn]     <artifact> val x$6: com.typesafe.config.Config = com.typesafe.config.ConfigFactory.empty();

[warn]     <artifact> val x$7: akka.routing.RouterConfig = routeeProps.routerConfig;

[warn]     <artifact> val x$8: akka.remote.RemoteScope = akka.remote.RemoteScope.apply(target);

[warn]     <artifact> val x$9: String = akka.actor.Deploy.apply$default$1;

[warn]     <artifact> val x$10: String = akka.actor.Deploy.apply$default$5;

[warn]     <artifact> val x$11: String = akka.actor.Deploy.apply$default$6;

[warn]     akka.actor.Deploy.apply(x$9, x$6, x$7, x$8, x$10, x$11)

[warn]   };

[warn]   val routee: akka.routing.Routee = ClusterRouterPoolActor.this.pool.newRoutee(routeeProps.withDeploy(deploy), ClusterRouterPoolActor.this.context);

[warn]   ClusterRouterPoolActor.this.cell.addRoutee(routee);

[warn]   doAddRoutees()

[warn] })
[warn]     def doAddRoutees(): Unit = selectDeploymentTarget match {
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:389: [UseOptionForallNotPatMatch] ... match { Some(x) => true; None => memberRoles.contains(r)} can be replaced with .forall(memberRoles.contains(r))
[warn]   private def satisfiesRole(memberRoles: Set[String]): Boolean = settings.useRole match {
[warn]                                                                                   ^
[warn] there were 18 deprecation warnings; re-run with -deprecation for details
[warn] 8 warnings found
[info] Compiling 24 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\PersistenceQuery.scala:52: [UnusedParameter] Parameter clazz is not used in method getReadJournalFor.
[warn]   final def getReadJournalFor[T <: javadsl.ReadJournal](clazz: Class[T], readJournalPluginId: String): T =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\journal\leveldb\EventsByPersistenceIdPublisher.scala:89: [UnusedParameter] Parameter limit is not used in method replaying.
[warn]   def replaying(limit: Int): Receive = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\journal\leveldb\EventsByTagPublisher.scala:91: [UnusedParameter] Parameter limit is not used in method replaying.
[warn]   def replaying(limit: Int): Receive = {
[warn]       ^
[warn] three warnings found
[info] Compiling 3 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-camel-scala\target\classes...
[info] Compiling 11 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-camel-java\target\classes...
[info] Compiling 23 Scala sources and 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\AkkaSpec.scala:116: [UnlikelyEquality] Comparing with == on instances of unrelated types (Set[A],T).
[warn]       def areEqual(a: Set[A], b: T) = a == b
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\AkkaSpecSpec.scala:36: [UndesirableTypeInference] Inferred type scala.collection.immutable.Map[String,Any]. (This might not be what you've intended)
[warn]       val conf = Map(
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\Coroner.scala:211: [IdenticalCaseBodies] Bodies of 2 neighbouring cases are identical and could be merged.
[warn]             case TIMED_WAITING ? appendMsg("\t-  waiting on ", ti.getLockInfo)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:44: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]         val worker = TestActorRef(Props[WorkerActor])
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:48: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]         val worker = TestActorRef(Props[WorkerActor])
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:121: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]         val a = TestActorRef(Props(new Actor {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:122: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]           val nested = TestActorRef(Props(new Actor { def receive = { case _ ? } }))
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:132: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]         val a = TestActorRef(Props(new Actor {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:145: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]       val serverRef = TestActorRef(Props[ReplyActor])
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:146: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]       val clientRef = TestActorRef(Props(classOf[SenderActor], serverRef))
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:171: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]         val a = TestActorRef(Props[WorkerActor])
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:192: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]         val boss = TestActorRef(Props(new TActor {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:193: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]           val ref = TestActorRef(Props(new TActor {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:253: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]       val a = TestActorRef(Props[WorkerActor].withDispatcher("disp1"))
[warn]           ^
[warn] there were 7 deprecation warnings; re-run with -deprecation for details
[warn] 15 warnings found
[info] Compiling 15 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\TestRouteResult.scala:184: [UseContainsNotExistsEquals] Use col.contains(expected) instead of col.exists(x$2 == expected)
[warn]     assertTrue(response.headers.exists(_ == expected), s"Header $expected was missing.")
[warn]                                       ^
[warn] one warning found
[info] Compiling 1 Scala source to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-marshallers-scala\akka-http-xml\target\classes...
[info] Compiling 2 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-marshallers-scala\akka-http-spray-json\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-marshallers-scala\akka-http-spray-json\src\main\scala\akka\http\scaladsl\marshallers\sprayjson\SprayJsonSupport.scala:47: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[akka.util.ByteString,Any]. (This might not be what you've intended)
[warn]         val frames = e.dataBytes.via(support.framingDecoder)
[warn]             ^
[warn] one warning found
[info] Compiling 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-marshallers-java\akka-http-jackson\target\classes...
[info] Compiling 20 Scala sources and 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\GCounter.scala:82: [UnlikelyEquality] Comparing with == on instances of unrelated types (BigInt,Int).
[warn]     if (delta == 0) this
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:107: [UseContainsNotExistsEquals] Use col.contains(v) instead of col.exists(x$2 == v)
[warn]               case (thisDotNode, v) ? rhsVs.get(thisDotNode).exists(_ == v)
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:981: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   val msg: Product with Serializable = if (envelope.data.==(Replicator.Internal.DeletedData))

[warn]     Replicator.DataDeleted.apply[akka.cluster.ddata.ReplicatedData](key)

[warn]   else

[warn]     Replicator.Changed.apply[akka.cluster.ddata.ReplicatedData](key)(envelope.data);

[warn]   subs.foreach[Unit](((x$3: akka.actor.ActorRef) => akka.this.actor.`package`.actorRef2Scala(x$3).!(msg)(Replicator.this.self)))

[warn] }; None => {} } can be replaced with .foreach({

[warn]   val msg: Product with Serializable = if (envelope.data.==(Replicator.Internal.DeletedData))

[warn]     Replicator.DataDeleted.apply[akka.cluster.ddata.ReplicatedData](key)

[warn]   else

[warn]     Replicator.Changed.apply[akka.cluster.ddata.ReplicatedData](key)(envelope.data);

[warn]   subs.foreach[Unit](((x$3: akka.actor.ActorRef) => akka.this.actor.`package`.actorRef2Scala(x$3).!(msg)(Replicator.this.self)))

[warn] })
[warn]       getData(keyId) match {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:1079: [UseOptionForeachNotPatMatch] ... match { Some(x) => if (hadData.||(d.pruning.nonEmpty))

[warn]   replyData = replyData.updated[akka.cluster.ddata.Replicator.Internal.DataEnvelope](key, d)

[warn] else

[warn]   (); None => {} } can be replaced with .foreach(if (hadData.||(d.pruning.nonEmpty))

[warn]   replyData = replyData.updated[akka.cluster.ddata.Replicator.Internal.DataEnvelope](key, d)

[warn] else

[warn]   ())
[warn]         if (sendBack) getData(key) match {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\VersionVector.scala:324: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => 0L} can be replaced with .getOrElse(0L)
[warn]   private[akka] override def versionAt(node: UniqueAddress): Long = versions.get(node) match {
[warn]                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:184: [UndesirableTypeInference] Inferred type scala.collection.immutable.Map[akka.cluster.ddata.protobuf.msg.ReplicatorMessages.OtherMessage,Any]. (This might not be what you've intended)
[warn]     var otherElementsMap = Map.empty[dm.OtherMessage, Any]
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:200: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val element = iter.next() match {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:243: [UndesirableTypeInference] Inferred type scala.collection.immutable.Map[Any,akka.cluster.ddata.VersionVector]. (This might not be what you've intended)
[warn]     val elementsMap = elements.zip(dots).toMap
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:438: [UseOptionForeachNotPatMatch] ... match { Some(x) => b.setEnvelope(ReplicatorMessageSerializer.this.dataEnvelopeToProto(d)); None => {} } can be replaced with .foreach(b.setEnvelope(ReplicatorMessageSerializer.this.dataEnvelopeToProto(d)))
[warn]     readResult.envelope match {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:260: [UnusedParameter] Parameter node is not used in method remove.
[warn]   private[akka] def remove(node: UniqueAddress, element: A): ORSet[A] =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:273: [UnusedParameter] Parameter node is not used in method clear.
[warn]   private[akka] def clear(node: UniqueAddress): ORSet[A] =
[warn]                     ^
[warn] 11 warnings found
[info] Compiling 8 Scala sources and 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:463: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val (m, _) = buffer.removeFirst()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:474: [UndesirableTypeInference] Inferred type (Any, akka.actor.ActorRef). (This might not be what you've intended)
[warn]       val (msg, snd) = buffer.removeFirst()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:474: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val (msg, snd) = buffer.removeFirst()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:909: [UseGetOrElseNotPatMatch] ... match { Some(x) => x; None => ClusterReceptionist.this.context.actorOf(akka.actor.Props.apply(classOf[akka.cluster.client.ClusterReceptionist$$Internal$ClientResponseTunnel], client, ClusterReceptionist.this.settings.responseTunnelReceiveTimeout), encName)} can be replaced with .getOrElse(ClusterReceptionist.this.context.actorOf(akka.actor.Props.apply(classOf[akka.cluster.client.ClusterReceptionist$$Internal$ClientResponseTunnel], client, ClusterReceptionist.this.settings.responseTunnelReceiveTimeout), encName))
[warn]     context.child(encName) match {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:354: [UseOptionForeachNotPatMatch] ... match { Some(x) => g.forward(msg)(Topic.this.context); None => {} } can be replaced with .foreach(g.forward(msg)(Topic.this.context))
[warn]             context.child(encGroup) match {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:613: [UseOptionForeachNotPatMatch] ... match { Some(x) => t.forward(msg)(DistributedPubSubMediator.this.context); None => {} } can be replaced with .foreach(t.forward(msg)(DistributedPubSubMediator.this.context))
[warn]         context.child(encTopic) match {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:239: [UseOptionForallNotPatMatch] ... match { Some(x) => true; None => member.hasRole(r)} can be replaced with .forall(member.hasRole(r))
[warn]       def matchingRole(member: Member): Boolean = role match {
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:164: [UseOptionForallNotPatMatch] ... match { Some(x) => true; None => member.hasRole(r)} can be replaced with .forall(member.hasRole(r))
[warn]   def matchingRole(member: Member): Boolean = role match {
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:246: [UseContainsNotExistsEquals] Use col.contains(ref) instead of col.exists(x$2 == ref)
[warn]       if (singleton.exists(_ == ref)) {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:269: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val (m, _) = buffer.removeFirst()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:281: [UndesirableTypeInference] Inferred type (Any, akka.actor.ActorRef). (This might not be what you've intended)
[warn]       val (msg, snd) = buffer.removeFirst()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:281: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val (msg, snd) = buffer.removeFirst()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:49: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         case "consistent-hashing" ? throw new IllegalArgumentException(s"'consistent-hashing' routing logic can't be used by the pub-sub mediator")
[warn]                                                                        ^
[warn] there was one deprecation warning; re-run with -deprecation for details
[warn] 14 warnings found
[info] Compiling 10 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsRouting.scala:294: [YodaConditions] Yoda conditions using you are.
[warn]   require(0.0 <= factor, s"factor must be non negative: ${factor}")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Metric.scala:88: [UseOptionMapNotPatMatch] ... match { Some(x) => Some(EWMA.apply(value, alpha)); None => None} can be replaced with .map(EWMA.apply(value, alpha))
[warn]   def createEWMA(value: Double, decayFactor: Option[Double]): Option[EWMA] = decayFactor match {
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Metric.scala:217: [UseOptionForeachNotPatMatch] ... match { Some(x) => scala.this.Predef.require(0.0.<=(x).&&(x.<=(1.0)), scala.StringContext.apply("cpuCombined must be between [0.0 - 1.0], was [", "]").s(x)); None => {} } can be replaced with .foreach(scala.this.Predef.require(0.0.<=(x).&&(x.<=(1.0)), scala.StringContext.apply("cpuCombined must be between [0.0 - 1.0], was [", "]").s(x)))
[warn]     cpuCombined match {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Metric.scala:222: [UseOptionForeachNotPatMatch] ... match { Some(x) => scala.this.Predef.require(0.0.<=(x).&&(x.<=(1.0)), scala.StringContext.apply("cpuStolen must be between [0.0 - 1.0], was [", "]").s(x)); None => {} } can be replaced with .foreach(scala.this.Predef.require(0.0.<=(x).&&(x.<=(1.0)), scala.StringContext.apply("cpuStolen must be between [0.0 - 1.0], was [", "]").s(x)))
[warn]     cpuStolen match {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsCollector.scala:71: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       log.debug(s"Collection started.")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsCollector.scala:74: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       log.debug(s"Collection stopped.")
[warn]                 ^
[warn] 6 warnings found
[info] Compiling 28 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:175: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectDone() // by sender
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:207: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]         probe.expectMsg(ReqAck)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:238: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       probe.expectMsg(ReqAck)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:310: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       probe.expectMsg(ReqAck)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:340: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       probe.expectMsg(ReqAck)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:58: [UndesirableTypeInference] Inferred type Any => Unit. (This might not be what you've intended)
[warn]     val doNothing = (_: Any) ? ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorRecoveryTimeoutSpec.scala:125: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       SteppingInmemJournal.step(journal)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorStashingSpec.scala:221: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       SteppingInmemJournal.step(journal)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentViewSpec.scala:59: [UseQuantifierFuncNotFold] Unless there are side-effects, this col.foldLeft can be replaced by col.exists.
[warn]       failAt.foldLeft(false) { (a, f) ? a || (m == f) }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentViewSpec.scala:86: [UseQuantifierFuncNotFold] Unless there are side-effects, this col.foldLeft can be replaced by col.exists.
[warn]       failAt.foldLeft(false) { (a, f) ? a || (m == f) }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentViewSpec.scala:252: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       viewProbe.expectMsg("replicated-a-1")
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\fsm\PersistentFSMSpec.scala:301: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg(NonEmptyShoppingCart(List(shirt, shoes, coat)))
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:18: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     s"""
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:160: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]         log.debug(s"sender stopped, starting it again")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\chaos\ChaosJournal.scala:23: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   extends TestException(s"recovery failed when reading highest sequence number")
[warn]                         ^
[warn] there were 7 deprecation warnings; re-run with -deprecation for details
[warn] 16 warnings found
[info] 注: D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\java\akka\persistence\fsm\AbstractPersistentFSMTest.java使用或覆盖了已过时的 API。
[info] 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。
[info] Compiling 11 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Coroner.scala:212: [IdenticalCaseBodies] Bodies of 2 neighbouring cases are identical and could be merged.
[warn]             case TIMED_WAITING ? appendMsg("\t-  waiting on ", ti.getLockInfo)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Utils.scala:30: [VariableAssignedUnusedValue] Variable children has an unused value before this reassign.
[warn]             children = probe.expectMsgType[StreamSupervisor.Children].children
[warn]                      ^
[warn] two warnings found
[info] Compiling 111 Scala sources and 21 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorDSLSpec.scala:94: [UndesirableTypeInference] Inferred type scala.collection.immutable.IndexedSeq[Any]. (This might not be what you've intended)
[warn]         val gotit = for (_ ← 1 to 1000) yield i.receive()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorLookupSpec.scala:244: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val lookup = Await.result(looker ? query, timeout.duration)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:240: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]             actorOf(Props(new OuterActor(actorOf(Props(promiseIntercept({ new InnerActor; new InnerActor })(result)))))))
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:359: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]       val inner = Await.result(a ? "innerself", timeout.duration)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorTimeoutSpec.scala:31: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]       val f = echo.?("hallo")(testTimeout)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithStashSpec.scala:41: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]           stash()
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithStashSpec.scala:181: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg("terminated")
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeathWatchSpec.scala:76: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectTerminationOf(terminal)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeathWatchSpec.scala:103: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectTerminationOf(terminal)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeathWatchSpec.scala:120: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]         terminal ! Kill
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\HotSwapSpec.scala:53: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       a ! "pigdog"
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:55: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg(Tock)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:63: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg(Tock)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:768: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]         boss ! "killCrasher"
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorMiscSpec.scala:79: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg("preStart")
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorSpec.scala:181: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]     val result = (pingPongActor.?(DieReply)(DilatedTimeout))
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorSpec.scala:313: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg(Timeout, ExceptionMessage)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorSpec.scala:327: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg(Timeout, ExceptionMessage)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorSpec.scala:364: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg(Timeout, ExceptionMessage)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:98: [AssigningOptionToNull] You probably meant None, not null.
[warn]     def nullOption(): Option[Any] = null
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:96: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       case DoubleStop                   ? { ack(); context.stop(self); context.stop(self); busy.switchOff }
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:145: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]       val a = TestActorRef(Props(new Actor {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:153: [UndesirableTypeInference] Inferred type akka.testkit.TestActorRef[Nothing]. (This might not be what you've intended)
[warn]       val b = TestActorRef(Props(new Actor {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ForkJoinPoolStarvationSpec.scala:53: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       system.actorOf(Props(new SelfBusyActor).withDispatcher("actorhang.task-dispatcher"))
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:321: [DivideByZero] Possible division by zero.
[warn]           val future2 = future1 map (_ / 0)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:515: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]           val f1 = Future[Any] { throw new ThrowableTest("test") }
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:100: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       bus.publish(event)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:103: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg(event)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventStreamSpec.scala:387: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]         fishForDebugMessage(a1, s"watching ${a2.ref}", 1 second)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\LoggerSpec.scala:122: [UndesirableTypeInference] Inferred type scala.collection.immutable.Map[_ <: String, Any]. (This might not be what you've intended)
[warn]       val perMessage = currentMessage match {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:242: [UseMinOrMaxNotSort] Use col.minBy instead of col.sortBy.head.
[warn]             .head
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\AskSpec.scala:30: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]       val f = dead.ask(42)(1 second)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\AskSpec.scala:51: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]       val f = ask(null: ActorRef, 3.14)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\CircuitBreakerSpec.scala:298: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Nothing]. (This might not be what you've intended)
[warn]       val fut = breaker().withCircuitBreaker(Future {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\PatternSpec.scala:62: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Nothing]. (This might not be what you've intended)
[warn]       val f = akka.pattern.after(1 second, using = system.scheduler)(Promise.failed(new IllegalStateException("Mexico")).future)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\PromiseRefSpec.scala:27: [UndesirableTypeInference] Inferred type akka.pattern.PromiseRef[Any]. (This might not be what you've intended)
[warn]       val promiseRef = PromiseRef(5.seconds)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\PromiseRefSpec.scala:47: [UndesirableTypeInference] Inferred type akka.pattern.PromiseRef[Any]. (This might not be what you've intended)
[warn]       val promiseRef = PromiseRef(5.seconds)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RandomSpec.scala:31: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       actor ! "hello"
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ResizerSpec.scala:147: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       router ! latch
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ResizerSpec.scala:162: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       router ! latch
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoundRobinSpec.scala:38: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       actor ! "hello"
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoutingSpec.scala:59: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       router ! ""
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoutingSpec.scala:68: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]         router ! ""
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoutingSpec.scala:187: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg("restarted")
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\TailChoppingSpec.scala:34: [UndesirableTypeInference] Inferred type Seq[Any]. (This might not be what you've intended)
[warn]     val results = ref.map(p ? f(p))
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\TailChoppingSpec.scala:40: [UndesirableTypeInference] Inferred type Seq[Any]. (This might not be what you've intended)
[warn]     val results = ref.map(p ? f(p))
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:144: [UnlikelyEquality] Comparing with == on instances of unrelated types (akka.util.ByteString,scala.collection.immutable.Vector[Byte]).
[warn]     bsBuilder.result == vecBuilder.result
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\TokenBucketSpec.scala:165: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       bucket.offer(0)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\TokenBucketSpec.scala:173: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       bucket.offer(0)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorMailboxSpec.scala:16: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val mailboxConf = ConfigFactory.parseString(s"""
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoutingSpec.scala:85: [InvariantReturn] This method always returns the same value: 2.
[warn]           2
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoutingSpec.scala:122: [InvariantReturn] This method always returns the same value: 3.
[warn]           3
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:26: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val serializeConf = s"""
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FSMActorSpec.scala:81: [UnusedParameter] Parameters (from, to) are not used in method transitionHandler.
[warn]     def transitionHandler(from: LockState, to: LockState) = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:107: [UnusedParameter] Parameters (foo, s, i) are not used in method testMethodCallSerialization.
[warn]     def testMethodCallSerialization(foo: Foo, s: String, i: Int): Unit = throw new IllegalStateException("expected")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:445: [UnusedParameter] Parameter testNumber is not used in method test.
[warn]         def test(testNumber: Int) {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:749: [UnusedParameter] Parameter in is not used in method checkType.
[warn]   def checkType[A: ClassTag, B](in: Future[A], reftag: ClassTag[B]): Boolean = implicitly[ClassTag[A]].runtimeClass == reftag.runtimeClass
[warn]       ^
[warn] there were 100 deprecation warnings; re-run with -deprecation for details
[warn] 58 warnings found
[info] Compiling 5 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-tests\target\classes...
[info] Compiling 5 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-distributed-data-java\target\classes...
[info] Compiling 5 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-distributed-data-scala\target\classes...
[info] Compiling 8 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\circuitbreaker\CircuitBreakerProxy.scala:60: [UnextendedSealedTrait] This sealed trait is never extended
[warn]   sealed trait CircuitBreakerEvent
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\circuitbreaker\CircuitBreakerProxy.scala:57: [UnextendedSealedTrait] This sealed trait is never extended
[warn]   sealed trait CircuitBreakerResponse
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\circuitbreaker\CircuitBreakerProxy.scala:180: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val failureNotification = failureMap(CircuitOpenFailure(message))
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\circuitbreaker\CircuitBreakerProxy.scala:208: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]         val failureNotification = failureMap(CircuitOpenFailure(message))
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\circuitbreaker\askExtensions.scala:69: [PassPartialFunctionDirectly] You can pass the partial function in directly. (Remove `_ match {`).
[warn]     future.flatMap {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:48: [UseConditionDirectly] Remove the if expression and use the condition directly.
[warn]     else if (processing && (addBuffer remove fn)) true
[warn]                         ^
[warn] there was one deprecation warning; re-run with -deprecation for details
[warn] 7 warnings found
[info] Compiling 8 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:128: postfix operator milliseconds should be enabled
[warn] by making the implicit value scala.language.postfixOps visible.
[warn] This can be achieved by adding the import clause 'import scala.language.postfixOps'
[warn] or by setting the compiler option -language:postfixOps.
[warn] See the Scaladoc for value scala.language.postfixOps for a discussion
[warn] why the feature should be explicitly enabled.
[warn]         100 milliseconds,
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\Shard.scala:203: [UseContainsNotExistsEquals] Use col.contains(ref) instead of col.exists(x$1 == ref)
[warn]     if (handOffStopper.exists(_ == ref))
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\Shard.scala:265: [UndesirableTypeInference] Inferred type (akka.cluster.sharding.ShardRegion.EntityId, Any). (This might not be what you've intended)
[warn]     val (id, payload) = extractEntityId(msg)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\Shard.scala:265: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]     val (id, payload) = extractEntityId(msg)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:544: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   ShardCoordinator.this.log.debug("Graceful shutdown of region [{}] with shards [{}]", region, shards);

[warn]   ShardCoordinator.this.gracefulShutdownInProgress_=(ShardCoordinator.this.gracefulShutdownInProgress.+(region));

[warn]   ShardCoordinator.this.continueRebalance(shards.toSet[akka.cluster.sharding.ShardRegion.ShardId])

[warn] }; None => {} } can be replaced with .foreach({

[warn]   ShardCoordinator.this.log.debug("Graceful shutdown of region [{}] with shards [{}]", region, shards);

[warn]   ShardCoordinator.this.gracefulShutdownInProgress_=(ShardCoordinator.this.gracefulShutdownInProgress.+(region));

[warn]   ShardCoordinator.this.continueRebalance(shards.toSet[akka.cluster.sharding.ShardRegion.ShardId])

[warn] })
[warn]         state.regions.get(region) match {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardRegion.scala:386: [UseOptionForallNotPatMatch] ... match { Some(x) => true; None => member.hasRole(r)} can be replaced with .forall(member.hasRole(r))
[warn]   def matchingRole(member: Member): Boolean = role match {
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardRegion.scala:667: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   ShardRegion.this.log.debug("Deliver [{}] buffered messages for shard [{}]", buf.size, shardId);

[warn]   buf.foreach[Unit](((x0$5: (akka.cluster.sharding.ShardRegion.Msg, akka.actor.ActorRef)) => x0$5 match {

[warn]     case (_1: Any, _2: akka.actor.ActorRef)(Any, akka.actor.ActorRef)((msg @ _), (snd @ _)) => receiver.tell(msg, snd)

[warn]   }));

[warn]   ShardRegion.this.shardBuffers_=(ShardRegion.this.shardBuffers.-(shardId))

[warn] }; None => {} } can be replaced with .foreach({

[warn]   ShardRegion.this.log.debug("Deliver [{}] buffered messages for shard [{}]", buf.size, shardId);

[warn]   buf.foreach[Unit](((x0$5: (akka.cluster.sharding.ShardRegion.Msg, akka.actor.ActorRef)) => x0$5 match {

[warn]     case (_1: Any, _2: akka.actor.ActorRef)(Any, akka.actor.ActorRef)((msg @ _), (snd @ _)) => receiver.tell(msg, snd)

[warn]   }));

[warn]   ShardRegion.this.shardBuffers_=(ShardRegion.this.shardBuffers.-(shardId))

[warn] })
[warn]     shardBuffers.get(shardId) match {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardRegion.scala:732: [UseContainsNotExistsEquals] Use col.contains(id) instead of col.exists(x$8 == id)
[warn]           case Some(props) if !shardsByRef.values.exists(_ == id) ?
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\RemoveInternalClusterShardingData.scala:83: [UnusedParameter] Parameter terminateSystem is not used in method remove.
[warn]   def remove(system: ActorSystem, journalPluginId: String, typeNames: Set[String],
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\Shard.scala:284: [UnusedParameter] Parameter msg is not used in method deliverTo.
[warn]   def deliverTo(id: EntityId, msg: Any, payload: Msg, snd: ActorRef): Unit = {
[warn]       ^
[warn] 10 warnings found
[info] Compiling 18 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-cluster-scala\target\classes...
[info] Compiling 27 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-cluster-java\target\classes...
[info] Compiling 145 Scala sources and 17 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowZipWithSpec.scala:47: [OperationAlwaysProducesZero] This integer division will always return 0.
[warn]       probe.expectNext(1 / -2)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphUnzipWithSpec.scala:170: [OperationAlwaysProducesZero] This integer division will always return 0.
[warn]       leftProbe.expectNext(1 / -2)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphZipWithNSpec.scala:68: [OperationAlwaysProducesZero] This integer division will always return 0.
[warn]       probe.expectNext(1 / 2 / -1)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphZipWithSpec.scala:66: [OperationAlwaysProducesZero] This integer division will always return 0.
[warn]       probe.expectNext(1 / -2)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:155: [MergeMaps] Merge these two map operations.
[warn]       j ← jMethods
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:165: [InefficientUseOfListSize] Use matches.isEmpty instead of comparing to matches.length. (matches is a List, length takes O(n) time)
[warn]       if (matches.length == 0) {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:238: [TypeToType] Using toList on something that is already of type List.
[warn]     (scalaParams.toList, javaParams.toList) match {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:238: [TypeToType] Using toList on something that is already of type List.
[warn]     (scalaParams.toList, javaParams.toList) match {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:246: [UseConditionDirectly] Remove the if expression and use the condition directly.
[warn]     else if (`scala -> java types` contains p) true
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:399: [OnceEvaluatedStatementsInBlockReturningFunction] You're passing a block that returns a function. The statements in this block, except the last one, will only be executed once.
[warn]       (0 to 10).foreach {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:415: [UndesirableTypeInference] Inferred type org.reactivestreams.Publisher[Nothing]. (This might not be what you've intended)
[warn]         val pub = ActorPublisher(a)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:421: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Nothing]. (This might not be what you've intended)
[warn]         val sub = TestSubscriber.manualProbe()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:438: [UndesirableTypeInference] Inferred type org.reactivestreams.Publisher[Nothing]. (This might not be what you've intended)
[warn]         val pub = ActorPublisher(system.actorOf(timeoutingProps(testActor, timeout)))
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:486: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       probe.expectMsg(TotalDemand(5))
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorSubscriberSpec.scala:142: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       ref ! "ready"
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorSubscriberSpec.scala:170: [UndesirableTypeInference] Inferred type org.reactivestreams.Subscriber[Nothing]. (This might not be what you've intended)
[warn]       val sub = ActorSubscriber(ref)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\FixedBufferSpec.scala:16: [UndesirableTypeInference] Inferred type akka.stream.impl.FixedSizeBuffer.FixedSizeBuffer[Nothing]. (This might not be what you've intended)
[warn]         val buf = FixedSizeBuffer(size)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\TimeoutsSpec.scala:257: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Flow[Any,Int,scala.concurrent.Future[akka.Done]]. (This might not be what you've intended)
[warn]       val upstream = Flow.fromSinkAndSourceMat(Sink.ignore, Source.fromPublisher(upstreamWriter))(Keep.left)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\TimeoutsSpec.scala:258: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Flow[Any,String,scala.concurrent.Future[akka.Done]]. (This might not be what you've intended)
[warn]       val downstream = Flow.fromSinkAndSourceMat(Sink.ignore, Source.fromPublisher(downstreamWriter))(Keep.left)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:226: [UndesirableTypeInference] Inferred type Any. (This might not be what you've intended)
[warn]           val internalEvent = portToConn(in.id).slot
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterSpec.scala:22: [UndesirableTypeInference] Inferred type akka.stream.impl.fusing.Take[Nothing]. (This might not be what you've intended)
[warn]   val takeOne = Take(1)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterSpec.scala:23: [UndesirableTypeInference] Inferred type akka.stream.impl.fusing.Take[Nothing]. (This might not be what you've intended)
[warn]   val takeTwo = Take(2)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterStressSpec.scala:20: [UndesirableTypeInference] Inferred type akka.stream.impl.fusing.Drop[Nothing]. (This might not be what you've intended)
[warn]   val dropOne = Drop(1)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterStressSpec.scala:21: [UndesirableTypeInference] Inferred type akka.stream.impl.fusing.Take[Nothing]. (This might not be what you've intended)
[warn]   val takeOne = Take(1)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterStressSpec.scala:22: [UndesirableTypeInference] Inferred type akka.stream.impl.fusing.Take[Nothing]. (This might not be what you've intended)
[warn]   val takeHalfOfRepetition = Take(repetition / 2)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:96: [TypeToType] Using toString on something that is already of type String.
[warn]       c.expectNext().utf8String should ===(nextChunk().toString)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:98: [TypeToType] Using toString on something that is already of type String.
[warn]       c.expectNext().utf8String should ===(nextChunk().toString)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:102: [TypeToType] Using toString on something that is already of type String.
[warn]       var expectedChunk = nextChunk().toString
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:105: [TypeToType] Using toString on something that is already of type String.
[warn]         expectedChunk = nextChunk().toString
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSinkSpec.scala:34: [UseHeadNotApply] It is idiomatic to use datas.head instead of datas(0) for List
[warn]       p.expectMsg(datas(0).utf8String)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSourceSpec.scala:33: [NumberInstanceOf] Use toByte instead of asInstanceOf[Byte].
[warn]   val bytesArray = Array.fill[Byte](3)(Random.nextInt(1024).asInstanceOf[Byte])
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpHelper.scala:62: [UseOptionForeachNotPatMatch] ... match { Some(x) => akka.actor.`package`.actorRef2Scala(TestClient.this.connection).!(cmd)(TestClient.this.self); None => {} } can be replaced with .foreach(akka.actor.`package`.actorRef2Scala(TestClient.this.connection).!(cmd)(TestClient.this.self))
[warn]         closeAfterWrite match {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:51: [NumberInstanceOf] Use toByte instead of asInstanceOf[Byte].
[warn]       val expectedOutput = ByteString(Array.tabulate(256)(_.asInstanceOf[Byte]))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:63: [NumberInstanceOf] Use toByte instead of asInstanceOf[Byte].
[warn]       val expectedOutput = ByteString(Array.tabulate(256)(_.asInstanceOf[Byte]))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:436: [NumberInstanceOf] Use toByte instead of asInstanceOf[Byte].
[warn]       val expectedOutput = ByteString(Array.tabulate(256)(_.asInstanceOf[Byte]))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:459: [NumberInstanceOf] Use toByte instead of asInstanceOf[Byte].
[warn]       val expectedOutput = ByteString(Array.tabulate(256)(_.asInstanceOf[Byte]))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TlsSpec.scala:417: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestPublisher.Probe[Nothing]. (This might not be what you've intended)
[warn]       val pub = TestPublisher.probe()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TlsSpec.scala:434: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestPublisher.Probe[Nothing]. (This might not be what you've intended)
[warn]       val pub = TestPublisher.probe()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\ActorRefBackpressureSinkSpec.scala:122: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Sink[Any,akka.NotUsed]. (This might not be what you've intended)
[warn]       val sink = Sink.actorRefWithAck(fw, initMessage, ackMessage, completeMessage)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\ActorRefBackpressureSinkSpec.scala:166: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Sink[Any,akka.NotUsed]. (This might not be what you've intended)
[warn]         val badSink = Sink
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\BidiFlowSpec.scala:62: [TypeToType] Using toInt on something that is already of type Int.
[warn]       val f = Flow[String].map(Integer.valueOf(_).toInt).join(bidi)
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\BidiFlowSpec.scala:82: [TypeToType] Using toInt on something that is already of type Int.
[warn]         Flow[String].map(Integer.valueOf(_).toInt) <~> bidi <~> Flow[Long].map(x ? ByteString(s"Hello $x"))
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\BidiFlowSpec.scala:92: [TypeToType] Using toInt on something that is already of type Int.
[warn]         val flow = b.add(Flow[String].map(Integer.valueOf(_).toInt))
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowCompileSpec.scala:55: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       "appended.run()" shouldNot compile
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowCompileSpec.scala:63: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       "closedSource2.run()" shouldNot compile
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:32: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]       val subs = TestSubscriber.manualProbe[Any]()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:33: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Sink[Any,org.reactivestreams.Publisher[Any]]. (This might not be what you've intended)
[warn]       val subSink = Sink.asPublisher[Any](false)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:35: [UndesirableTypeInference] Inferred type org.reactivestreams.Publisher[Any]. (This might not be what you've intended)
[warn]       val (_, res) = f1.concat(s2).runWith(s1, subSink)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:49: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]       val subs = TestSubscriber.manualProbe[Any]()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:50: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Sink[Any,org.reactivestreams.Publisher[Any]]. (This might not be what you've intended)
[warn]       val subSink = Sink.asPublisher[Any](false)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:52: [UndesirableTypeInference] Inferred type org.reactivestreams.Publisher[Any]. (This might not be what you've intended)
[warn]       val (_, res) = f2.prepend(s1).runWith(s2, subSink)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowExpandSpec.scala:111: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       pending += publisher.expectRequest()
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupBySpec.scala:76: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (key, substream) = masterSubscriber.expectNext()
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupBySpec.scala:220: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (_, substream) = subscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupedWithinSpec.scala:36: [TypeToType] Using toInt on something that is already of type Int.
[warn]       c.expectNext((1 to (demand1 + demand2).toInt).toVector)
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupedWithinSpec.scala:39: [TypeToType] Using toInt on something that is already of type Int.
[warn]       c.expectNext(((demand1 + demand2 + 1).toInt to (demand1 + demand2 + demand3).toInt).toVector)
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupedWithinSpec.scala:39: [TypeToType] Using toInt on something that is already of type Int.
[warn]       c.expectNext(((demand1 + demand2 + 1).toInt to (demand1 + demand2 + demand3).toInt).toVector)
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:21: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestPublisher.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:21: [UndesirableTypeInference] Inferred type akka.stream.FlowMonitor[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:21: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:29: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestPublisher.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:29: [UndesirableTypeInference] Inferred type akka.stream.FlowMonitor[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:29: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:36: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestPublisher.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:36: [UndesirableTypeInference] Inferred type akka.stream.FlowMonitor[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:36: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:45: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestPublisher.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:45: [UndesirableTypeInference] Inferred type akka.stream.FlowMonitor[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:45: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:53: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestPublisher.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:53: [UndesirableTypeInference] Inferred type akka.stream.FlowMonitor[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:53: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:64: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestPublisher.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:64: [UndesirableTypeInference] Inferred type akka.stream.FlowMonitor[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMonitorSpec.scala:64: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val ((source, monitor), sink) =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:30: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (prefix, tailFlow) = Await.result(fut, 3.seconds)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:40: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (prefix, tailFlow) = Await.result(fut, 3.seconds)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:50: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (takes, tail) = Await.result(fut, 3.seconds)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:61: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (takes, tail) = Await.result(fut, 3.seconds)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:72: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (takes, tail) = Await.result(fut, 3.seconds)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:83: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (takes, tail) = Await.result(fut, 3.seconds)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:94: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (takes, tail) = Await.result(fut, 3.seconds)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:118: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (takes, tail) = Await.result(fut, 3.seconds)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:135: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (takes, tail) = Await.result(fut, 3.seconds)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:149: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (takes, tail) = Await.result(fut, 3.seconds)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:185: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (head, tail) = subscriber.expectNext()
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowPrefixAndTailSpec.scala:230: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (head, tail) = subscriber.expectNext()
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowReduceSpec.scala:22: [UseFuncNotReduce] Use inputSource.sum instead of inputSource.reduce.
[warn]     val reduceSource = inputSource.reduce[Int](_ + _).filter(_ ? true).map(identity)
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowReduceSpec.scala:23: [UseFuncNotReduce] Use col.sum instead of col.reduce.
[warn]     val reduceFlow = Flow[Int].filter(_ ? true).map(identity).reduce(_ + _).filter(_ ? true).map(identity)
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowReduceSpec.scala:24: [UseFuncNotReduce] Use Sink.sum instead of Sink.reduce.
[warn]     val reduceSink = Sink.reduce[Int](_ + _)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowReduceSpec.scala:48: [UndesirableTypeInference] Inferred type scala.concurrent.Future[Any]. (This might not be what you've intended)
[warn]       val future = inputSource.map(x ? if (x > 50) throw error else x).runReduce(Keep.none)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:58: [UndesirableTypeInference] Inferred type akka.stream.impl.fusing.Map[Any,Any]. (This might not be what you've intended)
[warn]     val stage = fusing.Map({ x: Any ? x })
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:326: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]         val downstream2 = TestSubscriber.manualProbe[Any]()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:353: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]         val downstream2 = TestSubscriber.manualProbe[Any]()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:405: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]         val downstream2 = TestSubscriber.manualProbe[Any]()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:431: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]         val downstream2 = TestSubscriber.manualProbe[Any]()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:468: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]         val downstream2 = TestSubscriber.manualProbe[Any]()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:497: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]         val downstream3 = TestSubscriber.manualProbe[Any]()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:528: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]         val downstream2 = TestSubscriber.manualProbe[Any]()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:550: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]         val downstream2 = TestSubscriber.manualProbe[Any]()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:581: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.ManualProbe[Any]. (This might not be what you've intended)
[warn]           val downstream3 = TestSubscriber.manualProbe[Any]()
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitAfterSpec.scala:65: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val substream = masterSubscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitWhenSpec.scala:56: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val substream = masterSubscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitWhenSpec.scala:191: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       inputs3.expectRequest()
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitWhenSpec.scala:139: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val masterStream = TestSubscriber.probe[Any]()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitWhenSpec.scala:179: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val src = masterStream3.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitWhenSpec.scala:184: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val src2 = masterStream3.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitWhenSpec.scala:263: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]             .mapAsync(1) { src ? src.runWith(Sink.ignore); src.runWith(Sink.ignore) } // Sink.ignore+mapAsync pipes error back
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:219: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]           "Flow(List(1, 2, 3)) ~> zip.left ~> wrongOut" shouldNot compile
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:218: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Sink[Any,org.reactivestreams.Publisher[Any]]. (This might not be what you've intended)
[warn]           val whatever = Sink.asPublisher[Any](false)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:349: [UndesirableTypeInference] Inferred type akka.stream.FlowShape[Any,Any]. (This might not be what you've intended)
[warn]         val id = b.add(GraphStages.Identity)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMatValueSpec.scala:166: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Sink[Any,scala.concurrent.Future[akka.Done]]. (This might not be what you've intended)
[warn]           val sink = Sink.ignore
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMatValueSpec.scala:169: [UndesirableTypeInference] Inferred type akka.stream.SinkShape[Any]. (This might not be what you've intended)
[warn]             val s = builder.add(sink)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMatValueSpec.scala:185: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Sink[Any,Unit]. (This might not be what you've intended)
[warn]           val sink = Sink.ignore.mapMaterializedValue(_ ? testActor ! "side effect!")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMatValueSpec.scala:188: [UndesirableTypeInference] Inferred type akka.stream.SinkShape[Any]. (This might not be what you've intended)
[warn]             val s = builder.add(sink)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMergePreferredSpec.scala:46: [UseCountNotFilterLength] Use col.count(...) instead of col.filter(...).size
[warn]       Await.result(result, 3.seconds).filter(_ == 1).size should be(numElements)
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMergePreferredSpec.scala:71: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]           s ~> merge.preferred
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphUnzipWithSpec.scala:236: [UseHeadNotApply] It is idiomatic to use a.head instead of a(0) for List
[warn]           (a(0), a(0).toString,
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphUnzipWithSpec.scala:236: [UseHeadNotApply] It is idiomatic to use a.head instead of a(0) for List
[warn]           (a(0), a(0).toString,
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\HubSpec.scala:339: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Nothing,akka.NotUsed]. (This might not be what you've intended)
[warn]       val source = Source.failed(TE("Fail!")).runWith(BroadcastHub.sink(8))
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\LazySinkSpec.scala:25: [UndesirableTypeInference] Inferred type () => Nothing. (This might not be what you've intended)
[warn]   val fallback = () ? fail("Must not call fallback function")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\QueueSourceSpec.scala:47: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Nothing,akka.stream.scaladsl.SourceQueueWithComplete[Nothing]]. (This might not be what you've intended)
[warn]       val source = Source.queue(0, OverflowStrategy.backpressure)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\QueueSourceSpec.scala:48: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.SourceQueueWithComplete[Nothing]. (This might not be what you've intended)
[warn]       val q1 = source.to(Sink.ignore).run()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\QueueSourceSpec.scala:51: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.SourceQueueWithComplete[Nothing]. (This might not be what you've intended)
[warn]       val q2 = source.to(Sink.ignore).run()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SinkAsJavaStreamSpec.scala:28: [UndesirableTypeInference] Inferred type java.util.stream.Stream[Nothing]. (This might not be what you've intended)
[warn]       val javaSource = Source(1 to 100).map(_ ? throw TE("")).runWith(StreamConverters.asJavaStream())
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SinkAsJavaStreamSpec.scala:40: [UndesirableTypeInference] Inferred type java.util.stream.Stream[Nothing]. (This might not be what you've intended)
[warn]       val javaSource = Source.empty.runWith(StreamConverters.asJavaStream())
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:54: [UndesirableTypeInference] Inferred type org.reactivestreams.Publisher[Nothing]. (This might not be what you've intended)
[warn]       val p = Source.empty.runWith(Sink.asPublisher(false))
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:69: [UndesirableTypeInference] Inferred type org.reactivestreams.Publisher[Nothing]. (This might not be what you've intended)
[warn]       val p = Source.failed(ex).runWith(Sink.asPublisher(false))
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:199: [UseHeadNotApply] It is idiomatic to use source.head instead of source(0) for List
[warn]       Source.combine(source(0), source(1))(Merge(_)).to(Sink.fromSubscriber(out)).run()
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:311: [UndesirableTypeInference] Inferred type Iterator[Nothing]. (This might not be what you've intended)
[warn]       val empty = Iterator.empty
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SubstreamSubscriptionTimeoutSpec.scala:53: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (_, s1) = subscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SubstreamSubscriptionTimeoutSpec.scala:61: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (_, s2) = subscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SubstreamSubscriptionTimeoutSpec.scala:69: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (_, s3) = subscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SubstreamSubscriptionTimeoutSpec.scala:94: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (_, s1) = subscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SubstreamSubscriptionTimeoutSpec.scala:95: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (_, s2) = subscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SubstreamSubscriptionTimeoutSpec.scala:109: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (_, s1) = subscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SubstreamSubscriptionTimeoutSpec.scala:117: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Int,Any]. (This might not be what you've intended)
[warn]       val (_, s2) = subscriber.expectNext()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceAsyncSourceSpec.scala:206: [TypeToType] Using toString on something that is already of type String.
[warn]         c.expectNext().utf8String should ===(nextChunk().toString)
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceSourceSpec.scala:138: [TypeToType] Using toString on something that is already of type String.
[warn]         c.expectNext().utf8String should ===(nextChunk().toString)
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:22: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     s"""
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\FixedBufferSpec.scala:62: [UseUntilNotToMinusOne] Use (low until high) instead of (low to high-1).
[warn]         for (elem ← 1 to size - 1) buf.dequeue() should be(elem)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:409: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       system2.actorSelection(akka.io.Tcp(system2).getManager.path / "selectors" / s"$$a" / "*") ! Kill
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowDispatcherSpec.scala:11: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn] class FlowDispatcherSpec extends StreamSpec(s"my-dispatcher = $${akka.test.stream-dispatcher}") {
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSectionSpec.scala:15: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     s"""
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:21: [UnusedParameter] Parameter e is not used in method costFn.
[warn]       def costFn(e: Int): Long = 999999L // set to an arbitrarily big value
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:29: [UnusedParameter] Parameter e is not used in method costFn.
[warn]       def costFn(e: Int): Long = 0L
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:38: [UnusedParameter] Parameter e is not used in method costFn.
[warn]       def costFn(e: Int): Long = 1L
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\GraphStageLogicSpec.scala:81: The outer reference in this type test cannot be checked at run time.
[warn]   final case class ReadNEmitN(n: Int) extends GraphStage[FlowShape[Int, Int]] {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\GraphStageLogicSpec.scala:92: The outer reference in this type test cannot be checked at run time.
[warn]   final case class ReadNEmitRestOnComplete(n: Int) extends GraphStage[FlowShape[Int, Int]] {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterSpec.scala:580: The outer reference in this type test cannot be checked at run time.
[warn]   private[akka] final case class Doubler[T]() extends GraphStage[FlowShape[T, T]] {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterSpec.scala:614: The outer reference in this type test cannot be checked at run time.
[warn]   private[akka] final case class KeepGoing[T]() extends GraphStage[FlowShape[T, T]] {
[warn]                                  ^
[warn] there were 57 deprecation warnings; re-run with -deprecation for details
[warn] 152 warnings found
[info] 注: 某些输入文件使用或覆盖了已过时的 API。
[info] 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。
[info] Compiling 87 Scala sources and 3 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\AkkaProtocolStressTest.scala:119: possible missing interpolator: detected interpolated identifier `$a`
[warn]       EventFilter.warning(source = "akka://AkkaProtocolStressTest/user/$a", start = "received dead letter"),
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:180: possible missing interpolator: detected interpolated identifier `$a`
[warn]       EventFilter.warning(source = "akka://AkkaProtocolStressTest/user/$a", start = "received dead letter"),
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:139: possible missing interpolator: detected interpolated identifier `$a`
[warn]       EventFilter.warning(source = "akka://AkkaProtocolStressTest/user/$a", start = "received dead letter"),
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:109: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:121: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat() //0
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:151: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:164: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:180: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat() //0
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:186: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat() //1000
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DeadlineFailureDetectorSpec.scala:34: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DeadlineFailureDetectorSpec.scala:46: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat() //0
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DeadlineFailureDetectorSpec.scala:76: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DeadlineFailureDetectorSpec.scala:89: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       fd.heartbeat()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:52: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     fd.heartbeat("resource1")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:63: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     fd.heartbeat("resource1") //0
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:76: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     fd.heartbeat("resource1")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:89: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     fd.heartbeat("resource1")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:104: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     fd.heartbeat("resource1")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:118: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     fd.heartbeat("resource1") //0
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:132: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     fd.heartbeat("resource1") //4400
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteInitErrorSpec.scala:11: [JavaConverters] Consider using the explicit collection.JavaConverters instead of implicit conversions in collection.JavaConversions.
[warn] import scala.collection.JavaConversions._
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:76: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       recorder.snapshot()
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\InboundControlJunctionSpec.scala:48: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val ((upstream, controlSubject), downstream) = TestSource.probe[AnyRef]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\InboundHandshakeSpec.scala:54: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(inboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\InboundHandshakeSpec.scala:66: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(inboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\InboundHandshakeSpec.scala:81: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(inboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\OutboundControlJunctionSpec.scala:44: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val ((upstream, controlIngress), downstream) = TestSource.probe[String]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\OutboundHandshakeSpec.scala:53: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(outboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\OutboundHandshakeSpec.scala:64: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(outboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\OutboundHandshakeSpec.scala:76: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(outboundContext, timeout = 200.millis)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\OutboundHandshakeSpec.scala:86: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(outboundContext, retryInterval = 100.millis)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\OutboundHandshakeSpec.scala:98: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(outboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\OutboundHandshakeSpec.scala:115: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(outboundContext, injectHandshakeInterval = 500.millis)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteSendConsistencySpec.scala:131: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]         expectMsg("success")
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RestartCounterSpec.scala:34: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       counter.restart()
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageAckerSpec.scala:51: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(inboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageAckerSpec.scala:64: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(inboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageAckerSpec.scala:79: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(inboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageAckerSpec.scala:92: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(inboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageAckerSpec.scala:103: [UndesirableTypeInference] Inferred type akka.stream.testkit.TestSubscriber.Probe[Any]. (This might not be what you've intended)
[warn]       val (upstream, downstream) = setupStream(inboundContext)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:200: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       replyProbe.expectMsg(Nack(0L, addressB)) // from receiving 2
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:238: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       replyProbe.expectMsg(4.seconds, Ack(3L, addressB))
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SwitchableLoggedBehaviorSpec.scala:77: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       behavior.pop()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:786: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       val config = ConfigFactory.parseString(s"""
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:823: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       val config = ConfigFactory.parseString(s"""
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\BindCanonicalAddressSpec.scala:20: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       val config = ConfigFactory.parseString(s"""
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\BindCanonicalAddressSpec.scala:61: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       val config = ConfigFactory.parseString(s"""
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlushOnShutdownSpec.scala:16: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeDenySpec.scala:15: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeFailureSpec.scala:20: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeRetrySpec.scala:19: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LateConnectSpec.scala:20: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteSendConsistencySpec.scala:20: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SerializationErrorSpec.scala:16: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:34: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:24: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HandshakeShouldDropCompressionTableSpec.scala:25: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:44: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       val bindConfig = ConfigFactory.parseString(s"""
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:91: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       val bindConfig = ConfigFactory.parseString(s"""
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:107: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       val bindConfig = ConfigFactory.parseString(s"""
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\InboundHandshakeSpec.scala:38: [UnusedParameter] Parameter timeout is not used in method setupStream.
[warn]   private def setupStream(inboundContext: InboundContext, timeout: FiniteDuration = 5.seconds): (TestPublisher.Probe[AnyRef], TestSubscriber.Probe[Any]) = {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageAckerSpec.scala:32: [UnusedParameter] Parameter timeout is not used in method setupStream.
[warn]   private def setupStream(inboundContext: InboundContext, timeout: FiniteDuration = 5.seconds): (TestPublisher.Probe[AnyRef], TestSubscriber.Probe[Any]) = {
[warn]               ^
[warn] there were 28 deprecation warnings; re-run with -deprecation for details
[warn] 63 warnings found
[info] Compiling 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-docs\target\classes...
[info] Compiling 6 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\target\test-classes...
[info] Formatting 33 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote-tests(multi-jvm) ...
[info] Compiling 31 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\StartupWithOneThreadSpec.scala:57: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       system.actorOf(testProps) ! "hello"
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\StartupWithOneThreadSpec.scala:65: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       expectMsg("hello")
[warn]                ^
[warn] there were 95 deprecation warnings; re-run with -deprecation for details
[warn] three warnings found
[info] Compiling 33 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\target\multi-jvm-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\Ticket15109Spec.scala:83: [VariableAssignedUnusedValue] Variable subject has an unused value before this reassign.
[warn]         subject = identify(second, "subject")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteDeliverySpec.scala:78: [InvariantCondition] This condition will never hold.
[warn]           if (n % 10000 == 0) log.info("Passed [{}]", n)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamConcistencySpec.scala:36: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     ConfigFactory.parseString(s"""
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\HandshakeRestartReceiverSpec.scala:24: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     ConfigFactory.parseString(s"""
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamLatencySpec.scala:143: [UnusedParameter] Parameter payloadSize is not used in method printTotal.
[warn]   def printTotal(testName: String, payloadSize: Long, histogram: Histogram, totalDurationNanos: Long, lastRepeat: Boolean): Unit = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\LatencySpec.scala:122: [UnusedParameter] Parameter payloadSize is not used in method printTotal.
[warn]     def printTotal(testName: String, payloadSize: Long, histogram: Histogram, totalDurationNanos: Long): Unit = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\MaxThroughputSpec.scala:237: [UnusedParameter] Parameter system is not used in method totalSize.
[warn]     def totalSize(system: ActorSystem) = payloadSize + (if (RARP(system).provider.remoteSettings.Artery.Advanced.Compression.Enabled) 38 else 110)
[warn]         ^
[warn] there was one deprecation warning; re-run with -deprecation for details
[warn] 8 warnings found
[info] Formatting 47 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster(multi-jvm) ...
[info] Compiling 17 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\LotsOfDataBot.scala:122: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val ORSet(elements) = c.dataValue
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\LotsOfDataBot.scala:137: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val ORSet(elements) = c.dataValue
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:22: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(a) = m.entries("a")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:24: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(b) = m.entries("b")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:28: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(a2) = m2.entries("a")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:73: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(a1) = merged1.entries("a")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:76: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(b1) = merged1.entries("b")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:80: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(d1) = merged1.entries("d")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:85: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(a2) = merged1.entries("a")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:88: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(b2) = merged2.entries("b")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMapSpec.scala:92: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val GSet(d2) = merged2.entries("d")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:19: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]       val m = ORMultiMap().addBinding(node1, "a", "A").addBinding(node1, "b", "B")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:22: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]       val m2 = m.addBinding(node1, "a", "C")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:27: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]       val m = ORMultiMap().addBinding(node1, "a", "A").addBinding(node1, "b", "B").removeBinding(node1, "a", "A")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:32: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]       val m = ORMultiMap().addBinding(node1, "a", "A").replaceBinding(node1, "a", "A", "B")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:37: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]       val m1 = ORMultiMap().addBinding(node1, "a", "A").addBinding(node1, "b", "B")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:38: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]       val m2 = ORMultiMap().addBinding(node2, "c", "C")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:55: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]       val m1 = ORMultiMap()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:60: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]       val m2 = ORMultiMap()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:84: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]     val m = ORMultiMap().addBinding(node1, "a", "A1").addBinding(node1, "a", "A2").addBinding(node1, "b", "B1")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:85: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]     val Some(a) = m.get("a")
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:89: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]     val m2 = m.put(node1, "a", a - "A1")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:99: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]     val m = ORMultiMap().addBinding(node1, "a", "A")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:105: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]     val m = ORMultiMap().addBinding(node1, "a", "A1").addBinding(node1, "a", "A2").addBinding(node1, "b", "B1")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORMultiMapSpec.scala:106: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORMultiMap[Any]. (This might not be what you've intended)
[warn]     val m2 = m.remove(node1, "a")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:37: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c1 = ORSet()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:39: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c2 = c1.add(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:40: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c3 = c2.add(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:42: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c4 = c3.add(node1, user4)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:43: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c5 = c4.add(node1, user3)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:52: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c1 = ORSet()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:54: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c2 = c1.add(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:55: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c3 = c2.add(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:57: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c4 = c3.remove(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:58: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c5 = c4.remove(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:63: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c6 = c3.merge(c5)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:67: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c7 = c5.merge(c3)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:73: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c1 = ORSet()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:74: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c2 = c1.remove(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:75: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c3 = c2.add(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:77: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c4 = c3.remove(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:79: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c5 = c4.add(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:84: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c1 = ORSet()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:86: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c2 = c1.add(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:87: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c3 = c2.add(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:88: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c4 = c3.remove(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:92: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c5 = c4.add(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:93: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c6 = c5.add(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:97: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c7 = c6.remove(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:98: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c8 = c7.add(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:99: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c9 = c8.remove(node1, user1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:106: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c1 = ORSet().add(node1, user1).add(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:111: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c2 = ORSet().add(node2, user3).add(node2, user4).remove(node2, user3)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:132: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c1 = ORSet().add(node1, user1).add(node1, user2).add(node1, user3).remove(node1, user1).remove(node1, user3)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:139: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c2 = ORSet().add(node2, user1).add(node2, user2).add(node2, user3).add(node2, user4).remove(node2, user3)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:161: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c1 = ORSet().add(node1, user1).add(node1, user2).add(node1, user3)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:167: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c2 = c1.add(node2, user1).remove(node2, user2).remove(node2, user3)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:184: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c3 = c1.add(node1, user4).remove(node1, user3).add(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:201: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c1 = ORSet().add(node1, user1).add(node1, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:202: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c2 = c1.remove(node2, user2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:213: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c3 = c1.add(node1, user3)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:275: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val a1 = ORSet().add(node1, "bar")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:276: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val b1 = ORSet().add(node2, "baz")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:277: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val c = a1.merge(b1)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:278: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val a2 = a1.remove(node1, "bar")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:279: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val d = a2.merge(c)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:285: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val a = ORSet().add(node1, "Z")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:289: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val a2 = a.remove(node1, "Z")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:291: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val b = ORSet().add(node2, "Z")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:294: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val a3 = b.merge(a2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:297: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val b2 = b.remove(node2, "Z")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:314: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val a = ORSet().add(node1, "Z")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:315: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val b = ORSet().add(node2, "Z")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:318: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val a2 = a.remove(node1, "Z")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:320: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val a3 = a2.merge(b)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:323: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val b2 = b.remove(node2, "Z")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:325: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val b3 = b2.merge(c)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:353: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]           val ORSet(elements3) = c.dataValue // `unapply(a: ReplicatedData)` is used here
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\WriteAggregatorSpec.scala:98: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       probe.expectMsgType[Write]
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\WriteAggregatorSpec.scala:117: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       probe.expectMsgType[Write]
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\WriteAggregatorSpec.scala:121: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]       probe.expectMsgType[Write]
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializerSpec.scala:89: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val s1 = ORSet().add(address1, "a").add(address2, "b")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializerSpec.scala:90: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val s2 = ORSet().add(address2, "b").add(address1, "a")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializerSpec.scala:94: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val s3 = ORSet().add(address1, "a").add(address2, 17).remove(address3, 17)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializerSpec.scala:95: [UndesirableTypeInference] Inferred type akka.cluster.ddata.ORSet[Any]. (This might not be what you've intended)
[warn]       val s4 = ORSet().add(address2, 17).remove(address3, 17).add(address1, "a")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializerSpec.scala:178: [UnusedParameter] Parameter a is not used in method createValue.
[warn]       def createValue(a: Read): AnyRef = {
[warn]           ^
[warn] there were 39 deprecation warnings; re-run with -deprecation for details
[warn] 87 warnings found
[info] Compiling 47 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\target\multi-jvm-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\DeterministicOldestWhenJoiningSpec.scala:60: [UseMinOrMaxNotSort] Use col.min instead of col.sorted.head.
[warn]         ups.map(_.member).sorted(Member.ageOrdering).head.address should ===(seedNodes.head)
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MultiNodeClusterSpec.scala:337: [UseMinOrMaxNotSort] Use nodesInCluster.min instead of nodesInCluster.sorted.head.
[warn]     nodesInCluster.sorted.head
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:832: [UseOptionForeachNotPatMatch] ... match { Some(x) => {

[warn]   StressSpec.this.watch(r);

[warn]   {

[warn]     StressSpec.this.expectMsgPF[Boolean](StressSpec.this.expectMsgPF$default$1[Nothing], StressSpec.this.expectMsgPF$default$2[Nothing])(({

[warn]       @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Any,Boolean] with Serializable {

[warn]         def <init>(): <$anon: Any => Boolean> = {

[warn]           $anonfun.super.<init>();

[warn]           ()

[warn]         };

[warn]         final override def applyOrElse[A1, B1 >: Boolean](x15: A1, default: A1 => B1): B1 = ((x15.asInstanceOf[Any]: Any): Any @unchecked) match {

[warn]           case (actor: akka.actor.ActorRef)(existenceConfirmed: Boolean, addressTerminated: Boolean)akka.actor.Terminated((a @ _)) if a.path.==(r.path) => true

[warn]           case (defaultCase$ @ _) => default.apply(x15)

[warn]         };

[warn]         final def isDefinedAt(x15: Any): Boolean = ((x15.asInstanceOf[Any]: Any): Any @unchecked) match {

[warn]           case (actor: akka.actor.ActorRef)(existenceConfirmed: Boolean, addressTerminated: Boolean)akka.actor.Terminated((a @ _)) if a.path.==(r.path) => true

[warn]           case (defaultCase$ @ _) => false

[warn]         }

[warn]       };

[warn]       new $anonfun()

[warn]     }: PartialFunction[Any,Boolean]));

[warn]     ()

[warn]   }

[warn] }; None => {} } can be replaced with .foreach({

[warn]   StressSpec.this.watch(r);

[warn]   {

[warn]     StressSpec.this.expectMsgPF[Boolean](StressSpec.this.expectMsgPF$default$1[Nothing], StressSpec.this.expectMsgPF$default$2[Nothing])(({

[warn]       @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Any,Boolean] with Serializable {

[warn]         def <init>(): <$anon: Any => Boolean> = {

[warn]           $anonfun.super.<init>();

[warn]           ()

[warn]         };

[warn]         final override def applyOrElse[A1, B1 >: Boolean](x15: A1, default: A1 => B1): B1 = ((x15.asInstanceOf[Any]: Any): Any @unchecked) match {

[warn]           case (actor: akka.actor.ActorRef)(existenceConfirmed: Boolean, addressTerminated: Boolean)akka.actor.Terminated((a @ _)) if a.path.==(r.path) => true

[warn]           case (defaultCase$ @ _) => default.apply(x15)

[warn]         };

[warn]         final def isDefinedAt(x15: Any): Boolean = ((x15.asInstanceOf[Any]: Any): Any @unchecked) match {

[warn]           case (actor: akka.actor.ActorRef)(existenceConfirmed: Boolean, addressTerminated: Boolean)akka.actor.Terminated((a @ _)) if a.path.==(r.path) => true

[warn]           case (defaultCase$ @ _) => false

[warn]         }

[warn]       };

[warn]       new $anonfun()

[warn]     }: PartialFunction[Any,Boolean]));

[warn]     ()

[warn]   }

[warn] })
[warn]       clusterResultAggregator match {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\TransitionSpec.scala:45: [UseMinOrMaxNotSort] Use roles.min instead of roles.sorted.head.
[warn]   def leader(roles: RoleName*) = roles.sorted.head
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingGroupSpec.scala:29: [UndesirableTypeInference] Inferred type scala.collection.immutable.Set[Any]. (This might not be what you've intended)
[warn]     var receivedMessages = Set.empty[Any]
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingGroupSpec.scala:87: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val a = expectMsgType[Collected].messages
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingGroupSpec.scala:88: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val b = expectMsgType[Collected].messages
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingGroupSpec.scala:89: [UndesirableTypeInference] Inferred type Set[Any]. (This might not be what you've intended)
[warn]       val c = expectMsgType[Collected].messages
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingRouterSpec.scala:40: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     withFallback(ConfigFactory.parseString(s"""
[warn]                                            ^
[warn] there were 10 deprecation warnings; re-run with -deprecation for details
[warn] 10 warnings found
[info] Formatting 6 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-distributed-data-experimental(multi-jvm) ...
[info] Compiling 44 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\BenchRunner.scala:9: [JavaConverters] Consider using the explicit collection.JavaConverters instead of implicit conversions in collection.JavaConversions.
[warn]     import scala.collection.JavaConversions._
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\dispatch\NodeQueueBenchmark.scala:57: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     System.gc()
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\SendQueueBenchmark.scala:90: [UndesirableTypeInference] Inferred type akka.stream.scaladsl.Source[Nothing,akka.actor.ActorRef]. (This might not be what you've intended)
[warn]     val source = Source.actorRef(1024, OverflowStrategy.dropBuffer)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:54: [IdenticalStatements] You're doing the exact same thing twice or more.
[warn]     bracket.poll().get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\io\FileSourcesBenchmark.scala:55: [CloseSourceFile] You should close the file stream after use. (Streams get garbage collected, but it is possible to open too many at once)
[warn]     ioSourceLinesIterator = Source.fromIterator(() ? scala.io.Source.fromFile(file.toFile).getLines()).map(ByteString(_))
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:30: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       s"""| akka {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBlueprintBenchmark.scala:88: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]     s"HTTP/1.1 200 OK\r\n" +
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBlueprintBenchmark.scala:89: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       s"Content-Length: 0\r\n" +
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBlueprintBenchmark.scala:90: [EmptyStringInterpolator] This string interpolation has no arguments.
[warn]       s"\r\n"
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpResponseRenderingBenchmark.scala:236: method renderToImpl in class HttpResponseRenderingBenchmark references private[http] class ResponseRenderingContext.
[warn] Classes which cannot access ResponseRenderingContext may be unable to override renderToImpl.
[warn]   def renderToImpl(ctx: ResponseRenderingContext, blackhole: Blackhole, n: Int)(implicit mat: Materializer): CountDownLatch = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpRequestParsingBenchmark.scala:86: [UnusedParameter] Parameter bytes is not used in method flow.
[warn]   def flow(bytes: SessionBytes, n: Int): RunnableGraph[Future[Done]] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpRequestParsingBenchmark.scala:93: [UnusedParameter] Parameter blackhole is not used in method parse_10000_requests_val.
[warn]   def parse_10000_requests_val(blackhole: Blackhole): Unit = {
[warn]       ^
[warn] there were 11 deprecation warnings; re-run with -deprecation for details
[warn] 13 warnings found
[info] Compiling 6 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\target\multi-jvm-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:68: [InvariantCondition] This condition will never hold.
[warn]     if (delayMillis != 0) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:74: [InvariantCondition] This condition will never hold.
[warn]     if (delayMillis != 0)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:75: [ZeroDivideBy] Division of zero will return zero.
[warn]       Thread.sleep(delayMillis * totalCount / nodeCount / 10)
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:79: [ZeroDivideBy] Division of zero will return zero.
[warn]     Thread.sleep(math.max(5000, delayMillis * totalCount / nodeCount / 2))
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:250: [InvariantCondition] This condition will never hold.
[warn]         if (delayMillis != 0)
[warn]                         ^
[warn] 5 warnings found
[success] Total time: 609 s, completed 2020-11-2 22:44:40
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-camel-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-camel-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-cluster-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-cluster-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-distributed-data-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-distributed-data-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-fsm-java-lambda\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-fsm-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-java-lambda\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-multi-node-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java-lambda\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-remote-java\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-remote-scala\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Loading project definition from D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-supervision-java-lambda\project
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Set current project to akka (in build file:/D:/data/akka-akka/akka-akka-4f9dc51/)
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[success] Total time: 15 s, completed 2020-11-5 14:38:37
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-actor...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-parsing...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-protobuf...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-samples...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-testkit...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-osgi...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-main-scala/}akka-sample-main-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-main-java-lambda/}akka-sample-main-java-lambda...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-main-java/}akka-sample-main-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-fsm-scala/}akka-sample-fsm-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-testkit...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-actor-tests...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-typed-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-agent...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-slf4j...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-fsm-java-lambda/}akka-sample-fsm-java-lambda...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving junit#junit;4.11 ...
[info] Resolving org.hamcrest#hamcrest-core;1.3 ...
[info] Resolving com.novocode#junit-interface;0.10 ...
[info] Resolving junit#junit-dep;4.10 ...
[info] Resolving org.scala-tools.testing#test-interface;0.5 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Scala version was updated by one of library dependencies:
[warn] 	* org.scala-lang:scala-library:2.11.7 -> 2.11.8
[warn] To force scalaVersion, add the following:
[warn] 	ivyScala := ivyScala.value map { _.copy(overrideScalaVersion = true) }
[warn] Run 'evicted' to see detailed eviction warnings
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-supervision-java-lambda/}akka-sample-supervision-java-lambda...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving junit#junit;4.12 ...
[info] Resolving org.hamcrest#hamcrest-core;1.3 ...
[info] Resolving com.novocode#junit-interface;0.11 ...
[info] Resolving org.scala-sbt#test-interface;1.0 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Scala version was updated by one of library dependencies:
[warn] 	* org.scala-lang:scala-library:2.11.7 -> 2.11.8
[warn] To force scalaVersion, add the following:
[warn] 	ivyScala := ivyScala.value map { _.copy(overrideScalaVersion = true) }
[warn] Run 'evicted' to see detailed eviction warnings
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-kernel...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-core...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-tests...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-tests-tck...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-camel...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-tck...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-query-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-persistence-scala/}akka-sample-persistence-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.iq80.leveldb#leveldb;0.7 ...
[info] Resolving org.iq80.leveldb#leveldb-api;0.7 ...
[info] Resolving com.google.guava#guava;16.0.1 ...
[info] Resolving org.fusesource.leveldbjni#leveldbjni-all;1.8 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-persistence_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-persistence-java/}akka-sample-persistence-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.iq80.leveldb#leveldb;0.7 ...
[info] Resolving org.iq80.leveldb#leveldb-api;0.7 ...
[info] Resolving com.google.guava#guava;16.0.1 ...
[info] Resolving org.fusesource.leveldbjni#leveldbjni-all;1.8 ...
[info] Resolving com.typesafe.akka#akka-persistence_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-persistence-java-lambda/}akka-sample-persistence-java-lambda...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.iq80.leveldb#leveldb;0.7 ...
[info] Resolving org.iq80.leveldb#leveldb-api;0.7 ...
[info] Resolving com.google.guava#guava;16.0.1 ...
[info] Resolving org.fusesource.leveldbjni#leveldbjni-all;1.8 ...
[info] Resolving com.typesafe.akka#akka-persistence_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-multi-node-testkit...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-shared...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-remote-java/}akka-sample-remote-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-remote-scala/}akka-sample-remote-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-camel-scala/}akka-sample-camel-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.apache.camel#camel-jetty;2.10.3 ...
[info] Resolving org.apache.camel#camel-core;2.10.3 ...
[info] Resolving org.apache.camel#camel-http;2.10.3 ...
[info] Resolving org.apache.geronimo.specs#geronimo-servlet_2.5_spec;1.1.2 ...
[info] Resolving commons-httpclient#commons-httpclient;3.1 ...
[info] Resolving commons-logging#commons-logging;1.0.4 ...
[info] Resolving commons-codec#commons-codec;1.6 ...
[info] Resolving org.eclipse.jetty#jetty-server;7.5.4.v20111024 ...
[info] Resolving javax.servlet#servlet-api;2.5 ...
[info] Resolving org.eclipse.jetty#jetty-continuation;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-http;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-io;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-util;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-security;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-servlet;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-servlets;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-client;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-jmx;7.5.4.v20111024 ...
[info] Resolving org.apache.camel#camel-quartz;2.10.3 ...
[info] Resolving org.quartz-scheduler#quartz;1.8.5 ...
[info] Resolving javax.transaction#jta;1.1 ...
[info] Resolving commons-collections#commons-collections;3.2.1 ...
[info] Resolving org.slf4j#slf4j-api;1.7.2 ...
[info] Resolving ch.qos.logback#logback-classic;1.0.7 ...
[info] Resolving ch.qos.logback#logback-core;1.0.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-camel_2.11;2.4.11.2 ...
[info] Resolving org.apache.camel#camel-core;2.13.4 ...
[info] Resolving com.sun.xml.bind#jaxb-impl;2.2.6 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-camel-java/}akka-sample-camel-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving org.apache.camel#camel-jetty;2.10.3 ...
[info] Resolving org.apache.camel#camel-core;2.10.3 ...
[info] Resolving org.apache.camel#camel-http;2.10.3 ...
[info] Resolving org.apache.geronimo.specs#geronimo-servlet_2.5_spec;1.1.2 ...
[info] Resolving commons-httpclient#commons-httpclient;3.1 ...
[info] Resolving commons-logging#commons-logging;1.0.4 ...
[info] Resolving commons-codec#commons-codec;1.6 ...
[info] Resolving org.eclipse.jetty#jetty-server;7.5.4.v20111024 ...
[info] Resolving javax.servlet#servlet-api;2.5 ...
[info] Resolving org.eclipse.jetty#jetty-continuation;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-http;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-io;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-util;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-security;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-servlet;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-servlets;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-client;7.5.4.v20111024 ...
[info] Resolving org.eclipse.jetty#jetty-jmx;7.5.4.v20111024 ...
[info] Resolving org.apache.camel#camel-quartz;2.10.3 ...
[info] Resolving org.quartz-scheduler#quartz;1.8.5 ...
[info] Resolving javax.transaction#jta;1.1 ...
[info] Resolving commons-collections#commons-collections;3.2.1 ...
[info] Resolving org.slf4j#slf4j-api;1.7.2 ...
[info] Resolving ch.qos.logback#logback-classic;1.0.7 ...
[info] Resolving ch.qos.logback#logback-core;1.0.7 ...
[info] Resolving com.typesafe.akka#akka-camel_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving org.apache.camel#camel-core;2.13.4 ...
[info] Resolving com.sun.xml.bind#jaxb-impl;2.2.6 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-jackson-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-xml-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-spray-json-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-testkit...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote-tests...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-multi-node-scala/}akka-sample-multi-node-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-tests...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-distributed-data-experimental...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-metrics...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-tools...
[info] Done updating.
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-distributed-data-scala/}akka-sample-distributed-data-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-cluster_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-distributed-data-experimental_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-bench-jmh...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-distributed-data-java/}akka-sample-distributed-data-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-cluster_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-distributed-data-experimental_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-docs...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-cluster-scala/}akka-sample-cluster-scala...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving io.kamon#sigar-loader;1.6.6-rev002 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-cluster_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-cluster-metrics_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-cluster-tools_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-contrib...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-sharding...
[info] Done updating.
[info] Updating {file:/D:/data/akka-akka/akka-akka-4f9dc51/akka-samples/akka-sample-cluster-java/}akka-sample-cluster-java...
[info] Resolving org.scala-lang#scala-library;2.11.7 ...
[info] Resolving io.kamon#sigar-loader;1.6.6-rev002 ...
[info] Resolving com.typesafe.akka#akka-actor_2.11;2.4.11.2 ...
[info] Resolving org.scala-lang#scala-library;2.11.8 ...
[info] Resolving com.typesafe#config;1.3.0 ...
[info] Resolving org.scala-lang.modules#scala-java8-compat_2.11;0.7.0 ...
[info] Resolving com.typesafe.akka#akka-remote_2.11;2.4.11.2 ...
[info] Resolving io.netty#netty;3.10.6.Final ...
[info] Resolving org.uncommons.maths#uncommons-maths;1.2.2a ...
[info] Resolving io.aeron#aeron-driver;1.0.1 ...
[info] Resolving io.aeron#aeron-client;1.0.1 ...
[info] Resolving org.agrona#Agrona;0.5.4 ...
[info] Resolving com.typesafe.akka#akka-cluster_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-cluster-metrics_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-cluster-tools_2.11;2.4.11.2 ...
[info] Resolving com.typesafe.akka#akka-multi-node-testkit_2.11;2.4.11.2 ...
[info] Resolving org.scalatest#scalatest_2.11;2.2.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.2 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.2 ...
[info] Resolving org.scala-lang#scala-compiler;2.11.7 ...
[info] Resolving org.scala-lang#scala-reflect;2.11.7 ...
[info] Resolving org.scala-lang.modules#scala-xml_2.11;1.0.4 ...
[info] Resolving org.scala-lang.modules#scala-parser-combinators_2.11;1.0.4 ...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[success] Total time: 12 s, completed 2020-11-5 14:38:49
[info] Formatting 6 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-testkit(compile) ...
[info] Formatting 8 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-multi-node-testkit(compile) ...
[info] Formatting 10 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-metrics(compile) ...
[info] Formatting 4 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-osgi(compile) ...
[info] Formatting 156 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-core(compile) ...
[info] Formatting 19 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-camel(compile) ...
[info] Formatting 20 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-distributed-data-experimental(compile) ...
[info] Formatting 1 Scala source {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-xml-experimental(compile) ...
[info] Formatting 1 Scala source {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-agent(compile) ...
[info] Formatting 83 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote(compile) ...
[info] Formatting 2 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-spray-json-experimental(compile) ...
[info] Formatting 26 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-parsing(compile) ...
[info] Formatting 44 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-bench-jmh(compile) ...
[info] Formatting 1 Scala source {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-kernel(compile) ...
[info] Formatting 145 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-actor(compile) ...
[info] Formatting 37 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence(compile) ...
[info] Formatting 8 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-sharding(compile) ...
[info] Formatting 12 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-testkit(compile) ...
[info] Formatting 15 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-testkit(compile) ...
[info] Formatting 8 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster-tools(compile) ...
[info] Formatting 10 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-tck(compile) ...
[info] Formatting 118 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-http-experimental(compile) ...
[info] Formatting 24 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence-query-experimental(compile) ...
[info] Formatting 1 Scala source {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-slf4j(compile) ...
[info] Formatting 31 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-typed-experimental(compile) ...
[info] Formatting 107 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream(compile) ...
[info] Formatting 19 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster(compile) ...
[info] Formatting 8 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-contrib(compile) ...
[info] Generating 'Functions.scala'
[info] Generating 'Tuples.scala'
[info] Generating 'JavaPathMatchers.scala'
[info] Generating 'ApplyConverterInstances.scala'
[info] Generating 'ConstructFromTupleInstances.scala'
[info] Generating 'TupleAppendOneInstances.scala'
[info] Generating 'TupleFoldInstances.scala'
[info] Generating 'FanInShape.scala'
[info] Generating 'FanOutShape.scala'
[info] Generating 'GraphCreate.scala'
[info] Generating 'UnzipWith.scala'
[info] Generating 'ZipWith.scala'
[info] Generating 'GraphApply.scala'
[info] Generating 'UnzipWithApply.scala'
[info] Generating 'ZipWithApply.scala'
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 148 Scala sources and 23 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\AkkaException.scala:12: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   AkkaException.this.<init>(msg, null)
[warn]   def this(msg: String) = this(msg, null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\AkkaException.scala:33: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ConfigurationException.this.<init>(msg, null)
[warn]   def this(msg: String) = this(msg, null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\Main.scala:32: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val appClass = system.asInstanceOf[ExtendedActorSystem].dynamicAccess.getClassFor[Actor](args(0)).get
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\Main.scala:32: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem].dynamicAccess.getClassFor[akka.actor.Actor](args.apply(0))((ClassTag.apply[akka.actor.Actor](classOf[akka.actor.Actor]): scala.reflect.ClassTag[akka.actor.Actor])).get
[warn]         val appClass = system.asInstanceOf[ExtendedActorSystem].dynamicAccess.getClassFor[Actor](args(0)).get
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractActor.scala:67: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   AbstractActor.this.context.asInstanceOf[akka.actor.AbstractActorContext]
[warn]   def getContext(): AbstractActorContext = context.asInstanceOf[AbstractActorContext]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractActor.scala:49: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var _receive: Receive = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractActor.scala:58: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   AbstractActor.this._receive.==(null)
[warn]     if (_receive == null) _receive = receive
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractActor.scala:70: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   AbstractActor.this._receive.!=(null)
[warn]     if (_receive != null) _receive
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractFSM.scala:106: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   transitionHandlerBuilder.build().asInstanceOf[AbstractFSM.this.TransitionHandler]
[warn]     onTransition(transitionHandlerBuilder.build().asInstanceOf[TransitionHandler])
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractFSM.scala:132: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   stopBuilder.build().asInstanceOf[PartialFunction[AbstractFSM.this.StopEvent,Unit]]
[warn]     onTermination(stopBuilder.build().asInstanceOf[PartialFunction[StopEvent, Unit]])
[warn]                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractFSM.scala:23: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def NullFunction[S, D]: PartialFunction[S, D] = FSM.NullFunction
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractFSM.scala:57: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   AbstractFSM.this.when(stateName, null, stateFunctionBuilder)
[warn]     when(stateName, null, stateFunctionBuilder)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractProps.scala:53: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   c.!=(ac)
[warn]             v.getBounds collectFirst { case c: Class[_] if ac.isAssignableFrom(c) && c != ac ? c } getOrElse ac
[warn]                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractProps.scala:56: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   c.==(coc)
[warn]       case c: Class[_] if (c == coc) ?
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractProps.scala:90: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   c.getParameterTypes().apply(0).==(enclosingClass)
[warn]           if (c.getParameterCount >= 1 && c.getParameterTypes()(0) == enclosingClass)
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\AbstractProps.scala:57: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("erased Creator types are unsupported, use Props.create(actorClass, creator) instead").s()
[warn]         throw new IllegalArgumentException(s"erased Creator types are unsupported, use Props.create(actorClass, creator) instead")
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:257: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def getMessage(): Any = UnhandledMessage.this.message
[warn] final case class UnhandledMessage(@BeanProperty message: Any, @BeanProperty sender: ActorRef, @BeanProperty recipient: ActorRef)
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:173: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[akka] def apply(actor: ActorRef, message: String, cause: Throwable = null): ActorInitializationException =
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:366: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   final val noSender: ActorRef = null
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:444: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     ActorCell.contextStack.set(null :: contextStack)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:172: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   actor.==(null)
[warn]     if (actor == null) message else s"${actor.path}: $message"
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:175: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new ActorInitializationException(null, message, null)
[warn]   private[akka] def apply(message: String): ActorInitializationException = new ActorInitializationException(null, message, null)
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:297: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorLogging.this._log.eq(null)
[warn]     if (_log eq null)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:443: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   contextStack.head
[warn]     val c = contextStack.head
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Actor.scala:222: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val ex: akka.actor.PostRestartException = _
[warn]     @tailrec def rec(ex: PostRestartException): Option[Throwable] = ex match {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:587: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   val created: akka.actor.Actor = ActorCell.this.newActor();

[warn]   ActorCell.this.actor_=(created);

[warn]   created.aroundPreStart();

[warn]   ActorCell.this.checkReceiveTimeout();

[warn]   if (ActorCell.this.system.settings.DebugLifecycle)

[warn]     ActorCell.this.publish(akka.event.Logging.Debug.apply(ActorCell.thi
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:456: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   message match {

[warn]     case (message @ (_: akka.dispatch.sysmsg.SystemMessage)) if shouldStash(message, currentState) => ActorCell.this.stash(message)

[warn]     case (f @ (_: akka.dispatch.sysmsg.Failed)) => ActorCell.this.handleFailure(f)

[warn]     case (actor: akka.actor.ActorRef, existenceConfirmed:
[warn]       try {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:489: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   ActorCell.this.currentMessage_=(messageHandle);

[warn]   if (influenceReceiveTimeout)

[warn]     ActorCell.this.cancelReceiveTimeout()

[warn]   else

[warn]     ();

[warn]   messageHandle.message match {

[warn]     case (msg @ (_: akka.actor.AutoReceivedMessage)) => ActorCell.this.autoReceiveMessage(messageHandle)

[warn]     case (m
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:447: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m.isInstanceOf[akka.dispatch.sysmsg.StashWhenFailed]
[warn]         case SuspendedState                ? m.isInstanceOf[StashWhenFailed]
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:448: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m.isInstanceOf[akka.dispatch.sysmsg.StashWhenWaitingForChildren]
[warn]         case SuspendedWaitForChildrenState ? m.isInstanceOf[StashWhenWaitingForChildren]
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:488: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   messageHandle.message.isInstanceOf[akka.actor.NotInfluenceReceiveTimeout]
[warn]     val influenceReceiveTimeout = !messageHandle.message.isInstanceOf[NotInfluenceReceiveTimeout]
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:497: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       currentMessage = null // reset current message after successful invocation
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:581: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         actor = null // ensure that we know that we failed during creation
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:637: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     currentMessage = null
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:431: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorCell.this.waitingForChildrenOrNull.ne(null)
[warn]       if (waitingForChildrenOrNull ne null) SuspendedWaitForChildrenState
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:534: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   msg.sender.ne(null)
[warn]     case msg if msg.sender ne null ? msg.sender
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:564: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   instance.eq(null)
[warn]       if (instance eq null)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:579: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorCell.this.actor.!=(null)
[warn]       if (actor != null) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:636: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorCell.this.setActorFields(actorInstance, null, if (recreate)

[warn]   ActorCell.this.self

[warn] else

[warn]   ActorCell.this.system.deadLetters)
[warn]     setActorFields(actorInstance, context = null, self = if (recreate) self else system.deadLetters)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:642: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   actorInstance.ne(null)
[warn]     if (actorInstance ne null) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:651: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   o.eq(null)
[warn]   protected final def clazz(o: AnyRef): Class[_] = if (o eq null) this.getClass else o.getClass
[warn]                                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:347: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @tailrec final def newUid(): Int = {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:355: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def splitNameAndUid(name: String): (String, Int) = {
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:649: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]   protected final def publish(e: LogEvent): Unit = try system.eventStream.publish(e) catch { case NonFatal(_) ? }
[warn]                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:526: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   ActorCell.this.behaviorStack.head
[warn]   final def receiveMessage(msg: Any): Unit = actor.aroundReceive(behaviorStack.head, msg)
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:550: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   original.tail
[warn]       else original.tail
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:573: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   stackAfter.tail.tail
[warn]         contextStack.set(if (stackAfter.head eq null) stackAfter.tail.tail else stackAfter.tail) // pop null marker plus our context
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:573: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   stackAfter.tail
[warn]         contextStack.set(if (stackAfter.head eq null) stackAfter.tail.tail else stackAfter.tail) // pop null marker plus our context
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:454: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val message: akka.dispatch.sysmsg.SystemMessage = messages.head
[warn]       val message = messages.head
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:457: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   message match {

[warn]   case (message @ (_: akka.dispatch.sysmsg.SystemMessage)) if shouldStash(message, currentState) => ActorCell.this.stash(message)

[warn]   case (f @ (_: akka.dispatch.sysmsg.Failed)) => Act
[warn]         message match {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorCell.scala:641: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val self: akka.actor.ActorRef = _
[warn]   final protected def setActorFields(actorInstance: Actor, context: ActorContext, self: ActorRef): Unit =
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorDSL.scala:92: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Extension.this.system.systemActorOf(Props.apply[akka.actor.Actor]({

[warn]   final class $anon extends AnyRef with akka.actor.Actor {

[warn]     def <init>(): <$anon: akka.actor.Actor> = {

[warn]       $anon.super.<init>();

[warn]       ()

[warn]     };

[warn]     def receive: PartialFunction[Any,Unit] = ({

[warn]       @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Any,Unit] with Serializable {

[warn]         def <init>(): <$anon: Any => Unit> = {

[warn]           $anonfun.super.<init>()
[warn]       }), "dsl").asInstanceOf[RepointableActorRef]
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorDSL.scala:100: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Extension.this.boss.underlying.asInstanceOf[akka.actor.ActorCell]
[warn]         boss.underlying.asInstanceOf[ActorCell].attachChild(p, name, systemService = true)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorDSL.scala:103: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any]({

[warn]   <artifact> val qual$1: akka.pattern.AskableActorRef = akka.pattern.`package`.ask(Extension.this.boss);

[warn]   <artifact> val x$1: Extension.this.MkChild = Extension.this.MkChild.apply(p, name);

[warn]   <artifact> val x$2: akka.util.Timeout = timeout;

[warn]   <artifact> val x$3: akka.actor.ActorRef = qual$1.?$default$3(x$1);

[warn]   qual$1.?(x$1)(x$2, x$3)

[warn] }, timeout.duration).asInstanceOf[akka.actor.ActorRef]
[warn]         Await.result(boss ? MkChild(p, name), timeout.duration).asInstanceOf[ActorRef]
[warn]                                                                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorDSL.scala:85: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     private case class MkChild(props: Props, name: String) extends NoSerializationVerificationNeeded
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorDSL.scala:80: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.actor.ActorDSL.Extension = Extension.super.get(system)
[info]     override def get(system: ActorSystem): Extension = super.get(system)
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:417: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   left.isInstanceOf[akka.actor.RootActorPath]
[warn]       else if (left.isInstanceOf[RootActorPath]) left equals right
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:418: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   right.isInstanceOf[akka.actor.RootActorPath]
[warn]       else if (right.isInstanceOf[RootActorPath]) right equals left
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:444: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   left.isInstanceOf[akka.actor.RootActorPath]
[warn]       else if (left.isInstanceOf[RootActorPath]) left compareTo right
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:445: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   right.isInstanceOf[akka.actor.RootActorPath]
[warn]       else if (right.isInstanceOf[RootActorPath]) -(right compareTo left)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:75: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorPath.this.validatePathElement(element, null)
[warn]   final def validatePathElement(element: String): Unit = validatePathElement(element, fullPath = null)
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:85: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   fullPath.ne(null)
[warn]     def fullPathMsg = if (fullPath ne null) s""" (in path [$fullPath])""" else ""
[warn]                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:29: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def validatePathElement(element: String): Unit = ActorPath.validatePathElement(element)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:38: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def validatePathElement(element: String, fullPath: String): Unit =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:48: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def isValidPathElement(s: String): Boolean = ActorPath.isValidPathElement(s)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:75: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def validatePathElement(element: String): Unit = validatePathElement(element, fullPath = null)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:84: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def validatePathElement(element: String, fullPath: String): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:108: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def isValidPathElement(s: String): Boolean =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:111: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   private final def findInvalidPathElementCharPosition(s: String): Int = if (s.isEmpty) EmptyPathCode else {
[info]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:313: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val uid: Int = x$3._2
[warn]     val (childName, uid) = ActorCell.splitNameAndUid(child)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorPath.scala:338: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val uid: Int = _
[warn]   override private[akka] def withUid(uid: Int): ActorPath =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:751: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   watcher.asInstanceOf[akka.actor.ActorRefScope]
[warn]     if (watcher.asInstanceOf[ActorRefScope].isLocal == ifLocal)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:752: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   watcher.asInstanceOf[akka.actor.InternalActorRef]
[warn]       watcher.asInstanceOf[InternalActorRef].sendSystemMessage(DeathWatchNotification(this, existenceConfirmed = true, addressTerminated = false))
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:755: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   watched.asInstanceOf[akka.actor.InternalActorRef]
[warn]     watched.asInstanceOf[InternalActorRef].sendSystemMessage(Unwatch(watched, this))
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:811: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actorRef.asInstanceOf[akka.actor.InternalActorRef]
[warn]     actorRef.asInstanceOf[InternalActorRef].sendSystemMessage(Watch(actorRef.asInstanceOf[InternalActorRef], this))
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:811: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actorRef.asInstanceOf[akka.actor.InternalActorRef]
[warn]     actorRef.asInstanceOf[InternalActorRef].sendSystemMessage(Watch(actorRef.asInstanceOf[InternalActorRef], this))
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:821: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actorRef.asInstanceOf[akka.actor.InternalActorRef]
[warn]     actorRef.asInstanceOf[InternalActorRef].sendSystemMessage(Unwatch(actorRef.asInstanceOf[InternalActorRef], this))
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:821: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actorRef.asInstanceOf[akka.actor.InternalActorRef]
[warn]     actorRef.asInstanceOf[InternalActorRef].sendSystemMessage(Unwatch(actorRef.asInstanceOf[InternalActorRef], this))
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:530: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("ELAR ", " having enqueued ", "").s(EmptyLocalActorRef.this.path, message))

[warn] else

[warn]   ()
[warn]     if (Mailbox.debug) println(s"ELAR $path having enqueued $message")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:425: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   @throws[java.io.ObjectStreamException](classOf[java.io.ObjectStreamException]) def readResolve(): AnyRef = akka.serialization.JavaSerializer.currentSystem.value match {

[warn]   case null => throw new java.lang.IllegalStateException("Trying to deserialize a serialized ActorRef without an ActorSystem in sc
[warn]   def readResolve(): AnyRef = currentSystem.value match {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:657: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   VirtualPathContainer.this.children.remove(name).eq(null)
[warn]     if (children.remove(name) eq null) log.warning("{} trying to remove non-child {}", path, name)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:664: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   current.eq(null)
[warn]     if (current eq null)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:733: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FunctionRef.this._watchedBy.get().==(null)
[warn]   override def isTerminated = _watchedBy.get() == null
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:737: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FunctionRef.this._watchedBy.getAndSet(null)
[warn]     val watchedBy = _watchedBy.getAndSet(null)
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:738: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   watchedBy.!=(null)
[warn]     if (watchedBy != null) {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:799: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]   private def publish(e: Logging.LogEvent): Unit = try eventStream.publish(e) catch { case NonFatal(_) ? }
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRef.scala:624: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   elements.head
[warn]       elements.head match {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:620: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   LocalActorRefProvider.this.extraNames.get(other).getOrElse[akka.actor.InternalActorRef]($anon.super.getSingleChild(other))
[warn]         case other         ? extraNames.get(other).getOrElse(super.getSingleChild(other))
[warn]                                                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:572: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[String, Nothing]()
[info]   private var extraNames: Map[String, InternalActorRef] = Map()
[info]                                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:531: [scapegoat] Simplify boolean expressions
[info]   Boolean expressions such as x == false can be re-written as !x.
[info]   $anon.this.causeOfTermination.future.isCompleted.==(false)
[info]     def isWalking = causeOfTermination.future.isCompleted == false
[info]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:353: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   elems.tail
[warn]       else if (elems.head.isEmpty) ActorSelection(provider.rootGuardian, elems.tail)
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:676: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   elems.tail
[warn]       } else if (elems.head.isEmpty) actorFor(rootGuardian, elems.tail)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:773: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   {

[warn]   <synthetic> <artifact> val x$5: akka.routing.RouterConfig = router;

[warn]   {

[warn]   <synthetic> <artifact> val x$4: List[akka.routing.RouterConfig] = deploy.map[akka.routing.RouterConfig](((x$2: akka.actor.Deploy) => x$2.routerConfig)).toList;

[warn]   lookup.map[akka.routing.RouterConfig](((x$3: akka.actor.Deploy) => x$3.routerConfig)).toList.:::[akka.routing.RouterConfig](x$4)

[warn] }.::[akka.routing.RouterConfig](x$5)

[warn] }.reduce
[warn]         val r = router :: deploy.map(_.routerConfig).toList ::: lookup.map(_.routerConfig).toList reduce ((a, b) ? b withFallback a)
[warn]                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:583: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   LocalActorRefProvider.this.dynamicAccess.createInstanceFor[akka.actor.SupervisorStrategyConfigurator](LocalActorRefProvider.this.settings.SupervisorStrategyClass, akka.util.Collections.EmptyImmutableSeq)((ClassTag.apply[akka.actor.SupervisorStrategyConfigurator](classOf[akka.actor.SupervisorStrategyConfigurator]): scala.reflect.ClassTag[akka.actor.SupervisorStrategyConfigurator])).get
[warn]     dynamicAccess.createInstanceFor[SupervisorStrategyConfigurator](settings.SupervisorStrategyClass, EmptyImmutableSeq).get
[warn]                                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:733: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val system: akka.actor.ActorSystemImpl = _
[warn]   def actorOf(system: ActorSystemImpl, props: Props, supervisor: InternalActorRef, path: ActorPath,
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSelection.scala:39: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorSelection.this.anchor.asInstanceOf[akka.actor.InternalActorRef]
[warn]     ActorSelection.deliverSelection(anchor.asInstanceOf[InternalActorRef], sender,
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSelection.scala:141: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sel.asInstanceOf[akka.actor.ScalaActorSelection]
[warn]   implicit def toScala(sel: ActorSelection): ScalaActorSelection = sel.asInstanceOf[ScalaActorSelection]
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSelection.scala:224: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.asInstanceOf[akka.actor.InternalActorRef]
[warn]                     matchingChildren.foreach(c ? deliverSelection(c.asInstanceOf[InternalActorRef], sender, m))
[warn]                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSelection.scala:304: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   @SerialVersionUID(value = 1L) final case class ActorNotFound extends scala.`package`.RuntimeException with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val selection: akka.actor.ActorSelection = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def selection: akka.actor.ActorSelection = ActorNotFound.this.selection;

[warn]   def <init>(selection: akka.actor.ActorSelection): akka.actor.ActorNotFound = {

[warn]     ActorNotFound.super.<init>("Actor not found for: ".+(sele
[warn] final case class ActorNotFound(selection: ActorSelection) extends RuntimeException("Actor not found for: " + selection)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSelection.scala:208: [scapegoat] Repeated body of if main and else branch
[warn]   Main and else branches start with the same command.
[warn]   if (iter.isEmpty)

[warn]   {

[warn]     val matchingChildren: scala.collection.immutable.Iterable[akka.actor.ActorRef] = chldr.filter(((c: akka.actor.ActorRef) => p.pattern.matcher(c.path.name).matches()));

[warn]     if (matchingChildren.isEmpty.&&(sel.wildcardFanOut.unary_!))

[warn]       emptyRef.tell(sel, sender)

[warn]     else

[warn]       matchingChildren.foreach[Unit](((x$2: akka.actor.ActorRef) => x$2.tell(sel.msg, sender)))

[warn]   }

[warn] else

[warn]   {

[warn]     val matchingChildren: scala.collection.immutable.Iterable[akka.actor.ActorRef
[warn]                 if (iter.isEmpty) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:593: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.asInstanceOf[akka.actor.InternalActorRef]
[warn]       case _       ? actor.asInstanceOf[InternalActorRef].stop()
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:735: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   other.asInstanceOf[T]
[warn]       other.asInstanceOf[T] //could be a T or null, in which case we return the null as T
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:760: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   existing.asInstanceOf[T]
[warn]       case existing ? existing.asInstanceOf[T]
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:766: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   some.asInstanceOf[T]
[warn]     case some ? some.asInstanceOf[T]
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:744: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   ext.createExtension(this) match {

[warn]     case null => throw new java.this.lang.IllegalStateException("Extension instance created as \'null\' for extension [".+(ext).+("]"))

[warn]     case (instance @ _) => {

[warn]       ActorSystemImpl.this.extensions.replace(ext, inProcessOfRegistration, instance);

[warn]  
[warn]           case null ? try { // Signal was successfully sent
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:769: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   ActorSystemImpl.this.findExtension[_$3](ext).!=(null)
[warn]   def hasExtension(ext: ExtensionId[_ <: Extension]): Boolean = findExtension(ext) != null
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:670: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = {

[warn]   code;

[warn]   ()

[warn] }
[warn]   def registerOnTermination[T](code: ? T) { registerOnTermination(new Runnable { def run = code }) }
[warn]                                                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:846: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final def add(r: Runnable): Unit = {
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:605: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ActorSystemImpl.this.dynamicAccess.createInstanceFor[akka.event.LoggingFilter](ActorSystemImpl.this.settings.LoggingFilter, arguments)((ClassTag.apply[akka.event.LoggingFilter](classOf[akka.event.LoggingFilter]): scala.reflect.ClassTag[akka.event.LoggingFilter])).get
[warn]     dynamicAccess.createInstanceFor[LoggingFilter](LoggingFilter, arguments).get
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:619: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ActorSystemImpl.this.dynamicAccess.createInstanceFor[akka.actor.ActorRefProvider](ActorSystemImpl.this.settings.ProviderClass, arguments)((ClassTag.apply[akka.actor.ActorRefProvider](classOf[akka.actor.ActorRefProvider]): scala.reflect.ClassTag[akka.actor.ActorRefProvider])).get
[warn]     dynamicAccess.createInstanceFor[ActorRefProvider](ProviderClass, arguments).get
[warn]                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:711: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ActorSystemImpl.this.dynamicAccess.createInstanceFor[akka.actor.Scheduler](ActorSystemImpl.this.settings.SchedulerClass, scala.collection.immutable.Seq.apply[(Class[_ >: java.util.concurrent.ThreadFactory with akka.event.LoggingAdapter with com.typesafe.config.Config <: Object], Object)](scala.this.Predef.ArrowAssoc[Class[com.typesafe.config.Config]](classOf[com.typesafe.config.Config]).→[com.typesafe.config.Config](ActorSystemImpl.this.settings.config), scala.this.Predef.ArrowAssoc[Class[akka.e
[warn]       classOf[ThreadFactory] → threadFactory.withName(threadFactory.name + "-scheduler"))).get
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:576: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   def systemActorOf(props: Props, name: String): ActorRef = systemGuardian.underlying.attachChild(props, name, systemService = true)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:578: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   def actorOf(props: Props, name: String): ActorRef =
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorSystem.scala:847: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val r: Runnable = _
[warn]       @tailrec def addRec(r: Runnable, p: Promise[T]): Unit = ref.get match {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Address.scala:134: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   uri.eq(null)
[warn]     if (uri eq null) None
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Address.scala:136: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   uri.getUserInfo().==(null)
[warn]     else if (uri.getUserInfo == null) { // case 1: “akka://system”
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Address.scala:55: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Address.this.host.get
[warn]     if (host.isDefined) sb.append('@').append(host.get)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Address.scala:56: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Address.this.port.get
[warn]     if (port.isDefined) sb.append(':').append(port.get)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Deployer.scala:209: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Deployer.this.dynamicAccess.createInstanceFor[akka.routing.RouterConfig](fqn, args1)((ClassTag.apply[akka.routing.RouterConfig](classOf[akka.routing.RouterConfig]): scala.reflect.ClassTag[akka.routing.RouterConfig])).recover[akka.routing.RouterConfig](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,akka.routing.RouterConfig] with Serializable {

[warn]     def <init>(): <$anon: Throwable => akka.routing.RouterConfig> = {

[warn]      
[warn]       }).get
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Deployer.scala:154: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val d: akka.actor.Deploy = _
[warn]     @tailrec def add(path: Array[String], d: Deploy, w: WildcardIndex[Deploy] = deployments.get): Unit = {
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Deployer.scala:166: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val config: com.typesafe.config.Config = _
[warn]   def parseConfig(key: String, config: Config): Option[Deploy] = {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Deployer.scala:181: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val config: com.typesafe.config.Config = _
[warn]   protected def createRouterConfig(routerType: String, key: String, config: Config, deployment: Config): RouterConfig =
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Deployer.scala:201: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       dynamicAccess.createInstanceFor[RouterConfig](fqn, args1).recover({
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Deployer.scala:204: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]           dynamicAccess.createInstanceFor[RouterConfig](fqn, args2).recover({
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Extension.scala:100: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   other.asInstanceOf[AnyRef]
[warn]   override final def equals(other: Any): Boolean = this eq other.asInstanceOf[AnyRef]
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Extension.scala:153: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.dynamicAccess.createInstanceFor[T](ExtensionKey.this.m.runtimeClass, immutable.this.List.apply[(Class[akka.actor.ExtendedActorSystem], akka.actor.ExtendedActorSystem)](scala.this.Predef.ArrowAssoc[Class[akka.actor.ExtendedActorSystem]](classOf[akka.actor.ExtendedActorSystem]).→[akka.actor.ExtendedActorSystem](system)))(ExtensionKey.this.m).get
[warn]   def createExtension(system: ExtendedActorSystem): T = system.dynamicAccess.createInstanceFor[T](m.runtimeClass, List(classOf[ExtendedActorSystem] → system)).get
[warn]                                                                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:793: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LoggingFSM.this.stateName.asInstanceOf[AnyRef]
[warn]       states(pos) = stateName.asInstanceOf[AnyRef]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:812: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x._2.asInstanceOf[S]
[warn]     val log = events zip states filter (_._1 ne null) map (x ? LogEntry(x._2.asInstanceOf[S], x._1.stateData, x._1.event))
[warn]                                                                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:148: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class State[S, D](stateName: S, stateData: D, timeout: Option[FiniteDuration] = None, stopReason: Option[Reason] = None, replies: List[Any] = Nil) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:483: [scapegoat] List append is slow
[info]   List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).
[info]   final def onTransition(transitionHandler: TransitionHandler): Unit = transitionEvent :+= transitionHandler
[info]                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:347: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   final def when(stateName: S, stateTimeout: FiniteDuration = null)(stateFunction: StateFunction): Unit =
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:690: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         this.nextState = null
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:521: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FSM.this.currentState.!=(null)
[warn]     if (currentState != null) makeTransition(currentState)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:528: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FSM.this.currentState.!=(null)
[warn]     if (currentState != null) currentState.stateName
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:536: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FSM.this.currentState.!=(null)
[warn]     if (currentState != null) currentState.stateData
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:113: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   object `->` {
[info]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:104: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Timer.this.ref.get
[warn]         ref.get.cancel()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:622: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FSM.this.timeoutFuture.get
[warn]           timeoutFuture.get.cancel()
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:647: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FSM.this.timeoutFuture.get
[warn]         timeoutFuture.get.cancel()
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:704: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   timeout.get
[warn]           if (timeout.isDefined) timeoutFuture = scheduleTimeout(timeout.get)
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:728: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   nextState.stopReason.get
[warn]       val reason = nextState.stopReason.get
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:156: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stateName: S = stateName
[warn]     def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies): State[S, D] = {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:156: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stateData: D = stateData
[warn]     def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies): State[S, D] = {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:156: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val timeout: Option[scala.concurrent.duration.FiniteDuration] = timeout
[warn]     def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies): State[S, D] = {
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:156: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stopReason: Option[akka.actor.FSM.Reason] = stopReason
[warn]     def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies): State[S, D] = {
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:156: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val replies: List[Any] = replies
[warn]     def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies): State[S, D] = {
[warn]                                                                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:167: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val timeout: scala.concurrent.duration.Duration = _
[warn]     def forMax(timeout: Duration): State[S, D] = timeout match {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:662: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nextState: akka.actor.FSM.State[S,D] = if (stateFunc.isDefinedAt(event))

[warn]   stateFunc.apply(event)

[warn] else

[warn]   FSM.this.handleEvent.apply(event)
[warn]     val nextState = if (stateFunc isDefinedAt event) {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:671: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nextState: FSM.this.State = _
[warn]   private[akka] def applyState(nextState: State): Unit = {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:681: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nextState: FSM.this.State = _
[warn]   private[akka] def makeTransition(nextState: State): Unit = {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FSM.scala:726: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nextState: FSM.this.State = _
[warn]   private def terminate(nextState: State): Unit = {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:350: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   child.asInstanceOf[akka.actor.InternalActorRef]
[warn]   final def resumeChild(child: ActorRef, cause: Throwable): Unit = child.asInstanceOf[InternalActorRef].resume(causedByFailure = cause)
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:363: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   child.asInstanceOf[akka.actor.InternalActorRef]
[warn]     val c = child.asInstanceOf[InternalActorRef]
[warn]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:382: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class AllForOneStrategy(
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:460: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class OneForOneStrategy(
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:331: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.getCause().ne(null)
[warn]         case e: ActorInitializationException if e.getCause ne null ? e.getCause.getMessage
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:42: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   x.get
[warn]       case (x, Some(window))                 ? retriesInWindowOkay(if (x.isDefined) x.get else 1, window)
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:343: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]     try context.system.eventStream.publish(logEvent) catch { case NonFatal(_) ? }
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\FaultHandling.scala:214: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]     { case x ? directives collectFirst { case (c, d) if c isInstance x ? d } getOrElse Escalate }
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\IndirectActorProducer.scala:45: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   args.head.asInstanceOf[T]
[warn]       def get1stArg[T]: T = args.head.asInstanceOf[T]
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\IndirectActorProducer.scala:46: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   args.tail.head.asInstanceOf[T]
[warn]       def get2ndArg[T]: T = args.tail.head.asInstanceOf[T]
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\IndirectActorProducer.scala:57: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Reflect.instantiate[_$2](clazz, args).asInstanceOf[akka.actor.IndirectActorProducer]
[warn]           Reflect.instantiate(clazz, args).asInstanceOf[IndirectActorProducer]
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\IndirectActorProducer.scala:60: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   clazz.asInstanceOf[Class[_ <: akka.actor.Actor]]
[warn]       if (args.isEmpty) new NoArgsReflectConstructor(clazz.asInstanceOf[Class[_ <: Actor]])
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\IndirectActorProducer.scala:61: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   clazz.asInstanceOf[Class[_ <: akka.actor.Actor]]
[warn]       else new ArgsReflectConstructor(clazz.asInstanceOf[Class[_ <: Actor]], args)
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\IndirectActorProducer.scala:96: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Reflect.instantiate[_$7](ArgsReflectConstructor.this.constructor, ArgsReflectConstructor.this.args).asInstanceOf[akka.actor.Actor]
[warn]   override def produce() = Reflect.instantiate(constructor, args).asInstanceOf[Actor]
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:87: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   java.this.lang.Thread.sleep(sleepMs)

[warn] } catch {

[warn]   case (_: InterruptedException) => java.this.lang.Thread.currentThread().interrupt()

[warn] }
[warn]     try Thread.sleep(sleepMs) catch {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:144: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   task.run()

[warn] } catch {

[warn]   case (e @ (_: InterruptedException)) => throw e

[warn]   case (_: akka.actor.SchedulerException) => ()

[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((e @ _)) => LightArrayRevolverScheduler.this.log.error(e, "exception while executing timer tas
[warn]       try task.run() catch {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:330: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   TaskHolder.this.executionContext.execute(other);

[warn]   true

[warn] } catch {

[warn]   case (_: InterruptedException) => {

[warn]     java.this.lang.Thread.currentThread().interrupt();

[warn]     false

[warn]   }

[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((e @ _)) => {

[warn]     TaskHolder.this.ex
[warn]         try {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:238: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   $anon.this.nextTick()

[warn] } catch {

[warn]   case (t @ (_: Throwable)) => {

[warn]     LightArrayRevolverScheduler.this.log.error(t, "exception on LARS’ timer thread");

[warn]     LightArrayRevolverScheduler.this.stopped.get() match {

[warn]       case null => {

[warn]         val thread: Thread = LightArrayRevolverSchedul
[warn]       try nextTick()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:116: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   c.!=(null)
[warn]           case null ? if (c != null) c.cancel()
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:125: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.compareAndSet(c, null)
[warn]             if (c.cancel()) compareAndSet(c, null)
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:130: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.get().==(null)
[warn]       override def isCancelled: Boolean = get == null
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:164: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LightArrayRevolverScheduler.this.stopped.get().!=(null)
[warn]       if (stopped.get != null) throw new SchedulerException("cannot enqueue after timer shutdown")
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:167: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LightArrayRevolverScheduler.this.stopped.get().!=(null)
[warn]     } else if (stopped.get != null) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:190: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LightArrayRevolverScheduler.this.stopped.compareAndSet(null, p)
[warn]     if (stopped.compareAndSet(null, p)) {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:237: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   final override def run: Unit = try {

[warn]   $anon.this.nextTick()

[warn] } catch {

[warn]   case (t @ (_: Throwable)) => {

[warn]     LightArrayRevolverScheduler.this.log.error(t, "exception on LARS’ timer thread");

[warn]     LightArrayRevolverScheduler.this.stopped.get() match {

[warn]       case null => {

[warn]         val thread: Thr
[warn]     override final def run =
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:350: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = ()
[warn]   private[this] val CancelledTask = new Runnable { def run = () }
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:351: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = ()
[warn]   private[this] val ExecutedTask = new Runnable { def run = () }
[warn]                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:121: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]       @tailrec final def cancel(): Boolean = {
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:237: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     override final def run =
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:261: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     @tailrec final def nextTick(): Unit = {
[info]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\LightArrayRevolverScheduler.scala:146: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: akka.actor.SchedulerException) => ()
[warn]         case _: SchedulerException   ? // ignore terminated actors
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Props.scala:130: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Props.this._producer.eq(null)
[warn]     if (_producer eq null)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Props.scala:137: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Props.this._cachedActorClass.eq(null)
[warn]     if (_cachedActorClass eq null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ReflectiveDynamicAccess.scala:21: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   java.this.lang.Class.forName(fqcn, false, ReflectiveDynamicAccess.this.classLoader).asInstanceOf[Class[_ <: T]]
[warn]       val c = Class.forName(fqcn, false, classLoader).asInstanceOf[Class[_ <: T]]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ReflectiveDynamicAccess.scala:34: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   obj.asInstanceOf[T]
[warn]       if (t.isInstance(obj)) obj.asInstanceOf[T] else throw new ClassCastException(clazz.getName + " is not a subtype of " + t)
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\RepointableActorRef.scala:50: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractActorRef.cellOffset).asInstanceOf[akka.actor.Cell]
[warn]   def underlying: Cell = Unsafe.instance.getObjectVolatile(this, cellOffset).asInstanceOf[Cell]
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\RepointableActorRef.scala:51: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractActorRef.lookupOffset).asInstanceOf[akka.actor.Cell]
[warn]   def lookup = Unsafe.instance.getObjectVolatile(this, lookupOffset).asInstanceOf[Cell]
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\RepointableActorRef.scala:154: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   crs.child.asInstanceOf[akka.actor.InternalActorRef]
[warn]               crs.child.asInstanceOf[InternalActorRef].getChild(name)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\RepointableActorRef.scala:118: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val old: akka.actor.UnstartedCell = _).
[warn]   def newCell(old: UnstartedCell): Cell =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Scheduler.scala:51: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = {

[warn]   actor.this.`package`.actorRef2Scala(receiver).!(message)(sender);

[warn]   if (receiver.isTerminated)

[warn]     throw new SchedulerException("timer active for terminated actor")

[warn]   else

[warn]     ()

[warn] }
[warn]       def run = {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Scheduler.scala:78: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def run: Unit = f
[warn]     schedule(initialDelay, interval, new Runnable { override def run = f })
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Scheduler.scala:114: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def run: Unit = actor.this.`package`.actorRef2Scala(receiver).!(message)(sender)
[warn]       override def run = receiver ! message
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Scheduler.scala:126: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def run: Unit = f
[warn]     scheduleOnce(delay, new Runnable { override def run = f })
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Stash.scala:124: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   StashSupport.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]   private def actorCell = context.asInstanceOf[ActorCell]
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Stash.scala:252: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn] class StashOverflowException(message: String, cause: Throwable = null) extends AkkaException(message, cause) with NoStackTrace
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Stash.scala:158: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StashSupport.this.theStash.last
[warn]     if (theStash.nonEmpty && (currMsg eq theStash.last))
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Stash.scala:184: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StashSupport.this.theStash.head
[warn]     enqueueFirst(theStash.head)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\Stash.scala:186: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StashSupport.this.theStash.tail
[warn]     theStash = theStash.tail
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:47: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.asInstanceOf[akka.actor.InternalActorRef]
[warn]     case ref  ? ref.asInstanceOf[InternalActorRef].stop; true
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:247: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TypedActor.this.context.parent.asInstanceOf[akka.actor.InternalActorRef]
[warn]     if (!context.parent.asInstanceOf[InternalActorRef].isLocal)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:277: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[R]
[warn]           proxyVar.set(null.asInstanceOf[R])
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:330: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TypedActor.this.me.asInstanceOf[akka.actor.TypedActor.Receiver]
[warn]         me.asInstanceOf[Receiver].onReceive(msg, sender())
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:412: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   args.length.==(1).&&(proxy.eq(args.apply(0))).||(TypedActorInvocationHandler.this.actor.==(TypedActorInvocationHandler.this.extension.getActorRefFor(args.apply(0)))).asInstanceOf[AnyRef]
[warn]       case "equals"   ? (args.length == 1 && (proxy eq args(0)) || actor == extension.getActorRefFor(args(0))).asInstanceOf[AnyRef] //Force boxing of the boolean
[warn]                                                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:413: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TypedActorInvocationHandler.this.actor.hashCode().asInstanceOf[AnyRef]
[warn]       case "hashCode" ? actor.hashCode.asInstanceOf[AnyRef]
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:430: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   t.get.asInstanceOf[AnyRef]
[warn]                 t.get.asInstanceOf[AnyRef]
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:434: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   other.asInstanceOf[AnyRef]
[warn]             case other        ? other.asInstanceOf[AnyRef]
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:510: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.this.Predef.implicitly[scala.reflect.ClassTag[T]](evidence$1).runtimeClass.asInstanceOf[Class[T]]
[warn]     new TypedProps[T](implicitly[ClassTag[T]].runtimeClass.asInstanceOf[Class[T]])
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:672: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   java.lang.reflect.Proxy.newProxyInstance(props.loader.orElse[ClassLoader](props.interfaces.collectFirst[ClassLoader](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Class[_],ClassLoader] with Serializable {

[warn]     def <init>(): <$anon: Class[_] => ClassLoader> = {

[warn]       $anonfun.super.<init>();

[warn]       ()

[warn]     };

[warn]     final override def applyOrElse[A1 <: Class[_], B1 >: ClassLoader](x2: A1, default: A1 => B1): B1 = ((x2.asInstanceOf
[warn]       new TypedActorInvocationHandler(this, actorVar, props.timeout getOrElse DefaultReturnTimeout)).asInstanceOf[R]
[warn]                                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:131: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   MethodCall.this.method.getReturnType().==(java.lang.Void.TYPE)
[warn]     def isOneWay = method.getReturnType == java.lang.Void.TYPE
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:329: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TypedActor.this.me.isInstanceOf[akka.actor.TypedActor.Receiver]
[warn]       case msg if me.isInstanceOf[Receiver] ? withContext {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:141: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def apply(instance: AnyRef): AnyRef = try {

[warn]   MethodCall.this.parameters match {

[warn]     case null => MethodCall.this.method.invoke(instance)

[warn]     case (args @ _) if args.length.==(0) => MethodCall.this.method.invoke(instance)

[warn]     case (args @ _) => MethodCall.this.method.invoke(instance, (args: _*))
[warn]     def apply(instance: AnyRef): AnyRef = try {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:410: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   @throws[Throwable](classOf[java.lang.Throwable]) def invoke(proxy: AnyRef, method: java.lang.reflect.Method, args: Array[AnyRef]): AnyRef = method.getName() match {

[warn]   case "toString" => TypedActorInvocationHandler.this.actor.toString()

[warn]   case "equals" => args.length.==(1).&&(proxy.eq(args.apply(0)
[warn]     def invoke(proxy: AnyRef, method: Method, args: Array[AnyRef]): AnyRef = method.getName match {
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:104: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.actor.TypedActorExtension = TypedActor.super.get(system)
[info]   override def get(system: ActorSystem): TypedActorExtension = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:150: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TypedActor.this.SerializedMethodCall.apply(MethodCall.this.method.getDeclaringClass(), MethodCall.this.method.getName(), MethodCall.this.method.getParameterTypes(), null)
[warn]       case null                 ? SerializedMethodCall(method.getDeclaringClass, method.getName, method.getParameterTypes, null)
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:177: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   system.eq(null)
[warn]       if (system eq null) throw new IllegalStateException(
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:299: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TypedActor.selfReference.set(null)
[warn]         TypedActor.selfReference set null
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:300: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TypedActor.currentContext.set(null)
[warn]         TypedActor.currentContext set null
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:660: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TypedActorExtension.this.invocationHandlerFor(proxyOrNot).ne(null)
[warn]   def isTypedActor(proxyOrNot: AnyRef): Boolean = invocationHandlerFor(proxyOrNot) ne null
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:668: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new java.util.concurrent.atomic.AtomicReference[akka.actor.ActorRef](null)
[warn]     val actorVar = new AtomVar[ActorRef](null)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:674: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   proxyVar.eq(null)
[warn]     if (proxyVar eq null) {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:430: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   t.get
[warn]                 t.get.asInstanceOf[AnyRef]
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:579: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val loader: ClassLoader = _
[warn]   def withLoader(loader: ClassLoader): TypedProps[T] = withLoader(Option(loader))
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:587: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val loader: Option[ClassLoader] = _
[warn]   def withLoader(loader: Option[ClassLoader]): TypedProps[T] = this.copy(loader = loader)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:593: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val timeout: akka.util.Timeout = _
[warn]   def withTimeout(timeout: Timeout): TypedProps[T] = this.copy(timeout = Option(timeout))
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\TypedActor.scala:601: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val timeout: Option[akka.util.Timeout] = _
[warn]   def withTimeout(timeout: Option[Timeout]): TypedProps[T] = this.copy(timeout = timeout)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\UntypedActor.scala:109: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   UntypedActor.this.context.asInstanceOf[akka.actor.UntypedActorContext]
[warn]   def getContext(): UntypedActorContext = context.asInstanceOf[UntypedActorContext]
[warn]                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\UntypedActor.scala:137: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   @throws[Exception](classOf[java.lang.Exception]) override def preStart(): Unit = UntypedActor.super.preStart()
[info]   override def preStart(): Unit = super.preStart()
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\UntypedActor.scala:146: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   @throws[Exception](classOf[java.lang.Exception]) override def postStop(): Unit = UntypedActor.super.postStop()
[info]   override def postStop(): Unit = super.postStop()
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\UntypedActor.scala:155: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   @throws[Exception](classOf[java.lang.Exception]) override def preRestart(reason: Throwable, message: Option[Any]): Unit = UntypedActor.super.preRestart(reason, message)
[info]   override def preRestart(reason: Throwable, message: Option[Any]): Unit = super.preRestart(reason, message)
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\UntypedActor.scala:163: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   @throws[Exception](classOf[java.lang.Exception]) override def postRestart(reason: Throwable): Unit = UntypedActor.super.postRestart(reason)
[info]   override def postRestart(reason: Throwable): Unit = super.postRestart(reason)
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\UntypedActor.scala:174: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def unhandled(message: Any): Unit = UntypedActor.super.unhandled(message)
[info]   override def unhandled(message: Any): Unit = super.unhandled(message)
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:45: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def OneForOneStrategy = akka.actor.OneForOneStrategy
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:50: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def AllForOneStrategy = akka.actor.AllForOneStrategy
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:55: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def Stop = SupervisorStrategy.Stop
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:60: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def Restart = SupervisorStrategy.Restart
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:65: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def Resume = SupervisorStrategy.Resume
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:70: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def Escalate = SupervisorStrategy.Escalate
[info]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:36: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private[this] var preStartFun: () ? Unit = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:37: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private[this] var postStopFun: () ? Unit = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:38: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private[this] var preRestartFun: (Throwable, Option[Any]) ? Unit = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:39: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private[this] var postRestartFun: Throwable ? Unit = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:40: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private[this] var strategy: SupervisorStrategy = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:122: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Act.this.preStartFun.!=(null)
[warn]     override def preStart(): Unit = if (preStartFun != null) preStartFun() else super.preStart()
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:123: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Act.this.preRestartFun.!=(null)
[warn]     override def preRestart(cause: Throwable, msg: Option[Any]): Unit = if (preRestartFun != null) preRestartFun(cause, msg) else super.preRestart(cause, msg)
[warn]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:124: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Act.this.postRestartFun.!=(null)
[warn]     override def postRestart(cause: Throwable): Unit = if (postRestartFun != null) postRestartFun(cause) else super.postRestart(cause)
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:125: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Act.this.postStopFun.!=(null)
[warn]     override def postStop(): Unit = if (postStopFun != null) postStopFun() else super.postStop()
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:126: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Act.this.strategy.!=(null)
[warn]     override def supervisorStrategy: SupervisorStrategy = if (strategy != null) strategy else super.supervisorStrategy
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Creators.scala:178: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   name.==(null)
[warn]     if (name == null) factory.actorOf(props)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:218: [scapegoat] Finalizer without super
[warn]   Finalizers should call `super.finalize()` to ensure superclasses are able to run their finalization logic.
[warn]     override def finalize() {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:186: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def receive(timeout: scala.concurrent.duration.FiniteDuration = Inbox.this.defaultTimeout): Any = {

[warn]   implicit val t: akka.util.Timeout = akka.util.Timeout.apply(timeout.+(Inbox.this.extraTime));

[warn]   scala.concurrent.Await.result[Any]({

[warn]     <artifact> val qual$1: akka.pattern.AskableActorRef = akka
[warn]     def receive(timeout: FiniteDuration = defaultTimeout): Any = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:34: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private final case class Get(deadline: Deadline, client: ActorRef = null) extends Query {
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:37: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private final case class Select(deadline: Deadline, predicate: PartialFunction[Any, Any], client: ActorRef = null) extends Query {
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:108: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           currentSelect = null
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:129: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           currentMsg = null
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:134: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   InboxActor.this.currentDeadline.get
[warn]           currentDeadline.get._2.cancel()
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:144: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   InboxActor.this.currentDeadline.get
[warn]           currentDeadline.get._2.cancel()
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dsl\Inbox.scala:49: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val `this`: Inbox.this.Extension = _
[warn]   protected trait InboxExtension { this: Extension ?
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:27: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractActorCell.childrenOffset).asInstanceOf[akka.actor.dungeon.ChildrenContainer]
[warn]     Unsafe.instance.getObjectVolatile(this, AbstractActorCell.childrenOffset).asInstanceOf[ChildrenContainer]
[warn]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:50: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractActorCell.functionRefsOffset).asInstanceOf[Map[String,akka.actor.FunctionRef]]
[warn]     Unsafe.instance.getObjectVolatile(this, AbstractActorCell.functionRefsOffset).asInstanceOf[Map[String, FunctionRef]]
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:93: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getAndSetObject(this, AbstractActorCell.functionRefsOffset, scala.this.Predef.Map.empty[Nothing, Nothing]).asInstanceOf[Map[String,akka.actor.FunctionRef]]
[warn]     val refs = Unsafe.instance.getAndSetObject(this, AbstractActorCell.functionRefsOffset, Map.empty).asInstanceOf[Map[String, FunctionRef]]
[warn]                                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:119: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.asInstanceOf[akka.actor.InternalActorRef]
[warn]     actor.asInstanceOf[InternalActorRef].stop()
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:141: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   old.asInstanceOf[Option[akka.actor.ChildRestartStats]]
[warn]       case old @ Some(_: ChildRestartStats) ? old.asInstanceOf[Option[ChildRestartStats]]
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:175: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   child.asInstanceOf[akka.actor.InternalActorRef]
[warn]       case ChildRestartStats(child, _, _) if !(exceptFor contains child) ? child.asInstanceOf[InternalActorRef].suspend()
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:195: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   crs.child.asInstanceOf[akka.actor.InternalActorRef]
[warn]         case Some(crs: ChildRestartStats) ? crs.child.asInstanceOf[InternalActorRef]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:202: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   crs.child.asInstanceOf[akka.actor.InternalActorRef]
[warn]           crs.child.asInstanceOf[InternalActorRef]
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:248: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   arg.asInstanceOf[AnyRef]
[warn]               val o = arg.asInstanceOf[AnyRef]
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:271: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   val childPath: akka.actor.ChildActorPath = new akka.actor.ChildActorPath(cell.self.path, name, akka.actor.ActorCell.newUid());

[warn]   cell.provider.actorOf(cell.systemImpl, props, cell.self, childPath, systemService, scala.None, true, async)

[warn] } catch {

[warn]   case (e @ (_: InterruptedException)) =>
[warn]         try {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:256: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   ser.deserialize[?0](bytes, arg.getClass()).get.!=(null)
[warn]                   ser.deserialize(bytes, arg.getClass).get != null
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:246: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   arg.isInstanceOf[akka.actor.NoSerializationVerificationNeeded]
[warn]             arg.isInstanceOf[NoSerializationVerificationNeeded] ||
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:285: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Children.this.mailbox.ne(null)
[warn]       if (mailbox ne null) for (_ ← 1 to mailbox.suspendCount) actor.suspend()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:254: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ser.deserialize(bytes, serializer.identifier, manifest).get
[warn]                   ser.deserialize(bytes, serializer.identifier, manifest).get != null
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:256: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ser.deserialize[?0](bytes, arg.getClass()).get
[warn]                   ser.deserialize(bytes, arg.getClass).get != null
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Children.scala:285: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: Int = _
[warn]       if (mailbox ne null) for (_ ← 1 to mailbox.suspendCount) actor.suspend()
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:53: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.asInstanceOf[akka.actor.ChildRestartStats]
[warn]     override final def apply(c: ChildStats) = c.asInstanceOf[ChildRestartStats]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:59: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.asInstanceOf[akka.actor.ChildRestartStats]
[warn]     override final def apply(c: ChildStats) = c.asInstanceOf[ChildRestartStats].child
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:115: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.asInstanceOf[Option[akka.actor.ChildRestartStats]]
[warn]       case c @ Some(crs: ChildRestartStats) if (crs.child == actor) ? c.asInstanceOf[Option[ChildRestartStats]]
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:175: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.asInstanceOf[Option[akka.actor.ChildRestartStats]]
[warn]       case c @ Some(crs: ChildRestartStats) if (crs.child == actor) ? c.asInstanceOf[Option[ChildRestartStats]]
[warn]                                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:49: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info]   final case class Creation() extends SuspendReason with WaitingForChildren
[info]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:54: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.isInstanceOf[akka.actor.ChildRestartStats]
[warn]     override final def isDefinedAt(c: ChildStats) = c.isInstanceOf[ChildRestartStats]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:60: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.isInstanceOf[akka.actor.ChildRestartStats]
[warn]     override final def isDefinedAt(c: ChildStats) = c.isInstanceOf[ChildRestartStats]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:114: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   NormalChildrenContainer.this.c.get(actor.path.name) match {

[warn]   case (c @ (x: akka.actor.ChildStats)Some[akka.actor.ChildStats]((crs @ (_: akka.actor.ChildRestartStats)))) if crs.child.==(actor) => c.a
[warn]     override def getByRef(actor: ActorRef): Option[ChildRestartStats] = c.get(actor.path.name) match {
[warn]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\ChildrenContainer.scala:174: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   TerminatingChildrenContainer.this.c.get(actor.path.name) match {

[warn]   case (c @ (x: akka.actor.ChildStats)Some[akka.actor.ChildStats]((crs @ (_: akka.actor.ChildRestartStats)))) if crs.child.==(actor) =
[warn]     override def getByRef(actor: ActorRef): Option[ChildRestartStats] = c.get(actor.path.name) match {
[warn]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\DeathWatch.scala:86: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   watcher.asInstanceOf[akka.actor.ActorRefScope]
[warn]           if (watcher.asInstanceOf[ActorRefScope].isLocal == ifLocal && watcher != parent)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\DeathWatch.scala:87: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   watcher.asInstanceOf[akka.actor.InternalActorRef]
[warn]             watcher.asInstanceOf[InternalActorRef].sendSystemMessage(DeathWatchNotification(self, existenceConfirmed = true, addressTerminated = false))
[warn]                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\DeathWatch.scala:82: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   DeathWatch.this.watchedBy.isEmpty.unary_!
[info]     if (!watchedBy.isEmpty) {
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\DeathWatch.scala:112: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   DeathWatch.this.watching.isEmpty.unary_!
[info]     if (!watching.isEmpty) {
[info]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\DeathWatch.scala:180: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private def maintainAddressTerminatedSubscription[T](change: ActorRef = null)(block: ? T): T = {
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:25: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractActorCell.mailboxOffset).asInstanceOf[akka.dispatch.Mailbox]
[warn]   @inline final def mailbox: Mailbox = Unsafe.instance.getObjectVolatile(this, AbstractActorCell.mailboxOffset).asInstanceOf[Mailbox]
[warn]                                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:130: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.message match {

[warn]   case (message: Any, sender: akka.actor.ActorRef, recipient: akka.actor.ActorRef)akka.actor.DeadLetter((wrapped @ _), _, _) => wrapped

[warn]   case (other @ _) => other

[warn] }.asInstanceOf[AnyRef]
[warn]         }).asInstanceOf[AnyRef]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:113: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   Dispatch.this.dispatcher.systemDispatch(this, akka.dispatch.sysmsg.Suspend.apply())

[warn] } catch {

[warn]   case (x$1 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr1: util.control.Exception.Catcher[Unit] = Dispatch.this.handleException;

[warn]     if (catchExpr1.isDefinedAt(x$1))

[warn]       catchExpr1.ap
[warn]   final def suspend(): Unit = try dispatcher.systemDispatch(this, Suspend()) catch handleException
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:116: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   Dispatch.this.dispatcher.systemDispatch(this, akka.dispatch.sysmsg.Resume.apply(causedByFailure))

[warn] } catch {

[warn]   case (x$2 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr2: util.control.Exception.Catcher[Unit] = Dispatch.this.handleException;

[warn]     if (catchExpr2.isDefinedAt(x$2))

[warn]      
[warn]   final def resume(causedByFailure: Throwable): Unit = try dispatcher.systemDispatch(this, Resume(causedByFailure)) catch handleException
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:119: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   Dispatch.this.dispatcher.systemDispatch(this, akka.dispatch.sysmsg.Recreate.apply(cause))

[warn] } catch {

[warn]   case (x$3 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr3: util.control.Exception.Catcher[Unit] = Dispatch.this.handleException;

[warn]     if (catchExpr3.isDefinedAt(x$3))

[warn]       catchEx
[warn]   final def restart(cause: Throwable): Unit = try dispatcher.systemDispatch(this, Recreate(cause)) catch handleException
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:122: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   Dispatch.this.dispatcher.systemDispatch(this, akka.dispatch.sysmsg.Terminate.apply())

[warn] } catch {

[warn]   case (x$4 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr4: util.control.Exception.Catcher[Unit] = Dispatch.this.handleException;

[warn]     if (catchExpr4.isDefinedAt(x$4))

[warn]       catchExpr4.
[warn]   final def stop(): Unit = try dispatcher.systemDispatch(this, Terminate()) catch handleException
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:125: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   if (Dispatch.this.system.settings.SerializeAllMessages)

[warn]     {

[warn]       val unwrapped: AnyRef = msg.message match {

[warn]   case (message: Any, sender: akka.actor.ActorRef, recipient: akka.actor.ActorRef)akka.actor.DeadLetter((wrapped @ _), _, _) => wrapped

[warn]   case (other @ _) => other

[warn] }.asInstan
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:147: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   Dispatch.this.dispatcher.systemDispatch(this, message)

[warn] } catch {

[warn]   case (x$6 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr6: util.control.Exception.Catcher[Unit] = Dispatch.this.handleException;

[warn]     if (catchExpr6.isDefinedAt(x$6))

[warn]       catchExpr6.apply(x$6)

[warn]     else

[warn]       thr
[warn]   override def sendSystemMessage(message: SystemMessage): Unit = try dispatcher.systemDispatch(this, message) catch handleException
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:131: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   unwrapped.isInstanceOf[akka.actor.NoSerializationVerificationNeeded]
[warn]         if (!unwrapped.isInstanceOf[NoSerializationVerificationNeeded]) {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:64: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   mbox.messageQueue.==(null)
[warn]           val gotType = if (mbox.messageQueue == null) "null" else mbox.messageQueue.getClass.getName
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:138: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   s.deserialize(bytes, serializer.identifier, manifest).get.!=(null)
[warn]               s.deserialize(bytes, serializer.identifier, manifest).get != null
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:138: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   s.deserialize(bytes, serializer.identifier, manifest).get
[warn]               s.deserialize(bytes, serializer.identifier, manifest).get != null
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\Dispatch.scala:140: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   s.deserialize[?0](bytes, unwrapped.getClass()).get
[warn]               s.deserialize(bytes, unwrapped.getClass).get
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:244: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   child.asInstanceOf[akka.actor.InternalActorRef]
[warn]         try child.asInstanceOf[InternalActorRef].restart(cause)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:65: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   if (failedActor.context.ne(null))

[warn]     failedActor.aroundPreRestart(cause, optionalMessage)

[warn]   else

[warn]     ()

[warn] } catch {

[warn]   case (x$1 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr1: util.control.Exception.Catcher[Unit] = FaultHandling.this.handleNonFatalOrInterruptedException(((e: Thro
[warn]         try {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:136: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   FaultHandling.this.create(scala.None)

[warn] } catch {

[warn]   case (x$2 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr2: util.control.Exception.Catcher[Unit] = FaultHandling.this.handleNonFatalOrInterruptedException(((e: Throwable) => FaultHandling.this.handleInvokeFailure(immutable.this.Nil, e
[warn]     try create(None)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:178: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   FaultHandling.this.suspendNonRecursive();

[warn]   val skip: Set[akka.actor.ActorRef] = FaultHandling.this.currentMessage match {

[warn]     case (message: Any, sender: akka.actor.ActorRef)akka.dispatch.Envelope((child: akka.actor.ActorRef, cause: Throwable, uid: Int)akka.dispatch.sysmsg.Failed(_, _, _
[warn]     if (!isFailed) try {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:210: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   if (a.ne(null))

[warn]     a.aroundPostStop()

[warn]   else

[warn]     ()

[warn] } catch {

[warn]   case (x$4 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr4: util.control.Exception.Catcher[Unit] = FaultHandling.this.handleNonFatalOrInterruptedException(((e: Throwable) => FaultHandling.this.publish(akka.event.Logg
[warn]     try if (a ne null) a.aroundPostStop()
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:231: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   try {

[warn]     FaultHandling.this.resumeNonRecursive()

[warn]   } finally FaultHandling.this.clearFailed();

[warn]   val freshActor: akka.actor.Actor = FaultHandling.this.newActor();

[warn]   FaultHandling.this.actor_=(freshActor);

[warn]   if (freshActor.eq(failedActor))

[warn]     FaultHandling.this.setActorFields(freshAc
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:280: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   FaultHandling.this.actor.supervisorStrategy.handleChildTerminated(this, child, FaultHandling.this.children)

[warn] } catch {

[warn]   case (x$7 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr7: util.control.Exception.Catcher[Unit] = FaultHandling.this.handleNonFatalOrInterruptedException(((e: Thro
[warn]       try actor.supervisorStrategy.handleChildTerminated(this, child, children)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:46: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var _failed: ActorRef = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:49: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private def clearFailed(): Unit = _failed = null
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:223: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       actor = null
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:47: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FaultHandling.this._failed.!=(null)
[warn]   private def isFailed: Boolean = _failed != null
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:56: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FaultHandling.this.actor.==(null)
[warn]     if (actor == null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:63: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   failedActor.ne(null)
[warn]       if (failedActor ne null) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:64: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FaultHandling.this.currentMessage.ne(null)
[warn]         val optionalMessage = if (currentMessage ne null) Some(currentMessage.message) else None
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:67: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   failedActor.context.ne(null)
[warn]           if (failedActor.context ne null) failedActor.aroundPreRestart(cause, optionalMessage)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:79: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FaultHandling.this.faultResume(null)
[warn]       faultResume(causedByFailure = null)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:99: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FaultHandling.this.actor.==(null)
[warn]     if (actor == null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:112: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   causedByFailure.!=(null)
[warn]       finally if (causedByFailure != null) clearFailed()
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:210: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   a.ne(null)
[warn]     try if (a ne null) a.aroundPostStop()
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\dungeon\FaultHandling.scala:279: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FaultHandling.this.actor.!=(null)
[warn]     if (actor != null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\package.scala:10: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.asInstanceOf[akka.actor.ScalaActorRef]
[warn]   implicit def actorRef2Scala(ref: ActorRef): ScalaActorRef = ref.asInstanceOf[ScalaActorRef]
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\package.scala:11: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.asInstanceOf[akka.actor.ActorRef]
[warn]   implicit def scala2ActorRef(ref: ScalaActorRef): ActorRef = ref.asInstanceOf[ActorRef]
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:395: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   if (r.isInstanceOf[scala.concurrent.forkjoin.ForkJoinTask[_]])

[warn]   r

[warn] else

[warn]   new ForkJoinExecutorConfigurator.this.AkkaForkJoinTask(r).asInstanceOf[scala.concurrent.forkjoin.ForkJoinTask[Any]]
[warn]         super.execute((if (r.isInstanceOf[ForkJoinTask[_]]) r else new AkkaForkJoinTask(r)).asInstanceOf[ForkJoinTask[Any]])
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:409: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   AkkaForkJoinTask.this.runnable.run();

[warn]   true

[warn] } catch {

[warn]   case (ie @ (_: InterruptedException)) => {

[warn]     java.this.lang.Thread.currentThread().interrupt();

[warn]     false

[warn]   }

[warn]   case (anything @ (_: Throwable)) => {

[warn]     val t: Thread = java.this.lang.Thread.currentThread();

[warn]     t.getUncau
[warn]     final override def exec(): Boolean = try { runnable.run(); true } catch {
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:144: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   MessageDispatcher.this.executeTask(invocation)

[warn] } catch {

[warn]   case (t @ (_: Throwable)) => {

[warn]     MessageDispatcher.this.addInhabitants(-1L);

[warn]     throw t

[warn]   }

[warn] }
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:66: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   MessageDispatcher.this.actors.keys.foreach[Unit](((d: akka.dispatch.MessageDispatcher) => {

[warn]   scala.this.Predef.println(scala.this.Predef.any2stringadd[akka.dispatch.MessageDispatcher](d).+(" inhabitants: ").+(d.inhabitants));

[warn]   MessageDispatcher.this.actors.valueIterator(d)

[warn] }.foreach[Unit](((a: akka.actor.ActorRef) => {

[warn]     val status: String = if (a.isTerminated)

[warn]       " (terminated)"

[warn]     else

[warn]       " (alive)";

[warn]     val messages: String = a match {

[warn]       case (r @ (_: akk
[warn]     if (debug) {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:189: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   MessageDispatcher.actors.put(this, actor.self)

[warn] else

[warn]   ()
[warn]     if (debug) actors.put(this, actor.self)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:199: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   MessageDispatcher.actors.remove(this, actor.self)

[warn] else

[warn]   ()
[warn]     if (debug) actors.remove(this, actor.self)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:165: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (MessageDispatcher.this.updateShutdownSchedule(MessageDispatcher.SCHEDULED, MessageDispatcher.RESCHEDULED))

[warn]   ()

[warn] else

[warn]   MessageDispatcher.this.ifSensibleToDoSoThenScheduleShutdown()
[warn]         if (updateShutdownSchedule(SCHEDULED, RESCHEDULED)) ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:469: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Using passed in ExecutionContext as default executor for this ActorSystem. If you want to use a different executor, please specify one in akka.actor.default-dispatcher.default-executor.").s()
[warn]         prerequisites.eventStream.publish(Debug("DefaultExecutorServiceConfigurator", this.getClass, s"Using passed in ExecutionContext as default executor for this ActorSystem. If you want to use a different executor, please specify one in akka.actor.default-dispatcher.default-executor."))
[warn]                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:214: [scapegoat] Empty while block
[warn]   An empty while block is considered as dead code.
[warn]   while$1(){

[warn]   if (MessageDispatcher.this.updateShutdownSchedule(MessageDispatcher.this.shutdownSchedule, MessageDispatcher.UNSCHEDULED).unary_!)

[warn]     {

[warn]       ();

[warn]       while$1()

[warn]     }

[warn]   else

[warn]     ()

[warn] }
[warn]             while (!updateShutdownSchedule(shutdownSchedule, UNSCHEDULED)) {}
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:395: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   r.isInstanceOf[scala.concurrent.forkjoin.ForkJoinTask[_]]
[warn]         super.execute((if (r.isInstanceOf[ForkJoinTask[_]]) r else new AkkaForkJoinTask(r)).asInstanceOf[ForkJoinTask[Any]])
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:26: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   message.==(null)
[warn]     if (message == null) throw new InvalidMessageException("Message is null")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:394: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   r.ne(null)
[warn]       if (r ne null)
[warn]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:32: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def isBatchable: Boolean = runnable match {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:208: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final def run() {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:409: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final override def exec(): Boolean = try { runnable.run(); true } catch {
[info]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:334: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MessageDispatcherConfigurator.this.prerequisites.dynamicAccess.createInstanceFor[akka.dispatch.ExecutorServiceConfigurator](fqcn, args)((ClassTag.apply[akka.dispatch.ExecutorServiceConfigurator](classOf[akka.dispatch.ExecutorServiceConfigurator]): scala.reflect.ClassTag[akka.dispatch.ExecutorServiceConfigurator])).recover[akka.dispatch.ExecutorServiceConfigurator](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] 
[warn]         }).get
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:348: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val prerequisites: akka.dispatch.DispatcherPrerequisites = _).
[warn]   protected def createThreadPoolConfigBuilder(config: Config, prerequisites: DispatcherPrerequisites): ThreadPoolConfigBuilder = {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:348: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val config: com.typesafe.config.Config = _
[warn]   protected def createThreadPoolConfigBuilder(config: Config, prerequisites: DispatcherPrerequisites): ThreadPoolConfigBuilder = {
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\AbstractDispatcher.scala:348: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val prerequisites: akka.dispatch.DispatcherPrerequisites = _
[warn]   protected def createThreadPoolConfigBuilder(config: Config, prerequisites: DispatcherPrerequisites): ThreadPoolConfigBuilder = {
[warn]                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\BalancingDispatcher.scala:97: [scapegoat] Simplify boolean expressions
[info]   Boolean expressions such as x == false can be re-written as !x.
[info]   lm.atFullThrottle().==(false)
[info]             case lm: LoadMetrics ? lm.atFullThrottle == false
[info]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\BatchingExecutor.scala:73: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   Batch.this.processBatch(this)

[warn] } catch {

[warn]   case (t @ (_: Throwable)) => {

[warn]     Batch.this.resubmitUnbatched();

[warn]     throw t

[warn]   }

[warn] } finally BatchingExecutor.this._tasksLocal.remove()
[warn]       try processBatch(this) catch {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\BatchingExecutor.scala:91: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   BlockableBatch.this.processBatch(this)

[warn] } catch {

[warn]   case (t @ (_: Throwable)) => {

[warn]     BlockableBatch.this.resubmitUnbatched();

[warn]     throw t

[warn]   }

[warn] } finally {

[warn]   BatchingExecutor.this._tasksLocal.remove();

[warn]   if (firstInvocation)

[warn]     BatchingExecutor.this._blockContext.remove()

[warn]   else

[warn]         try processBatch(this) catch {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\BatchingExecutor.scala:88: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BatchingExecutor.this._blockContext.get().eq(null)
[warn]       val firstInvocation = _blockContext.get eq null
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\BatchingExecutor.scala:70: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   final override def run: Unit = {

[warn]   scala.this.Predef.require(BatchingExecutor.this._tasksLocal.get().eq(null));

[warn]   BatchingExecutor.this._tasksLocal.set(this);

[warn]   try {

[warn]     Batch.this.processBatch(this)

[warn]   } catch {

[warn]     case (t @ (_: Throwable)) => {

[warn]       Batch.this.resubmitUnbatched();

[warn]       
[warn]     override final def run: Unit = {
[warn]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\BatchingExecutor.scala:70: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     override final def run: Unit = {
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\BatchingExecutor.scala:85: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     override final def run(): Unit = {
[info]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\CachingConfig.scala:61: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   v.unwrapped().asInstanceOf[String]
[warn]                 StringPathEntry(true, true, v.atKey("cached"), v.unwrapped().asInstanceOf[String])
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\CachingConfig.scala:129: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def getAnyRef(path: String): Object = CachingConfig.this.config.getAnyRef(path)
[warn]   def getAnyRef(path: String) = config.getAnyRef(path)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Dispatcher.scala:100: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   protected[akka] def shutdown: Unit = {

[warn]   val newDelegate: Dispatcher.this.LazyExecutorServiceDelegate = Dispatcher.this.executorServiceDelegate.copy();

[warn]   val es: Dispatcher.this.LazyExecutorServiceDelegate = Dispatcher.this.esUpdater.getAndSet(this, newDelegate);

[warn]   es.shutdown()

[warn] }
[warn]   protected[akka] def shutdown: Unit = {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Dispatchers.scala:121: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Dispatchers.this.dispatcherConfigurators.putIfAbsent(id, configurator).==(null)
[warn]     dispatcherConfigurators.putIfAbsent(id, configurator) == null
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Dispatchers.scala:302: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new PinnedDispatcher(this, null, PinnedDispatcherConfigurator.this.config.getString("id"), akka.util.Helpers.ConfigOps(PinnedDispatcherConfigurator.this.config).getMillisDuration("shutdown-timeout"), PinnedDispatcherConfigurator.this.threadPoolConfig)
[warn]     new PinnedDispatcher(
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Dispatchers.scala:191: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Dispatchers.this.prerequisites.dynamicAccess.createInstanceFor[akka.dispatch.MessageDispatcherConfigurator](fqn, args)((ClassTag.apply[akka.dispatch.MessageDispatcherConfigurator](classOf[akka.dispatch.MessageDispatcherConfigurator]): scala.reflect.ClassTag[akka.dispatch.MessageDispatcherConfigurator])).recover[akka.dispatch.MessageDispatcherConfigurator](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Seri
[warn]         }).get
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:120: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]     val f = CompletableFuture.completedFuture[T](null.asInstanceOf[T])
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:196: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]     protected def internal(result: Throwable): T = null.asInstanceOf[T]
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:207: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   l.asInstanceOf[T]
[warn]     final def apply$mcLJ$sp(l: Long): BoxedUnit = { internal(l.asInstanceOf[T]); BoxedUnit.UNIT }
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:208: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   i.asInstanceOf[T]
[warn]     final def apply$mcLI$sp(i: Int): BoxedUnit = { internal(i.asInstanceOf[T]); BoxedUnit.UNIT }
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:209: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[T]
[warn]     final def apply$mcLF$sp(f: Float): BoxedUnit = { internal(f.asInstanceOf[T]); BoxedUnit.UNIT }
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:210: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   d.asInstanceOf[T]
[warn]     final def apply$mcLD$sp(d: Double): BoxedUnit = { internal(d.asInstanceOf[T]); BoxedUnit.UNIT }
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:258: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]     case Failure(t) ? onComplete(t, null.asInstanceOf[T])
[warn]                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:207: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     final def apply$mcLJ$sp(l: Long): BoxedUnit = { internal(l.asInstanceOf[T]); BoxedUnit.UNIT }
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:208: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     final def apply$mcLI$sp(i: Int): BoxedUnit = { internal(i.asInstanceOf[T]); BoxedUnit.UNIT }
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:209: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     final def apply$mcLF$sp(f: Float): BoxedUnit = { internal(f.asInstanceOf[T]); BoxedUnit.UNIT }
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:210: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     final def apply$mcLD$sp(d: Double): BoxedUnit = { internal(d.asInstanceOf[T]); BoxedUnit.UNIT }
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:259: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OnComplete.this.onComplete(null, r)
[warn]     case Success(r) ? onComplete(null, r)
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:189: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val result: T = _).
[warn]     protected def internal(result: T): Unit = ()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:196: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val result: Throwable = _).
[warn]     protected def internal(result: Throwable): T = null.asInstanceOf[T]
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:202: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val result: T = _).
[warn]     protected def internal(result: T): Boolean = false
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Future.scala:212: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val result: T = _).
[warn]     protected def internal(result: T): Unit = ()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:206: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractMailbox.systemMessageOffset).asInstanceOf[akka.dispatch.sysmsg.SystemMessage]
[warn]     new LatestFirstSystemMessageList(Unsafe.instance.getObjectVolatile(this, AbstractMailbox.systemMessageOffset).asInstanceOf[SystemMessage])
[warn]                                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:399: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   receiver.asInstanceOf[akka.actor.InternalActorRef]
[warn]       receiver.asInstanceOf[InternalActorRef].provider.deadLetters.tell(
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:527: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   receiver.asInstanceOf[akka.actor.InternalActorRef]
[warn]         receiver.asInstanceOf[InternalActorRef].provider.deadLetters.tell(
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:570: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   receiver.asInstanceOf[akka.actor.InternalActorRef]
[warn]         receiver.asInstanceOf[InternalActorRef].provider.deadLetters.tell(
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:577: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   receiver.asInstanceOf[akka.actor.InternalActorRef]
[warn]         receiver.asInstanceOf[InternalActorRef].provider.deadLetters.tell(
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:947: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   receiver.asInstanceOf[akka.actor.InternalActorRef]
[warn]         receiver.asInstanceOf[InternalActorRef].provider.deadLetters.tell(
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:234: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   Mailbox.this.run();

[warn]   false

[warn] } catch {

[warn]   case (ie @ (_: InterruptedException)) => {

[warn]     java.this.lang.Thread.currentThread().interrupt();

[warn]     false

[warn]   }

[warn]   case (anything @ (_: Throwable)) => {

[warn]     val t: Thread = java.this.lang.Thread.currentThread();

[warn]     t.getUncaughtExceptionHandl
[warn]   final override def exec(): Boolean = try { run(); false } catch {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:297: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   dlm.systemEnqueue(Mailbox.this.actor.self, msg)

[warn] } catch {

[warn]   case (e @ (_: InterruptedException)) => interruption = e

[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((e @ _)) => Mailbox.this.actor.system.eventStream.publish(akka.event.Logging.Error.apply(e, Mailb
[warn]       try dlm.systemEnqueue(actor.self, msg)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:442: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.any2stringadd[akka.actor.ActorRef](receiver).+(" having enqueued ").+(message))

[warn] else

[warn]   ()
[warn]     if (Mailbox.debug) println(receiver + " having enqueued " + message)
[warn]     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:606: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] final case class UnboundedMailbox() extends MailboxType with ProducesMessageQueue[UnboundedMailbox.MessageQueue] {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:628: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] final case class SingleConsumerOnlyUnboundedMailbox() extends MailboxType with ProducesMessageQueue[NodeMessageQueue] {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:765: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] final case class UnboundedDequeBasedMailbox() extends MailboxType with ProducesMessageQueue[UnboundedDequeBasedMailbox.MessageQueue] {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:840: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] final case class UnboundedControlAwareMailbox() extends MailboxType with ProducesMessageQueue[UnboundedControlAwareMailbox.MessageQueue] {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:643: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class NonBlockingBoundedMailbox(val capacity: Int) extends MailboxType with ProducesMessageQueue[BoundedNodeMessageQueue] {
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:782: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class BoundedDequeBasedMailbox( final val capacity: Int, override final val pushTimeOut: FiniteDuration)
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:274: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var interruption: Throwable = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:255: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   next.ne(null)
[warn]       if (next ne null) {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:305: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   interruption.ne(null)
[warn]     if (interruption ne null) {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:317: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Mailbox.this.actor.ne(null)
[warn]     if (actor ne null) { // actor is null for the deadLetterMailbox
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:328: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Mailbox.this.messageQueue.ne(null)
[warn]       if (messageQueue ne null) // needed for CallingThreadDispatcher, which never calls Mailbox.run()
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:382: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   envelope.ne(null)
[warn]     if (envelope ne null) {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:410: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   envelope.ne(null)
[warn]     if (envelope ne null) {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:445: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   DefaultSystemMessageQueue.this.actor.ne(null)
[warn]       if (actor ne null) actor.dispatcher.mailboxes.deadLetterMailbox.systemEnqueue(receiver, message)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:457: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new akka.dispatch.sysmsg.EarliestFirstSystemMessageList(null)
[warn]     if (currentList.head == NoMessage) new EarliestFirstSystemMessageList(null)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:485: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   envelope.ne(null)
[warn]       while (envelope ne null) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:665: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BoundedMailbox.this.pushTimeOut.eq(null)
[warn]   if (pushTimeOut eq null) throw new IllegalArgumentException("The push time-out for BoundedMailbox can not be null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:705: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BoundedPriorityMailbox.this.pushTimeOut.eq(null)
[warn]   if (pushTimeOut eq null) throw new IllegalArgumentException("The push time-out for BoundedMailbox can not be null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:748: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BoundedStablePriorityMailbox.this.pushTimeOut.eq(null)
[warn]   if (pushTimeOut eq null) throw new IllegalArgumentException("The push time-out for BoundedMailbox can not be null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:791: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BoundedDequeBasedMailbox.this.pushTimeOut.eq(null)
[warn]   if (pushTimeOut eq null) throw new IllegalArgumentException("The push time-out for BoundedDequeBasedMailbox can not be null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:819: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   controlMsg.ne(null)
[warn]     if (controlMsg ne null) controlMsg
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:610: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:632: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue = new NodeMessageQueue
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:649: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:667: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:769: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:793: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:261: [scapegoat] Simplify boolean expressions
[info]   Boolean expressions such as x == false can be re-written as !x.
[info]   Mailbox.this.dispatcher.isThroughputDeadlineTimeDefined.==(false)
[info]         if ((left > 1) && ((dispatcher.isThroughputDeadlineTimeDefined == false) || (System.nanoTime - deadlineNs) < 0))
[info]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:608: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:608: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:630: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:630: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:645: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this(config.getInt("mailbox-capacity"))
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:660: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this(
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:767: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:767: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:786: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this(
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:844: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:844: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailbox.scala:863: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this(
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailboxes.scala:204: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("which can lead to blocking behaviour when sending messages to this mailbox. ").s()
[warn]                     s"which can lead to blocking behaviour when sending messages to this mailbox. " +
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailboxes.scala:63: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Mailboxes.this.dynamicAccess.getClassFor[Any](k)((ClassTag.Any: scala.reflect.ClassTag[Any])).map[scala.collection.immutable.Map[Class[_],String]](((x0$2: Class[_]) => x0$2 match {

[warn]   case (x @ _) => m.updated[String](x, v.toString())

[warn] })).recover[scala.collection.immutable.Map[Class[_],String]](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => Nothing> =
[warn]           }.get
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailboxes.scala:95: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Mailboxes.this.dynamicAccess.getClassFor[AnyRef](x)((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])).get
[warn]     case x                    ? dynamicAccess.getClassFor[AnyRef](x).get
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\Mailboxes.scala:197: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Mailboxes.this.dynamicAccess.createInstanceFor[akka.dispatch.MailboxType](fqcn, args)((ClassTag.apply[akka.dispatch.MailboxType](classOf[akka.dispatch.MailboxType]): scala.reflect.ClassTag[akka.dispatch.MailboxType])).recover[akka.dispatch.MailboxType](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => Nothing> = {

[warn]       $anonfun.super.<init>();

[warn]       ()
[warn]                 }).get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\PinnedDispatcher.scala:44: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     owner = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\ThreadPoolBuilder.scala:172: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   result.get().get
[warn]       result.get.get // Exception intended if None
[warn]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\ThreadPoolBuilder.scala:92: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def createExecutorServiceFactory(id: String, threadFactory: ThreadFactory): ExecutorServiceFactory = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:221: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] private[akka] final case class Suspend() extends SystemMessage with StashWhenWaitingForChildren // sent to self from ActorCell.suspend
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:231: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] private[akka] final case class Terminate() extends SystemMessage with DeadLetterSuppression // sent to self from ActorCell.stop
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:160: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   final def reverse_:::(other: LatestFirstSystemMessageList): EarliestFirstSystemMessageList = {
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:192: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def unlink(): Unit = next = null
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:17: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new LatestFirstSystemMessageList(null)
[warn]   final val LNil: LatestFirstSystemMessageList = new LatestFirstSystemMessageList(null)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:18: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new EarliestFirstSystemMessageList(null)
[warn]   final val ENil: EarliestFirstSystemMessageList = new EarliestFirstSystemMessageList(null)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:21: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   head.eq(null)
[warn]   private[sysmsg] def sizeInner(head: SystemMessage, acc: Int): Int = if (head eq null) acc else sizeInner(head.next, acc + 1)
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:25: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   head.eq(null)
[warn]     if (head eq null) acc else {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:54: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LatestFirstSystemMessageList.this.head.eq(null)
[warn]   final def isEmpty: Boolean = head eq null
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:59: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LatestFirstSystemMessageList.this.head.ne(null)
[warn]   final def nonEmpty: Boolean = head ne null
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:115: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EarliestFirstSystemMessageList.this.head.eq(null)
[warn]   final def isEmpty: Boolean = head eq null
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:120: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EarliestFirstSystemMessageList.this.head.ne(null)
[warn]   final def nonEmpty: Boolean = head ne null
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:194: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SystemMessage.this.next.eq(null)
[warn]   def unlinked: Boolean = next eq null
[warn]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:54: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def isEmpty: Boolean = head eq null
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:59: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def nonEmpty: Boolean = head ne null
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:64: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def size: Int = sizeInner(head, 0)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:73: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tail: LatestFirstSystemMessageList = new LatestFirstSystemMessageList(head.next)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:81: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def reverse: EarliestFirstSystemMessageList = new EarliestFirstSystemMessageList(reverseInner(head, null))
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:86: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def ::(msg: SystemMessage): LatestFirstSystemMessageList = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:115: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def isEmpty: Boolean = head eq null
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:120: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def nonEmpty: Boolean = head ne null
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:125: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def size: Int = sizeInner(head, 0)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:134: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tail: EarliestFirstSystemMessageList = new EarliestFirstSystemMessageList(head.next)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:142: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def reverse: LatestFirstSystemMessageList = new LatestFirstSystemMessageList(reverseInner(head, null))
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:147: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def ::(msg: SystemMessage): EarliestFirstSystemMessageList = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\dispatch\sysmsg\SystemMessage.scala:160: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def reverse_:::(other: LatestFirstSystemMessageList): EarliestFirstSystemMessageList = {
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\ActorClassificationUnsubscriber.scala:69: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     system.asInstanceOf[ExtendedActorSystem]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\ActorClassificationUnsubscriber.scala:68: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val debug: Boolean = system.settings.config.getBoolean("akka.actor.debug.event-stream")
[warn]     val debug = system.settings.config.getBoolean("akka.actor.debug.event-stream")
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\AddressTerminatedTopic.scala:25: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.event.AddressTerminatedTopic = AddressTerminatedTopic.super.get(system)
[info]   override def get(system: ActorSystem): AddressTerminatedTopic = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:436: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   raw.asInstanceOf[scala.collection.immutable.TreeSet[akka.actor.ActorRef]]
[warn]         val v = raw.asInstanceOf[immutable.TreeSet[ActorRef]]
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:454: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   raw.asInstanceOf[scala.collection.immutable.TreeSet[akka.actor.ActorRef]]
[warn]           val v = raw.asInstanceOf[immutable.TreeSet[ActorRef]]
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:467: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   raw.asInstanceOf[scala.collection.immutable.TreeSet[akka.actor.ActorRef]]
[warn]             val monitors = raw.asInstanceOf[immutable.TreeSet[ActorRef]]
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:484: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   raw.asInstanceOf[scala.collection.immutable.TreeSet[akka.actor.ActorRef]]
[warn]         val v = raw.asInstanceOf[immutable.TreeSet[ActorRef]]
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:271: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   ManagedActorClassificationMappings.this.backing.get(monitored).getOrElse[scala.collection.immutable.TreeSet[akka.actor.ActorRef]](ManagedActorClassification.this.empty)
[warn]       val watchers = backing.get(monitored).getOrElse(empty) + monitor
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:276: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   ManagedActorClassificationMappings.this.backing.get(monitored).getOrElse[scala.collection.immutable.TreeSet[akka.actor.ActorRef]](ManagedActorClassification.this.empty)
[warn]       val monitors = backing.get(monitored).getOrElse(empty) - monitor
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:385: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("Subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:386: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   to.eq(null)
[warn]     else if (to eq null) throw new IllegalArgumentException("Classifier is null")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:390: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("Subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:391: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   from.eq(null)
[warn]     else if (from eq null) throw new IllegalArgumentException("Classifier is null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:395: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("Subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:432: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorClassification.this.mappings.putIfAbsent(monitored, ActorClassification.this.empty.+(monitor)).ne(null)
[warn]           if (mappings.putIfAbsent(monitored, empty + monitor) ne null) associate(monitored, monitor)
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:511: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("Subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:512: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   to.eq(null)
[warn]     else if (to eq null) throw new IllegalArgumentException("Classifier is null")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:516: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("Subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:517: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   from.eq(null)
[warn]     else if (from eq null) throw new IllegalArgumentException("Classifier is null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:521: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("Subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventBus.scala:449: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val monitored: akka.actor.ActorRef = _
[warn]     def dissociateAsMonitored(monitored: ActorRef): immutable.Iterable[ActorRef] = {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStream.scala:33: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EventStream.this.<init>(null, debug)
[warn]   def this(debug: Boolean = false) = this(sys = null, debug)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStream.scala:54: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStream.scala:61: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStream.scala:69: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStream.scala:81: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EventStream.this.sys.ne(null)
[warn]     if (sys ne null) EventStreamUnsubscriber.start(sys, this)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStream.scala:89: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EventStream.this.sys.eq(null)
[warn]     if (sys eq null) false
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStream.scala:114: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EventStream.this.sys.ne(null)
[warn]     if (sys ne null) initiallySubscribedOrUnsubscriber.get match {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStream.scala:134: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EventStream.this.sys.ne(null)
[warn]     if (sys ne null) initiallySubscribedOrUnsubscriber.get match {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\EventStreamUnsubscriber.scala:70: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     system.asInstanceOf[ExtendedActorSystem]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\LoggerMailbox.scala:40: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   envelope.ne(null)
[warn]       while (envelope ne null) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\LoggerMailbox.scala:19: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn] private[akka] class LoggerMailboxType(settings: ActorSystem.Settings, config: Config) extends MailboxType
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\LoggerMailbox.scala:19: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn] private[akka] class LoggerMailboxType(settings: ActorSystem.Settings, config: Config) extends MailboxType
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\LoggerMailbox.scala:31: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (owner).
[warn] private[akka] class LoggerMailbox(owner: ActorRef, system: ActorSystem)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\LoggerMailbox.scala:31: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn] private[akka] class LoggerMailbox(owner: ActorRef, system: ActorSystem)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\LoggerMailbox.scala:34: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val owner: akka.actor.ActorRef = _
[warn]   override def cleanUp(owner: ActorRef, deadLetters: MessageQueue): Unit = {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:284: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       a.path.toStringWithAddress(system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress)
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:297: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LogSource.this.fromClass.asInstanceOf[akka.event.LogSource[Class[T]]]
[warn]   implicit def fromAnyClass[T]: LogSource[Class[T]] = fromClass.asInstanceOf[LogSource[Class[T]]]
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:513: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     new BusLogging(system.eventStream, str, clazz, system.asInstanceOf[ExtendedActorSystem].logFilter)
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:541: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   logSource.context.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val system = logSource.context.system.asInstanceOf[ExtendedActorSystem]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:565: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     new BusLogging(system.eventStream, str, clazz, system.asInstanceOf[ExtendedActorSystem].logFilter)
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:597: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   logSource.getContext().system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val system = logSource.getContext().system.asInstanceOf[ExtendedActorSystem]
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1090: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$10.asInstanceOf[AnyRef]
[warn]     case a: Array[_] ? format(t, (a map (_.asInstanceOf[AnyRef]): _*))
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:105: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   val defaultLoggers: scala.collection.immutable.Seq[String] = system.settings.Loggers match {

[warn]     case immutable.this.Nil => {

[warn]       <synthetic> <artifact> val x$2: String = classOf[akka.event.Logging$$DefaultLogger].getName();

[warn]       immutable.this.Nil.::[String](x$2)

[warn]     }

[warn]     case (lo
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1108: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   arg.apply(p)
[warn]           .append(arg(p))
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:667: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Error(cause: Throwable, logSource: String, logClass: Class[_], message: Any = "") extends LogEvent {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:688: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Warning(logSource: String, logClass: Class[_], message: Any = "") extends LogEvent {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:699: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Info(logSource: String, logClass: Class[_], message: Any = "") extends LogEvent {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:710: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Debug(logSource: String, logClass: Class[_], message: Any = "") extends LogEvent {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:610: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   class LogEventException extends Throwable with scala.util.control.NoStackTrace {

[warn]   <paramaccessor> private[this] val event: akka.event.Logging.LogEvent = _;

[warn]   <stable> <accessor> <paramaccessor> def event: akka.event.Logging.LogEvent = LogEventException.this.event;

[warn]   <paramaccessor> private[this] val cause: Throwable = _;

[warn]   def <init>(event: akka.event.Logging.LogEvent, cause: Throwable): akka.event.Logging.LogEventException = {

[warn]     LogEventException.super.<init>();

[warn]     ()

[warn]   };

[warn]   overrid
[warn]   class LogEventException(val event: LogEvent, cause: Throwable) extends NoStackTrace {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:822: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   message.==(null)
[warn]       if (message == null) throw new InvalidMessageException("Message is null")
[warn]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:869: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[String, Nothing]()
[info]   val emptyMDC: MDC = Map()
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:427: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     @inline final def >=(other: LogLevel): Boolean = asInt >= other.asInt
[info]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:428: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     @inline final def <=(other: LogLevel): Boolean = asInt <= other.asInt
[info]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:429: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     @inline final def >(other: LogLevel): Boolean = asInt > other.asInt
[info]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:430: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     @inline final def <(other: LogLevel): Boolean = asInt < other.asInt
[info]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1252: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def isErrorEnabled = false
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1253: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def isWarningEnabled = false
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1254: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def isInfoEnabled = false
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1255: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def isDebugEnabled = false
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1257: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final protected override def notifyError(message: String): Unit = ()
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1258: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final protected override def notifyError(cause: Throwable, message: String): Unit = ()
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1259: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final protected override def notifyWarning(message: String): Unit = ()
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1260: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final protected override def notifyInfo(message: String): Unit = ()
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1261: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final protected override def notifyDebug(message: String): Unit = ()
[info]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:474: [scapegoat] Repeated body of if main and else branch
[warn]   Main and else branches of if are repeated.
[warn]   if (classOf[akka.event.Logging$$Debug].isAssignableFrom(eventClass))

[warn]   Logging.this.DebugLevel

[warn] else

[warn]   Logging.this.DebugLevel
[warn]     else if (classOf[Debug].isAssignableFrom(eventClass)) DebugLevel
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:143: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: Exception)) => {

[warn]   java.this.lang.System.err.println("error while starting up loggers
[warn]       case e: Exception ?
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:121: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.dynamicAccess.getClassFor[akka.actor.Actor](loggerName)((ClassTag.apply[akka.actor.Actor](classOf[akka.actor.Actor]): scala.reflect.ClassTag[akka.actor.Actor])).map[akka.actor.ActorRef](((x0$1: Class[_ <: akka.actor.Actor]) => x0$1 match {

[warn]   case (actorClass @ _) => LoggingBus.this.addLogger(system, actorClass, level, logName)

[warn] })).recover[akka.actor.ActorRef](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothi
[warn]           }).get
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:418: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   private[akka] class LogExt(system: ExtendedActorSystem) extends Extension {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\Logging.scala:1141: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: Settings, eventStream: EventStream) = this(() ? eventStream.logLevel)
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\event\LoggingReceive.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LoggingReceive.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]       val src = source getOrElse context.asInstanceOf[ActorCell].actor
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\DirectByteBufferPool.scala:50: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   buffer.==(null)
[warn]     if (buffer == null)
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Dns.scala:24: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Resolve(name: String) extends Command with ConsistentHashable {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Dns.scala:28: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Resolved(name: String, ipv4: immutable.Seq[Inet4Address], ipv6: immutable.Seq[Inet6Address]) extends Command {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Dns.scala:65: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.io.DnsExt = Dns.super.get(system)
[info]   override def get(system: ActorSystem): DnsExt = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Dns.scala:81: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DnsExt.this.system.dynamicAccess.getClassFor[akka.io.DnsProvider](DnsExt.this.Settings.ProviderObjectName)((ClassTag.apply[akka.io.DnsProvider](classOf[akka.io.DnsProvider]): scala.reflect.ClassTag[akka.io.DnsProvider])).get
[warn]   val provider: DnsProvider = system.dynamicAccess.getClassFor[DnsProvider](Settings.ProviderObjectName).get.newInstance()
[warn]                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:125: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   key.attachment().asInstanceOf[akka.actor.ActorRef]
[warn]                 val connection = key.attachment.asInstanceOf[ActorRef]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:100: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   cause.isInstanceOf[akka.actor.DeathPactException]
[warn]         if (cause.isInstanceOf[DeathPactException]) {
[warn]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:39: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def MaxChannelsPerSelector: Int
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:265: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.getCause().ne(null)
[warn]             case e: ActorInitializationException if e.getCause ne null ?
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:103: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]           } catch { case NonFatal(_) ? }
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:135: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: java.nio.channels.CancelledKeyException) => ()
[warn]                 case _: CancelledKeyException ?
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:164: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: java.nio.channels.ClosedChannelException) => ()
[warn]             case _: ClosedChannelException ?
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:221: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: java.nio.channels.CancelledKeyException) => ()
[warn]           case _: CancelledKeyException ? // ok, can be triggered while setting interest ops
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SelectionHandler.scala:274: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]         } catch { case NonFatal(_) ? }
[warn]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SimpleDnsCache.scala:80: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class CacheEntry(answer: Dns.Resolved, until: Long) {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SimpleDnsCache.scala:18: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.collection.immutable.Map.apply[String, Nothing]()
[info]     immutable.Map(), clock))
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\SimpleDnsCache.scala:70: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   q.head
[warn]         val minEntry = q.head
[warn]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Tcp.scala:256: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]     def ++:(writes: Iterable[WriteCommand]): WriteCommand =
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Tcp.scala:233: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NoAck(token: Any) extends Event
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Tcp.scala:303: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SimpleWriteCommand.this.ack.isInstanceOf[akka.io.Tcp.NoAck]
[warn]     def wantsAck: Boolean = !ack.isInstanceOf[NoAck]
[warn]                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Tcp.scala:42: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.io.TcpExt = Tcp.super.get(system)
[info]   override def get(system: ActorSystem): TcpExt = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Tcp.scala:372: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]             case x: SimpleWriteCommand ? { current = null; x }
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Tcp.scala:239: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   NoAck.super.<init>(null)
[warn]   object NoAck extends NoAck(null)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Tcp.scala:367: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.current.ne(null)
[warn]         def hasNext: Boolean = current ne null
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:203: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TcpConnection.this.channel.socket().getRemoteSocketAddress().asInstanceOf[java.net.InetSocketAddress]
[warn]       channel.socket.getRemoteSocketAddress.asInstanceOf[InetSocketAddress],
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:204: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TcpConnection.this.channel.socket().getLocalSocketAddress().asInstanceOf[java.net.InetSocketAddress]
[warn]       channel.socket.getLocalSocketAddress.asInstanceOf[InetSocketAddress])
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:411: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PendingBufferWrite.this.ack.isInstanceOf[akka.io.Tcp.NoAck]
[warn]           if (!ack.isInstanceOf[NoAck]) commander ! ack
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:455: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PendingWriteFile.this.ack.isInstanceOf[akka.io.Tcp.NoAck]
[warn]           val andThen = if (!ack.isInstanceOf[NoAck]) () ? commander ! ack else doNothing
[warn]                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:361: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def PendingWrite(commander: ActorRef, write: WriteCommand): PendingWrite = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:375: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def PendingBufferWrite(commander: ActorRef, data: ByteString, ack: Event, tail: WriteCommand): PendingBufferWrite = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:426: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def PendingWriteFile(commander: ActorRef, filePath: String, offset: Long, count: Long, ack: Event,
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:319: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.==(null)
[warn]     if (t == null) "unknown"
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:349: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TcpConnection.this.closedMessage.!=(null)
[warn]     if (closedMessage != null) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpConnection.scala:143: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   TcpConnection.this.interestedInResume.get
[warn]           interestedInResume.get ! WritingResumed
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpListener.scala:79: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TcpListener.this.channel.socket().getLocalSocketAddress().asInstanceOf[java.net.InetSocketAddress]
[warn]       bindCommander ! Bound(channel.socket.getLocalSocketAddress.asInstanceOf[InetSocketAddress])
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpListener.scala:117: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   socketChannel.!=(null)
[warn]     if (socketChannel != null) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\TcpOutgoingConnection.scala:27: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   java.nio.channels.SocketChannel.open().configureBlocking(false).asInstanceOf[java.nio.channels.SocketChannel]
[warn]   extends TcpConnection(_tcp, SocketChannel.open().configureBlocking(false).asInstanceOf[SocketChannel], connect.pullMode) {
[warn]                                                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Udp.scala:56: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NoAck(token: Any) extends Event
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Udp.scala:117: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class SimpleSender(options: immutable.Traversable[SocketOption] = Nil) extends Command
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Udp.scala:83: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Send.this.ack.isInstanceOf[akka.io.Udp.NoAck]
[warn]     def wantsAck: Boolean = !ack.isInstanceOf[NoAck]
[warn]                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Udp.scala:36: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.io.UdpExt = Udp.super.get(system)
[info]   override def get(system: ActorSystem): UdpExt = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\Udp.scala:62: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   NoAck.super.<init>(null)
[warn]   object NoAck extends NoAck(null)
[warn]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnected.scala:55: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NoAck(token: Any) extends Event
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnected.scala:75: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Send.this.ack.isInstanceOf[akka.io.UdpConnected.NoAck]
[warn]     def wantsAck: Boolean = !ack.isInstanceOf[NoAck]
[warn]                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnected.scala:35: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.io.UdpConnectedExt = UdpConnected.super.get(system)
[info]   override def get(system: ActorSystem): UdpConnectedExt = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnected.scala:61: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   NoAck.super.<init>(null)
[warn]   object NoAck extends NoAck(null)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnection.scala:32: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var pendingSend: (Send, ActorRef) = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnection.scala:36: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var channel: DatagramChannel = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnection.scala:139: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       pendingSend = null
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnection.scala:33: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   UdpConnection.this.pendingSend.ne(null)
[warn]   def writePending = pendingSend ne null
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnection.scala:56: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val address: java.net.InetSocketAddress = _).
[warn]   def doConnect(address: InetSocketAddress): Unit = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpConnection.scala:127: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val commander: akka.actor.ActorRef = x$2._2
[warn]       val (send, commander) = pendingSend
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\UdpListener.scala:66: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   UdpListener.this.channel.socket().getLocalSocketAddress().asInstanceOf[java.net.InetSocketAddress]
[warn]       bindCommander ! Bound(channel.socket.getLocalSocketAddress.asInstanceOf[InetSocketAddress])
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:20: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var pendingSend: Send = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:21: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var pendingCommander: ActorRef = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:58: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                 pendingSend = null
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:59: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                 pendingCommander = null
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:84: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           pendingSend = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:85: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           pendingCommander = null
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:93: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         pendingSend = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:94: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         pendingCommander = null
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\io\WithUdpSend.scala:25: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   WithUdpSend.this.pendingSend.ne(null)
[warn]   private def hasWritePending = pendingSend ne null
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\JavaAPI.scala:162: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Option.this.None.asInstanceOf[akka.japi.Option[A]]
[warn]   def none[A] = None.asInstanceOf[Option[A]]
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\JavaAPI.scala:229: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   imm.asInstanceOf[scala.collection.immutable.Seq[T]]
[warn]       case imm: immutable.Seq[_] ? imm.asInstanceOf[immutable.Seq[T]]
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\JavaAPI.scala:259: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]     scala.Option(jOption.orElse(null.asInstanceOf[T]))
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\JavaAPI.scala:168: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   v.==(null)
[warn]   def option[A](v: A): Option[A] = if (v == null) none else some(v)
[warn]                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\JavaAPI.scala:63: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class Pair[A, B](first: A, second: B) {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\JavaAPI.scala:200: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   o.get
[warn]   implicit def scala2JavaOption[A](o: scala.Option[A]): Option[A] = if (o.isDefined) some(o.get) else none
[warn]                                                                                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\JavaAPI.scala:85: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def noMatch(): RuntimeException = NoMatch
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\pf\CaseStatements.scala:18: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[P]
[warn]   override def apply(o: F) = apply.apply(o.asInstanceOf[P])
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\japi\pf\CaseStatements.scala:26: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[P]
[warn]   override def apply(o: F) = apply.apply(o.asInstanceOf[P])
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:336: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sender.asInstanceOf[akka.actor.InternalActorRef]
[warn]       val message = messageFactory(sender.asInstanceOf[InternalActorRef].provider.deadLetters)
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:425: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sender.asInstanceOf[akka.actor.InternalActorRef]
[warn]       val message = messageFactory(sender.asInstanceOf[InternalActorRef].provider.deadLetters)
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:466: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractPromiseActorRef.watchedByOffset).asInstanceOf[Set[akka.actor.ActorRef]]
[warn]   private[this] def watchedBy: Set[ActorRef] = Unsafe.instance.getObjectVolatile(this, watchedByOffset).asInstanceOf[Set[ActorRef]]
[warn]                                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:571: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   watcher.asInstanceOf[akka.actor.InternalActorRef]
[warn]           watcher.asInstanceOf[InternalActorRef]
[warn]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:250: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private[pattern] def ask$extension(actorRef: ActorRef, message: Any, timeout: Timeout): Future[Any] =
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:256: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private[pattern] def $qmark$extension(actorRef: ActorRef, message: Any, timeout: Timeout): Future[Any] =
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:345: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private[pattern] def ask$extension(actorSel: ActorSelection, message: Any, timeout: Timeout): Future[Any] =
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:351: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private[pattern] def $qmark$extension(actorSel: ActorSelection, message: Any, timeout: Timeout): Future[Any] =
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:568: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   watchers.isEmpty.unary_!
[info]       if (!watchers.isEmpty) {
[info]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:514: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         var p: ActorPath = null
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:333: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   sender.eq(null)
[warn]     case _ if sender eq null ?
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:422: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   sender.eq(null)
[warn]     case _ if sender eq null ?
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:487: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   PromiseActorRef.this.updateWatchedBy(other, null)
[warn]     case other ? if (!updateWatchedBy(other, null)) clearWatchers() else other
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:513: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   PromiseActorRef.this.updateState(null, PromiseActorRef.Registering)
[warn]       if (updateState(null, Registering)) {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:533: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   message.==(null)
[warn]       if (message == null) throw new InvalidMessageException("Message is null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:578: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   PromiseActorRef.this.updateState(null, PromiseActorRef.Stopped)
[warn]         if (updateState(null, Stopped)) ensureCompleted() else stop()
[warn]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:473: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   private[this] final def addWatcher(watcher: ActorRef): Boolean = watchedBy match {
[info]                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:479: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   private[this] final def remWatcher(watcher: ActorRef): Unit = watchedBy match {
[info]                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\AskSupport.scala:485: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   private[this] final def clearWatchers(): Set[ActorRef] = watchedBy match {
[info]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\BackoffOptions.scala:199: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val supervisorStrategy: akka.actor.OneForOneStrategy = _
[warn]   def withSupervisorStrategy(supervisorStrategy: OneForOneStrategy) = copy(supervisorStrategy = supervisorStrategy)
[warn]                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\BackoffSupervisor.scala:139: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[akka] case class ResetRestartCount(current: Int) extends DeadLetterSuppression
[info]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\BackoffSupervisor.scala:246: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: akka.actor.Cancellable = HandleBackoff.this.context.system.scheduler.scheduleOnce(resetBackoff, HandleBackoff.this.self, BackoffSupervisor.ResetRestartCount.apply(HandleBackoff.this.restartCoun
[warn]           val _ = context.system.scheduler.scheduleOnce(resetBackoff, self, ResetRestartCount(restartCount))
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:137: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractCircuitBreaker.stateOffset).asInstanceOf[CircuitBreaker.this.State]
[warn]     Unsafe.instance.getObjectVolatile(this, AbstractCircuitBreaker.stateOffset).asInstanceOf[State]
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:151: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractCircuitBreaker.resetTimeoutOffset).asInstanceOf[scala.concurrent.duration.FiniteDuration]
[warn]     Unsafe.instance.getObjectVolatile(this, AbstractCircuitBreaker.resetTimeoutOffset).asInstanceOf[FiniteDuration]
[warn]                                                                                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:462: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def _enter(): Unit
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:498: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     override def _enter(): Unit = {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:545: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     override def _enter(): Unit = set(true)
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:601: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     override def _enter(): Unit = {
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:265: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = callback
[warn]   def onOpen(callback: ? Unit): CircuitBreaker = onOpen(new Runnable { def run = callback })
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:285: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = callback
[warn]   def onHalfOpen(callback: ? Unit): CircuitBreaker = onHalfOpen(new Runnable { def run = callback })
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:306: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = callback
[warn]   def onClose(callback: ? Unit): CircuitBreaker = onClose(new Runnable { def run = callback })
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\CircuitBreaker.scala:103: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxResetTimeout: scala.concurrent.duration.FiniteDuration = _
[warn]   def withExponentialBackoff(maxResetTimeout: FiniteDuration): CircuitBreaker = {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\FutureTimeoutSupport.scala:43: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   t.!=(null)
[warn]               if (t != null) p.complete(t)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\GracefulStopSupport.scala:47: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   target.asInstanceOf[akka.actor.InternalActorRef]
[warn]     val internalTarget = target.asInstanceOf[InternalActorRef]
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:50: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.ask(actor, message)(timeout).asInstanceOf[scala.concurrent.Future[AnyRef]]
[warn]   def ask(actor: ActorRef, message: Any, timeout: Timeout): Future[AnyRef] = scalaAsk(actor, message)(timeout).asInstanceOf[Future[AnyRef]]
[warn]                                                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:67: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.ask(actor, {

[warn]   ((param: akka.actor.ActorRef) => messageFactory.apply(param))

[warn] })(timeout).asInstanceOf[scala.concurrent.Future[AnyRef]]
[warn]   def ask(actor: ActorRef, messageFactory: japi.Function[ActorRef, Any], timeout: Timeout): Future[AnyRef] = scalaAsk(actor, messageFactory.apply _)(timeout).asInstanceOf[Future[AnyRef]]
[warn]                                                                                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:99: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.ask(actor, message)(new akka.util.Timeout(timeoutMillis, MILLISECONDS)).asInstanceOf[scala.concurrent.Future[AnyRef]]
[warn]     scalaAsk(actor, message)(new Timeout(timeoutMillis, TimeUnit.MILLISECONDS)).asInstanceOf[Future[AnyRef]]
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:116: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.ask(actor, {

[warn]   ((param: akka.actor.ActorRef) => messageFactory.apply(param))

[warn] })(akka.util.Timeout.apply(scala.concurrent.duration.`package`.DurationLong(timeoutMillis).millis)).asInstanceOf[scala.concurrent.Future[AnyRef]]
[warn]   def ask(actor: ActorRef, messageFactory: japi.Function[ActorRef, Any], timeoutMillis: Long): Future[AnyRef] = scalaAsk(actor, messageFactory.apply _)(Timeout(timeoutMillis.millis)).asInstanceOf[Future[AnyRef]]
[warn]                                                                                                                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:148: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.ask(selection, message)(timeout).asInstanceOf[scala.concurrent.Future[AnyRef]]
[warn]     scalaAsk(selection, message)(timeout).asInstanceOf[Future[AnyRef]]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:180: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.ask(selection, message)(new akka.util.Timeout(timeoutMillis, MILLISECONDS)).asInstanceOf[scala.concurrent.Future[AnyRef]]
[warn]     scalaAsk(selection, message)(new Timeout(timeoutMillis, TimeUnit.MILLISECONDS)).asInstanceOf[Future[AnyRef]]
[warn]                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:197: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.ask(selection, {

[warn]   ((param: akka.actor.ActorRef) => messageFactory.apply(param))

[warn] })(akka.util.Timeout.apply(scala.concurrent.duration.`package`.DurationLong(timeoutMillis).millis)).asInstanceOf[scala.concurrent.Future[AnyRef]]
[warn]   def ask(selection: ActorSelection, messageFactory: japi.Function[ActorRef, Any], timeoutMillis: Long): Future[AnyRef] = scalaAsk(selection, messageFactory.apply _)(Timeout(timeoutMillis.millis)).asInstanceOf[Future[AnyRef]]
[warn]                                                                                                                                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:229: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.gracefulStop(target, timeout, akka.pattern.`package`.gracefulStop$default$3).asInstanceOf[scala.concurrent.Future[Boolean]]
[warn]     scalaGracefulStop(target, timeout).asInstanceOf[Future[java.lang.Boolean]]
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:245: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.pattern.`package`.gracefulStop(target, timeout, stopMessage).asInstanceOf[scala.concurrent.Future[Boolean]]
[warn]     scalaGracefulStop(target, timeout, stopMessage).asInstanceOf[Future[java.lang.Boolean]]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:299: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Any](akka.pattern.`package`.ask(actor, message)(timeout)).toJava.asInstanceOf[java.util.concurrent.CompletionStage[AnyRef]]
[warn]     scalaAsk(actor, message)(timeout).toJava.asInstanceOf[CompletionStage[AnyRef]]
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:317: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Any](akka.pattern.`package`.ask(actor, {

[warn]   ((param: akka.actor.ActorRef) => messageFactory.apply(param))

[warn] })(timeout)).toJava.asInstanceOf[java.util.concurrent.CompletionStage[AnyRef]]
[warn]     scalaAsk(actor, messageFactory.apply _)(timeout).toJava.asInstanceOf[CompletionStage[AnyRef]]
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:349: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Any](akka.pattern.`package`.ask(actor, message)(new akka.util.Timeout(timeoutMillis, MILLISECONDS))).toJava.asInstanceOf[java.util.concurrent.CompletionStage[AnyRef]]
[warn]     scalaAsk(actor, message)(new Timeout(timeoutMillis, TimeUnit.MILLISECONDS)).toJava.asInstanceOf[CompletionStage[AnyRef]]
[warn]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:367: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Any](akka.pattern.`package`.ask(actor, {

[warn]   ((param: akka.actor.ActorRef) => messageFactory.apply(param))

[warn] })(akka.util.Timeout.apply(scala.concurrent.duration.`package`.DurationLong(timeoutMillis).millis))).toJava.asInstanceOf[java.util.concurrent.CompletionStage[AnyRef]]
[warn]     scalaAsk(actor, messageFactory.apply _)(Timeout(timeoutMillis.millis)).toJava.asInstanceOf[CompletionStage[AnyRef]]
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:399: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Any](akka.pattern.`package`.ask(selection, message)(timeout)).toJava.asInstanceOf[java.util.concurrent.CompletionStage[AnyRef]]
[warn]     scalaAsk(selection, message)(timeout).toJava.asInstanceOf[CompletionStage[AnyRef]]
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:431: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Any](akka.pattern.`package`.ask(selection, message)(new akka.util.Timeout(timeoutMillis, MILLISECONDS))).toJava.asInstanceOf[java.util.concurrent.CompletionStage[AnyRef]]
[warn]     scalaAsk(selection, message)(new Timeout(timeoutMillis, TimeUnit.MILLISECONDS)).toJava.asInstanceOf[CompletionStage[AnyRef]]
[warn]                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:449: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Any](akka.pattern.`package`.ask(selection, {

[warn]   ((param: akka.actor.ActorRef) => messageFactory.apply(param))

[warn] })(akka.util.Timeout.apply(scala.concurrent.duration.`package`.DurationLong(timeoutMillis).millis))).toJava.asInstanceOf[java.util.concurrent.CompletionStage[AnyRef]]
[warn]     scalaAsk(selection, messageFactory.apply _)(Timeout(timeoutMillis.millis)).toJava.asInstanceOf[CompletionStage[AnyRef]]
[warn]                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:481: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Boolean](akka.pattern.`package`.gracefulStop(target, timeout, akka.pattern.`package`.gracefulStop$default$3)).toJava.asInstanceOf[java.util.concurrent.CompletionStage[Boolean]]
[warn]     scalaGracefulStop(target, timeout).toJava.asInstanceOf[CompletionStage[java.lang.Boolean]]
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\Patterns.scala:497: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.FutureOps[Boolean](akka.pattern.`package`.gracefulStop(target, timeout, stopMessage)).toJava.asInstanceOf[java.util.concurrent.CompletionStage[Boolean]]
[warn]     scalaGracefulStop(target, timeout, stopMessage).toJava.asInstanceOf[CompletionStage[java.lang.Boolean]]
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\PipeToSupport.scala:45: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   t.!=(null)
[warn]           if (t != null) recipient ! t
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\PipeToSupport.scala:53: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   t.!=(null)
[warn]           if (t != null) recipient ! t
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\pattern\PromiseRef.scala:74: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val provider = system.asInstanceOf[ExtendedActorSystem].provider
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Balancing.scala:31: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   routees.head
[warn]     else routees.head
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Broadcast.scala:89: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val resizer: akka.routing.Resizer = _
[warn]   def withResizer(resizer: Resizer): BroadcastPool = copy(resizer = Some(resizer))
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHash.scala:90: [scapegoat] Array passed to String.format
[warn]   An Array passed to String.format might result in an incorrect formatting.
[warn]   scala.this.Predef.augmentString("Can\'t get node for [%s] from an empty node ring").format(key)
[warn]     if (isEmpty) throw new IllegalStateException("Can't get node for [%s] from an empty node ring" format key)
[warn]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHash.scala:130: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   classOf[scala.Any].asInstanceOf[Class[T]]
[warn]     apply(nodes.asScala, virtualNodesFactor)(ClassTag(classOf[Any].asInstanceOf[Class[T]]))
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHashing.scala:94: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mapper.hashKey(message).asInstanceOf[AnyRef]
[warn]     case message if mapper.hashKey(message).asInstanceOf[AnyRef] ne null ?
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHashing.scala:105: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHashing.scala:94: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   mapper.hashKey(message).asInstanceOf[AnyRef].ne(null)
[warn]     case message if mapper.hashKey(message).asInstanceOf[AnyRef] ne null ?
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHashing.scala:159: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   a.==(null)
[warn]     if (a == null)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHashing.scala:210: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.serialization.SerializationExtension.apply(ConsistentHashingRoutingLogic.this.system).serialize(x).get
[warn]           case x: AnyRef          ? currentConsistenHash.nodeFor(SerializationExtension(system).serialize(x).get).routee
[warn]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHashing.scala:172: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val vnodes: Int = _
[warn]   def withVirtualNodesFactor(vnodes: Int): ConsistentHashingRoutingLogic = copy(virtualNodesFactor = vnodes)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ConsistentHashing.scala:304: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val resizer: akka.routing.Resizer = _
[warn]   def withResizer(resizer: Resizer): ConsistentHashingPool = copy(resizer = Some(resizer))
[warn]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\OptimalSizeExploringResizer.scala:40: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[routing] case class UnderUtilizationStreak(start: LocalDateTime, highestUtilization: Int)
[info]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\OptimalSizeExploringResizer.scala:45: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[routing] case class ResizeRecord(
[info]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\OptimalSizeExploringResizer.scala:117: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class DefaultOptimalSizeExploringResizer(
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\OptimalSizeExploringResizer.scala:235: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DefaultOptimalSizeExploringResizer.this.record.underutilizationStreak.get
[warn]         val downsizeTo = (record.underutilizationStreak.get.highestUtilization * downsizeRatio).toInt
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\OptimalSizeExploringResizer.scala:149: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val lowerBound: Double = _
[warn]   private def checkParamLowerBound(value: Double, lowerBound: Double, paramName: String): Unit =
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Random.scala:90: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val resizer: akka.routing.Resizer = _
[warn]   def withResizer(resizer: Resizer): RandomPool = copy(resizer = Some(resizer))
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Resizer.scala:66: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("cannot enable both resizer and optimal-size-exploring-resizer").s()
[warn]         throw new ResizerInitializationException(s"cannot enable both resizer and optimal-size-exploring-resizer", null)
[warn]                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Resizer.scala:128: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class DefaultResizer(
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Resizer.scala:66: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new ResizerInitializationException(scala.StringContext.apply("cannot enable both resizer and optimal-size-exploring-resizer").s(), null)
[warn]         throw new ResizerInitializationException(s"cannot enable both resizer and optimal-size-exploring-resizer", null)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Resizer.scala:259: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ResizablePoolCell.this.pool.resizer.get
[warn]   val resizer = pool.resizer.get
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RoundRobin.scala:29: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RoundRobinRoutingLogic.this.next.getAndIncrement().%(size).asInstanceOf[Int]
[warn]       val index = (next.getAndIncrement % size).asInstanceOf[Int]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RoundRobin.scala:98: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val resizer: akka.routing.Resizer = _
[warn]   def withResizer(resizer: Resizer): RoundRobinPool = copy(resizer = Some(resizer))
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RoutedActorCell.scala:49: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var _router: Router = null // initialized in start, and then only updated from the actor
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RoutedActorCell.scala:115: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   deprecatedPaths.==(null)
[warn]         val paths = if (deprecatedPaths == null) group.paths(system) else deprecatedPaths
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RoutedActorRef.scala:35: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RoutedActorRef.this._routerDispatcher.isInstanceOf[akka.dispatch.BalancingDispatcher]
[warn]   if (_routerProps.routerConfig != NoRouter && _routerDispatcher.isInstanceOf[BalancingDispatcher]) {
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Router.scala:121: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sender.asInstanceOf[akka.actor.InternalActorRef]
[warn]       sender.asInstanceOf[InternalActorRef].provider.deadLetters.tell(unwrap(msg), sender)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\Router.scala:120: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sender.isInstanceOf[akka.actor.InternalActorRef]
[warn]     if (routee == NoRoutee && sender.isInstanceOf[InternalActorRef])
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:111: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.withSupervisorStrategy(p.supervisorStrategy).asInstanceOf[akka.routing.PoolOverrideUnsetConfig[T]]
[warn]               this.withSupervisorStrategy(p.supervisorStrategy).asInstanceOf[PoolOverrideUnsetConfig[T]]
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:137: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   tmp.!=(null)
[warn]     if (tmp != null) immutableSeq(tmp)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   p.resizer.get
[warn]             wssConf.withResizer(p.resizer.get)
[warn]                                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:285: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @inline final def apply(
[info]                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:291: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @inline final def unapply(fc: FromConfig): Option[String] = Some(fc.routerDispatcher)
[info]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\RouterConfig.scala:331: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val resizer: akka.routing.Resizer = _
[warn]   def withResizer(resizer: Resizer): FromConfig =
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ScatterGatherFirstCompleted.scala:44: [scapegoat] Repeated body of if main and else branch
[warn]   Main and else branches start with the same command.
[warn]   if (ScatterGatherFirstCompletedRoutees.this.routees.isEmpty)

[warn]   {

[warn]     implicit val ec: akka.dispatch.ExecutionContexts.sameThreadExecutionContext.type = akka.dispatch.ExecutionContexts.sameThreadExecutionContext;

[warn]     val reply: scala.concurrent.Future[Nothing] = scala.concurrent.Future.failed[Nothing](new java.util.concurrent.TimeoutException("Timeout due to no routees"));

[warn]     {

[warn]       {

[warn]         <artifact> val qual$1: akka.pattern.PipeableFuture[Nothing] = akka.pattern.`package`.pipe[Nothing
[warn]     if (routees.isEmpty) {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\ScatterGatherFirstCompleted.scala:133: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val resizer: akka.routing.Resizer = _
[warn]   def withResizer(resizer: Resizer): ScatterGatherFirstCompletedPool = copy(resizer = Some(resizer))
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\SmallestMailbox.scala:206: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val resizer: akka.routing.Resizer = _
[warn]   def withResizer(resizer: Resizer): SmallestMailboxPool = copy(resizer = Some(resizer))
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\routing\TailChopping.scala:184: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val resizer: akka.routing.Resizer = _
[warn]   def withResizer(resizer: Resizer): TailChoppingPool = copy(resizer = Some(resizer))
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:68: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   a.underlying.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       case a: ActorRefWithCell ? a.underlying.system.asInstanceOf[ExtendedActorSystem]
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:118: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   serializer.fromBinary(bytes, clazz).asInstanceOf[T]
[warn]       serializer.fromBinary(bytes, clazz).asInstanceOf[T]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:193: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Serialization.this.serializerFor(clazz).fromBinary(bytes, scala.Some.apply[Class[T]](clazz)).asInstanceOf[T]
[warn]     Try(serializerFor(clazz).fromBinary(bytes, Some(clazz)).asInstanceOf[T])
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:336: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   serializer.isInstanceOf[akka.serialization.JavaSerializer]
[warn]       serializer.isInstanceOf[JavaSerializer] &&
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:172: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserializeByteBuffer(buf: java.nio.ByteBuffer, serializerId: Int, manifest: String): AnyRef = {

[warn]   val serializer: akka.serialization.Serializer = try {

[warn]     Serialization.this.getSerializerById(serializerId)

[warn]   } catch {

[warn]     case (_: java.util.NoSuchElementException) => throw new java.io.NotS
[warn]   def deserializeByteBuffer(buf: ByteBuffer, serializerId: Int, manifest: String): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:34: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new scala.util.DynamicVariable[akka.serialization.Serialization.Information](null)
[warn]   private[akka] val currentTransportInformation = new DynamicVariable[Information](null)
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:202: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   o.eq(null)
[warn]     if (o eq null) NullSerializer else serializerFor(o.getClass)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:257: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Serialization.this.serializerOf(v).get
[warn]     for ((k: String, v: String) ← settings.Serializers) yield k → serializerOf(v).get
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:265: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Serialization.this.system.dynamicAccess.getClassFor[Any](k)((ClassTag.Any: scala.reflect.ClassTag[Any])).get
[warn]       yield (system.dynamicAccess.getClassFor[Any](k).get, serializers(v))).to[immutable.Seq]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serialization.scala:330: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val serializedClass: Class[_] = _
[warn]     def suppressWarningOnNonSerializationVerification(serializedClass: Class[_]) = {
[warn]                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\SerializationExtension.scala:13: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.serialization.Serialization = SerializationExtension.super.get(system)
[info]   override def get(system: ActorSystem): Serialization = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:293: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = {

[warn]   val in: akka.util.ClassLoaderObjectInputStream = new akka.util.ClassLoaderObjectInputStream(JavaSerializer.this.system.dynamicAccess.classLoader, new java.io.ByteArrayInputStream(bytes));

[warn]   val obj: Object = JavaSerializer.c
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:309: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = null
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:333: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = bytes
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = bytes
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:258: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   CurrentSystem.super.<init>(null)
[warn]   final class CurrentSystem extends DynamicVariable[ExtendedActorSystem](null) {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:276: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaSerializer.this.<init>(null)
[warn]   def this() = this(null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:280: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaSerializer.this.system.eq(null)
[warn]     if (system eq null) 1
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:319: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ByteArraySerializer.this.<init>(null)
[warn]   def this() = this(null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:323: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ByteArraySerializer.this.system.eq(null)
[warn]     if (system eq null) 4
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\serialization\Serializer.scala:327: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   o match {

[warn]   case null => null

[warn]   case (o @ (_: Array[Byte])) => o

[warn]   case (other @ _) => throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply("", " only serializes byte arrays
[warn]   def toBinary(o: AnyRef): Array[Byte] = o match {
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:105: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[E]
[warn]           case null if remainingNanos <= 0 ? null.asInstanceOf[E]
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:121: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[E]
[warn]         case null ? null.asInstanceOf[E]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:239: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elements.apply($anon.this.last).asInstanceOf[E]
[warn]           elements(last).asInstanceOf[E]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:37: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.eq(null)
[warn]     if (e eq null) throw new NullPointerException
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:72: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.eq(null)
[warn]     if (e eq null) throw new NullPointerException
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:85: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.eq(null)
[warn]     if (e eq null) throw new NullPointerException
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:130: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.eq(null)
[warn]     if (e eq null) throw new NullPointerException
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:141: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.eq(null)
[warn]     if (e eq null) throw new NullPointerException
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoundedBlockingQueue.scala:174: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   c.eq(null)
[warn]     if (c eq null) throw new NullPointerException
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\BoxedType.scala:20: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def apply(c: Class[_]): Class[_] = if (c.isPrimitive) toBoxed(c) else c
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:208: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]     private[akka] def ++:(that: ByteArrayIterator): this.type = {
[info]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:241: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   MultiByteArrayIterator.this.iterators.isEmpty.unary_!
[info]       while ((rest > 0) && !iterators.isEmpty) {
[info]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:267: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   MultiByteArrayIterator.this.iterators.isEmpty.unary_!
[info]       while (!stop && !iterators.isEmpty) {
[info]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:289: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   MultiByteArrayIterator.this.iterators.isEmpty.unary_!
[info]       while ((rest > 0) && !iterators.isEmpty) {
[info]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:178: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   xs.tail
[warn]         else if (xs.head.isEmpty) norm(xs.tail)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:186: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MultiByteArrayIterator.this.iterators.head
[warn]     @inline private def current: ByteArrayIterator = iterators.head
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:187: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MultiByteArrayIterator.this.iterators.tail
[warn]     @inline private def dropCurrent(): Unit = { iterators = iterators.tail }
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:247: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MultiByteArrayIterator.this.iterators.tail
[warn]         iterators = iterators.tail
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:45: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   that match {

[warn]   case (that @ (_: akka.util.ByteIterator)) => if (that.isEmpty)

[warn]     this

[warn]   else

[warn]     if (this.isEmpty)

[warn]       that

[warn]     else

[warn]       that match {

[warn]         case (that @ (_: akka.util.By
[warn]     final override def ++(that: TraversableOnce[Byte]): ByteIterator = that match {
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:49: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   that match {

[warn]   case (that @ (_: akka.util.ByteIterator.ByteArrayIterator)) => if (this.array.eq(that.array).&&(this.until.==(that.from)))

[warn]     {

[warn]       this.until_=(that.until);

[warn]       that.clear();

[warn]         else that match {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:213: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   that match {

[warn]   case (that @ (_: akka.util.ByteIterator)) => if (that.isEmpty)

[warn]     this

[warn]   else

[warn]     if (this.isEmpty)

[warn]       that

[warn]     else

[warn]       that match {

[warn]         case (that @ (_: akka.util.By
[warn]     final override def ++(that: TraversableOnce[Byte]): ByteIterator = that match {
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:218: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   that match {

[warn]   case (that @ (_: akka.util.ByteIterator.ByteArrayIterator)) => {

[warn]     MultiByteArrayIterator.this.iterators_=(this.iterators.:+[akka.util.ByteIterator.ByteArrayIterator, scala.collecti
[warn]           that match {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:366: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val n: Long = _
[warn]         @tailrec def skipImpl(n: Long, skipped: Long): Long =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteIterator.scala:266: [scapegoat] Var could be val
[warn]   A variable (var) that is never written to could be turned into a value (val).
[warn]   final override def takeWhile(p: Byte => Boolean): MultiByteArrayIterator.this.type = {

[warn]   var stop: Boolean = false;

[warn]   var builder: scala.collection.mutable.ListBuffer[akka.util.ByteIterator.ByteArra
[warn]       var builder = new ListBuffer[ByteArrayIterator]
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:544: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def SerializationIdentity: Byte
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:810: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @inline protected final def fillByteBuffer(len: Int, byteOrder: ByteOrder)(fill: ByteBuffer ? Unit): this.type = {
[info]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:464: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   ByteStrings.this.bytestrings.last
[warn]         val last = bytestrings.last
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:467: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   ByteStrings.this.bytestrings.init
[warn]           val remaining = bytestrings.init
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:507: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   remainingByteStrings.tail
[warn]         val bs = remainingByteStrings.tail
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:1083: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   bytestrings.head
[warn]         bytestrings.head
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:194: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val empty: akka.util.ByteString.ByteString1 = new ByteString.this.ByteString1(scala.Array.empty[Byte]((ClassTag.Byte: scala.reflect.ClassTag[Byte])))
[warn]     val empty: ByteString1 = new ByteString1(Array.empty[Byte])
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:408: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val buffer: java.nio.ByteBuffer = _
[warn]       @tailrec def copyItToTheBuffer(buffer: ByteBuffer, i: Int, written: Int): Int =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\ByteString.scala:860: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   xs match {

[warn]   case (b @ (_: akka.util.ByteString)) if b.isEmpty => ()

[warn]   case (b @ (_: akka.util.ByteString.ByteString1C)) => {

[warn]     ByteStringBuilder.this.clearTemp();

[warn]     ByteStringBuilder.this._bu
[warn]     xs match {
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Collections.scala:44: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[To]
[warn]             _next = null.asInstanceOf[To] // Mark as consumed (nice to the GC, don't leak the last returned value)
[warn]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Collections.scala:31: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]         @tailrec override final def hasNext: Boolean =
[info]                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Collections.scala:41: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]         override final def next(): To =
[info]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\HashCode.scala:45: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value.asInstanceOf[Int]
[warn]   def hash(seed: Int, value: Char): Int = firstTerm(seed) + value.asInstanceOf[Int]
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\HashCode.scala:47: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value.^(value.>>>(32)).asInstanceOf[Int]
[warn]   def hash(seed: Int, value: Long): Int = firstTerm(seed) + (value ^ (value >>> 32)).asInstanceOf[Int]
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\HashCode.scala:39: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   value.eq(null)
[warn]       if (value eq null) result = hash(result, 0)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Index.scala:38: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   set.ne(null)
[warn]       if (set ne null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Index.scala:52: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   oldSet.ne(null)
[warn]         if (oldSet ne null) {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Index.scala:120: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   set.ne(null)
[warn]     if (set ne null) {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Index.scala:139: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   set.ne(null)
[warn]     if (set ne null) {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Index.scala:158: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   set.ne(null)
[warn]       if (set ne null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Index.scala:182: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   set.ne(null)
[warn]       if (set ne null) { set.synchronized { set.clear(); container.remove(e.getKey, emptySet) } }
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:178: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   dis.close()

[warn] } catch {

[warn]   case (ex @ (_: InterruptedException)) => throw ex

[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((ex @ _)) => ()

[warn] }
[warn]       try dis.close() catch {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:162: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB:   fwd(", ") rev(", ") ", "").s(constants.fwd.size, constants.rev.size, constants.fwd.keys.toList.sorted[Int](math.this.Ordering.Int)))

[warn] else

[warn]   ()
[warn]       if (debug) println(s"LNB:   fwd(${constants.fwd.size}) rev(${constants.rev.size}) ${constants.fwd.keys.toList.sorted}")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:189: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB:     resource \'", "\' resolved to stream ", "").s(resource, r))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB:     resource '$resource' resolved to stream $r")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:207: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   ex.printStackTrace()

[warn] else

[warn]   ()
[warn]         if (debug) ex.printStackTrace()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:213: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(({

[warn]     val arg$macro$5: Int = magic;

[warn]     new scala.collection.immutable.StringOps("LNB: magic=0x%08X").format(arg$macro$5)

[warn]   }: String))

[warn] else

[warn]   ()
[warn]     if (debug) println(f"LNB: magic=0x$magic%08X")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:220: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB: version=", ":", "").s(major, minor))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB: version=$major:$minor")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:225: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB: reading ", " constants").s(count))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB: reading $count constants")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:236: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB: class name = ", "").s(c.apply(name)))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB: class name = ${c(name)}")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:243: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB:   implements ", "").s(c.apply(intf)))

[warn] else

[warn]   ()
[warn]       if (debug) println(s"LNB:   implements ${c(intf)}")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:249: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB: reading ", " fields:").s(count))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB: reading $count fields:")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:259: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB:   ", " (", " attributes)").s(c.apply(name), attributes))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB:   ${c(name)} ($attributes attributes)")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:270: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB: reading ", " methods").s(count))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB: reading $count methods")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:293: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB:   ", "").s(c.apply(name)))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB:   ${c(name)}")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:331: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("LNB: reading ", " attributes").s(count))

[warn] else

[warn]   ()
[warn]     if (debug) println(s"LNB: reading $count attributes")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:279: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("LNB:   (skipped)").s()
[warn]       if (debug) println(s"LNB:   (skipped)")
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:350: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("LNB:   (skipped)").s()
[warn]       if (debug) println(s"LNB:   (skipped)")
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:171: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   source.get
[warn]         case None             ? SourceFile(source.get)
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:172: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   source.get
[warn]         case Some((from, to)) ? SourceFileLines(source.get, from, to)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:298: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   filter.get
[warn]         if (tag != codeTag || (filter.isDefined && c(name) != filter.get)) {
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LineNumbers.scala:319: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   lines.max
[warn]                 Some(lines.min → lines.max)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LockUtil.scala:27: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   action

[warn] } catch {

[warn]   case (t @ (_: Throwable)) => {

[warn]     Switch.this.switch.compareAndSet(from.unary_!, from);

[warn]     throw t

[warn]   }

[warn] }
[warn]       try action catch {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\LockUtil.scala:13: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def withGuard[T](body: ? T): T = {
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\OptionVal.scala:21: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new akka.util.OptionVal[Null](null)
[warn]   val None = new OptionVal[Null](null)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\OptionVal.scala:39: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OptionVal.this.x.==(null)
[warn]     x == null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\OptionVal.scala:51: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OptionVal.this.x.==(null)
[warn]     if (x == null) default else x
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\OptionVal.scala:64: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OptionVal.this.x.==(null)
[warn]     if (x == null) throw new NoSuchElementException("OptionVal.None.get")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\OptionVal.scala:68: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OptionVal.this.x.==(null)
[warn]     if (x == null) "None" else s"Some($x)"
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyByteString.scala:14: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   implicit class asPretty(bs: ByteString) {
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyByteString.scala:25: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   bs.toSeq
[warn]       val data = bs.toSeq
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyByteString.scala:24: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val bs: akka.util.ByteString = _
[warn]     def formatLine(bs: ByteString): String = {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyByteString.scala:30: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val bs: akka.util.ByteString = _
[warn]     def formatBytes(bs: ByteString): String =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyByteString.scala:31: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val bs: akka.util.ByteString = _
[warn]       bs.grouped(16).map(formatLine).mkString("\n")
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyDuration.scala:42: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("-∞ (minus infinity)").s()
[warn]         case Duration.MinusInf ? s"-∞ (minus infinity)"
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\PrettyDuration.scala:43: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("∞ (infinity)").s()
[warn]         case Duration.Inf      ? s"∞ (infinity)"
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:33: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m.invoke(null, (scala.Array.apply[AnyRef](i.asInstanceOf[Integer])((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])): _*)).asInstanceOf[Class[_]]
[warn]       Some((i: Int) ? m.invoke(null, Array[AnyRef](i.asInstanceOf[java.lang.Integer]): _*).asInstanceOf[Class[_]])
[warn]                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:65: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   args.asInstanceOf[Seq[AnyRef]]
[warn]     try constructor.newInstance(args.asInstanceOf[Seq[AnyRef]]: _*)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:89: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   clazz.getDeclaredConstructors().asInstanceOf[Array[java.lang.reflect.Constructor[T]]]
[warn]           clazz.getDeclaredConstructors.asInstanceOf[Array[Constructor[T]]].iterator filter { c ?
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:128: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   t.getRawType().asInstanceOf[Class[_]]
[warn]         case Some(t: ParameterizedType) ? if (t.getRawType == marker) t else rec(t.getRawType.asInstanceOf[Class[_]])
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:127: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   c.==(marker)
[warn]         case Some(c: Class[_])          ? if (c == marker) c else rec(c)
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:85: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   scala.util.Try.apply[java.lang.reflect.Constructor[T]](clazz.getDeclaredConstructor()).getOrElse[java.lang.reflect.Constructor[T]](null)
[warn]       if (args.isEmpty) Try { clazz.getDeclaredConstructor() } getOrElse (null)
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:105: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   constructor.==(null)
[warn]     if (constructor == null) error("no matching constructor")
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:110: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   a.==(null)
[warn]     if (a == null) classOf[AnyRef] else a.getClass
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Reflect.scala:139: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @tailrec protected[akka] final def lookupAndSetField(clazz: Class[_], instance: AnyRef, name: String, value: Any): Boolean = {
[info]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:39: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @tailrec private final def addState(newState: Int): Boolean = {
[info]                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:43: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @tailrec private final def remState(oldState: Int) {
[info]                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:53: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def resume(): Unit = remState(Suspended)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:59: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def suspend(): Unit = addState(Suspended)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:61: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def run(): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:74: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def attach(): Unit = if (!isEmpty() && state.compareAndSet(Off, On)) context execute this
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:75: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   override final def execute(task: Runnable): Unit = try add(task) finally attach()
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:76: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   override final def reportFailure(t: Throwable): Unit = context reportFailure t
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:82: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def size(): Int = count()
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SerializedSuspendableExecutionContext.scala:84: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   override final def toString: String = (state.get: @switch) match {
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\StablePriorityQueue.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[E]
[warn]     if (wrappedElement eq null) null.asInstanceOf[E] else wrappedElement.element
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\StablePriorityQueue.scala:40: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[E]
[warn]     if (wrappedElement eq null) null.asInstanceOf[E] else wrappedElement.element
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\StablePriorityQueue.scala:20: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   wrappedElement.eq(null)
[warn]     if (wrappedElement eq null) null.asInstanceOf[E] else wrappedElement.element
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\StablePriorityQueue.scala:26: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.eq(null)
[warn]     if (e eq null) throw new NullPointerException
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\StablePriorityQueue.scala:40: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   wrappedElement.eq(null)
[warn]     if (wrappedElement eq null) null.asInstanceOf[E] else wrappedElement.element
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:59: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SubclassifiedIndex.this.internalEmptyMergeMap.asInstanceOf[Map[K,Set[V]]]
[warn]   private[SubclassifiedIndex] def emptyMergeMap[K, V] = internalEmptyMergeMap.asInstanceOf[Map[K, Set[V]]]
[warn]                                                                                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:60: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[AnyRef, Set[AnyRef]]()
[info]   private[this] val internalEmptyMergeMap = Map[AnyRef, Set[AnyRef]]().withDefaultValue(Set[AnyRef]())
[info]                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:60: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[AnyRef]()
[info]   private[this] val internalEmptyMergeMap = Map[AnyRef, Set[AnyRef]]().withDefaultValue(Set[AnyRef]())
[info]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:207: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSet on a Set.
[warn]   n.values.toSet
[warn]     n.subkeys.map(n ? (n.key, n.values.toSet))
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:26: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val key: K = _
[warn]     override def innerAddValue(key: K, value: V): Changes = {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:40: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val key: K = _
[warn]     override def innerRemoveValue(key: K, value: V): Changes = {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:53: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val key: K = _
[warn]     override def innerFindValues(key: K): Set[V] =
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\SubclassifiedIndex.scala:207: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val n: akka.util.SubclassifiedIndex.Nonroot[K,V] = _
[warn]     n.subkeys.map(n ? (n.key, n.values.toSet))
[warn]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\Timeout.scala:13: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class Timeout(duration: FiniteDuration) {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\TypedMultiMap.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   s.asInstanceOf[Set[K[key.type]]]
[warn]       case Some(s) ? s.asInstanceOf[Set[K[key.type]]]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\TypedMultiMap.scala:105: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TypedMultiMap.this._empty.asInstanceOf[akka.util.TypedMultiMap[T,K]]
[warn]   def empty[T <: AnyRef, K[_ <: T]]: TypedMultiMap[T, K] = _empty.asInstanceOf[TypedMultiMap[T, K]]
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\TypedMultiMap.scala:93: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   TypedMultiMap.this.map.==(o.map)
[warn]     case o: TypedMultiMap[_, _] ? map == o.map
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\TypedMultiMap.scala:33: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type K[_ <: T]
[warn] class TypedMultiMap[T <: AnyRef, K[_ <: T]] private (private val map: Map[T, Set[Any]]) {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\TypedMultiMap.scala:105: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type K[_ <: T]
[warn]   def empty[T <: AnyRef, K[_ <: T]]: TypedMultiMap[T, K] = _empty.asInstanceOf[TypedMultiMap[T, K]]
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\util\WildcardIndex.scala:40: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   WildcardTree.this.empty.asInstanceOf[akka.util.WildcardTree[T]]
[warn]   def apply[T](): WildcardTree[T] = empty.asInstanceOf[WildcardTree[T]]
[warn]                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:94: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:104: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:114: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:124: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:134: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:144: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:154: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:164: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:174: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18, arg19: T19): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:184: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18, arg19: T19, arg20: T20): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:194: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18, arg19: T19, arg20: T20, arg21: T21): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:204: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18, arg19: T19, arg20: T20, arg21: T21, arg22: T22): R
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:314: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:325: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:336: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:347: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:358: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:369: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:380: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:391: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:402: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18, arg19: T19): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:413: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18, arg19: T19, arg20: T20): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:424: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18, arg19: T19, arg20: T20, arg21: T21): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\function\Functions.scala:435: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def apply(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16, arg17: T17, arg18: T18, arg19: T19, arg20: T20, arg21: T21, arg22: T22): Unit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:131: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11) = new Tuple11(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:146: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12) = new Tuple12(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:161: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13) = new Tuple13(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:176: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14) = new Tuple14(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:191: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14, t15: T15) = new Tuple15(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:206: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14, t15: T15, t16: T16) = new Tuple16(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:221: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14, t15: T15, t16: T16, t17: T17) = new Tuple17(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:236: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14, t15: T15, t16: T16, t17: T17, t18: T18) = new Tuple18(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:251: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14, t15: T15, t16: T16, t17: T17, t18: T18, t19: T19) = new Tuple19(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:266: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14, t15: T15, t16: T16, t17: T17, t18: T18, t19: T19, t20: T20) = new Tuple20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:281: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14, t15: T15, t16: T16, t17: T17, t18: T18, t19: T19, t20: T20, t21: T21) = new Tuple21(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\target\src_managed\main\akka\japi\tuple\Tuples.scala:296: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22](t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7, t8: T8, t9: T9, t10: T10, t11: T11, t12: T12, t13: T13, t14: T14, t15: T15, t16: T16, t17: T17, t18: T18, t19: T19, t20: T20, t21: T21, t22: T22) = new Tuple22(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22)
[info]       ^
[info] [warn] [scapegoat] Analysis complete: 148 files - 0 errors 691 warns 197 infos
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:71: method init in trait ActorRefProvider references private[akka] class ActorSystemImpl.
[warn] Classes which cannot access ActorSystemImpl may be unable to provide a concrete implementation of init.
[warn]   def init(system: ActorSystemImpl): Unit
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:91: method registerTempActor in trait ActorRefProvider references private[akka] class InternalActorRef.
[warn] Classes which cannot access InternalActorRef may be unable to provide a concrete implementation of registerTempActor.
[warn]   def registerTempActor(actorRef: InternalActorRef, path: ActorPath): Unit
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor\src\main\scala\akka\actor\ActorRefProvider.scala:107: method actorOf in trait ActorRefProvider references private[akka] class ActorSystemImpl.
[warn] Classes which cannot access ActorSystemImpl may be unable to provide a concrete implementation of actorOf.
[warn]   def actorOf(
[warn]       ^
[warn] there were 13 deprecation warnings; re-run with -deprecation for details
[warn] 669 warnings found
[info] Compiling 45 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-protobuf\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-protobuf\src\main\java\akka\protobuf\AbstractParser.java:113:  catch 子句无法访问
[warn]     } catch (IOException e) {
[warn]       ^
[warn] 已捕获到抛出的类型InvalidProtocolBufferException
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-protobuf\src\main\java\akka\protobuf\AbstractParser.java:150:  catch 子句无法访问
[warn]     } catch (IOException e) {
[warn]       ^
[info] Compiling 26 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\CharPredicate.scala:133: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   chars.apply(ix)
[warn]             if (ix == chars.length) result else rec(ix + 1, result ++ chars(ix))
[warn]                                                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\CharPredicate.scala:145: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class MaskBased private[CharPredicate] (lowMask: Long, highMask: Long) extends CharPredicate {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\CharPredicate.scala:276: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class General private[CharPredicate] (predicate: Char ? Boolean) extends CharPredicate {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\CharPredicate.scala:29: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.isInstanceOf[akka.parboiled2.CharPredicate.MaskBased]
[warn]   def isMaskBased: Boolean = this.isInstanceOf[MaskBased]
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\CharUtils.scala:48: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def lowerHexDigit_internal(i: Int) = (48 + i + (39 & ((9 - i) >> 31))).toChar
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\CharUtils.scala:62: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def upperHexDigit_internal(i: Int) = (48 + i + (7 & ((9 - i) >> 31))).toChar
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\CharUtils.scala:111: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def _numberOfDecimalDigits(long: Long): Int = {
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\DynamicRuleDispatch.scala:63: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   names.asInstanceOf[Array[Object]]
[warn]     java.util.Arrays.sort(names.asInstanceOf[Array[Object]])
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\DynamicRuleDispatch.scala:60: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Invalid `String` argument `x`, only `String` literals are supported!").s()
[warn]         case x                            ? c.abort(x.pos, s"Invalid `String` argument `x`, only `String` literals are supported!")
[warn]                                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\DynamicRuleDispatch.scala:55: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __create[P <: Parser, L <: HList](c: Context)(ruleNames: c.Expr[String]*)(implicit P: c.WeakTypeTag[P], L: c.WeakTypeTag[L]): c.Expr[(DynamicRuleDispatch[P, L], immutable.Seq[String])] = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\DynamicRuleDispatch.scala:51: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val ruleNames: String* = _).
[warn]   def apply[P <: Parser, L <: HList](ruleNames: String*): (DynamicRuleDispatch[P, L], immutable.Seq[String]) = macro __create[P, L]
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ErrorFormatter.scala:145: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   trace.prefix.head
[warn]     else formatNonTerminal(trace.prefix.head, showFrameStartOffset = false)
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ErrorFormatter.scala:197: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val errorIndex: Int = _).
[warn]   def formatTrace(trace: RuleTrace, errorIndex: Int): String = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ErrorFormatter.scala:231: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val showFrameStartOffset: Boolean = showFrameStartOffset
[warn]     showFrameStartOffset: Boolean               = showFrameStartOffset): String = {
[warn]     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ParseError.scala:22: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class ParseError(
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ParseError.scala:49: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class Position(index: Int, line: Int, column: Int)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ParseError.scala:61: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class RuleTrace(prefix: List[RuleTrace.NonTerminal], terminal: RuleTrace.Terminal) {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ParseError.scala:22: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   case class ParseError extends scala.`package`.RuntimeException with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val position: akka.parboiled2.Position = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def position: akka.parboiled2.Position = ParseError.this.position;

[warn]   <caseaccessor> <paramaccessor> private[this] val principalPosition: akka.parboiled2.Position = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def principalPosition: akka.parboile
[warn] case class ParseError(
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ParseError.scala:95: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   traces.tail
[warn]       val tracesTail = traces.tail
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:275: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   saved.asInstanceOf[akka.parboiled2.Parser.ErrorAnalysisPhase]
[warn]   def __exitNotPredicate(saved: AnyRef): Unit = phase = saved.asInstanceOf[ErrorAnalysisPhase]
[warn]                                                                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:507: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   protected class __SubParserInput extends ParserInput {
[info]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:575: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   class Fail extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace {

[warn]   <paramaccessor> private[this] val expected: String = _;

[warn]   <stable> <accessor> <paramaccessor> def expected: String = Fail.this.expected;

[warn]   def <init>(expected: String): akka.parboiled2.Parser.Fail = {

[warn]     Fail.super.<init>();

[warn]     ()

[warn]   }

[warn] }
[warn]   class Fail(val expected: String) extends RuntimeException with NoStackTrace
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:133: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __inErrorAnalysis = phase ne null
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:138: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __run[L <: HList](rule: ? RuleN[L])(implicit scheme: Parser.DeliveryScheme[L]): scheme.Result = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:227: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __advance(): Boolean = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:241: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __updateMaxCursor(): Boolean = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:252: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __saveState: Mark = new Mark((_cursor.toLong << 32) + (_cursorChar.toLong << 16) + valueStack.size)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:257: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __restoreState(mark: Mark): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:266: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __enterNotPredicate(): AnyRef = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:275: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __exitNotPredicate(saved: AnyRef): Unit = phase = saved.asInstanceOf[ErrorAnalysisPhase]
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:280: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __enterAtomic(start: Int): Boolean =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:292: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __exitAtomic(saved: Boolean): Unit =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:303: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __enterQuiet(): Int =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:321: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __exitQuiet(saved: Int): Unit =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:333: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __registerMismatch(): Boolean = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:352: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __bubbleUp(terminal: RuleTrace.Terminal): Nothing = __bubbleUp(Nil, terminal)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:357: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __bubbleUp(prefix: List[RuleTrace.NonTerminal], terminal: RuleTrace.Terminal): Nothing =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:363: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __push(value: Any): Boolean = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:375: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @tailrec final def __matchString(string: String, ix: Int = 0): Boolean =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:386: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @tailrec final def __matchStringWrapped(string: String, ix: Int = 0): Boolean =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:405: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @tailrec final def __matchIgnoreCaseString(string: String, ix: Int = 0): Boolean =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:416: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @tailrec final def __matchIgnoreCaseStringWrapped(string: String, ix: Int = 0): Boolean =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:435: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @tailrec final def __matchAnyOf(string: String, ix: Int = 0): Boolean =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:444: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @tailrec final def __matchNoneOf(string: String, ix: Int = 0): Boolean =
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:452: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __matchMap(m: Map[String, Any]): Boolean = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:468: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __matchMapWrapped(m: Map[String, Any]): Boolean = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:489: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def __hardFail(expected: String) = throw new Parser.Fail(expected)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:527: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     implicit def Try[L <: HList, Out](implicit unpack: Unpack.Aux[L, Out]) =
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:536: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     implicit def Either[L <: HList, Out](implicit unpack: Unpack.Aux[L, Out]) =
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:543: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     implicit def Throw[L <: HList, Out](implicit unpack: Unpack.Aux[L, Out]) =
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:266: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def __enterNotPredicate(): AnyRef = {

[warn]   val saved: akka.parboiled2.Parser.ErrorAnalysisPhase = Parser.this.phase;

[warn]   Parser.this.phase_=(null);

[warn]   saved

[warn] }
[warn]   def __enterNotPredicate(): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:220: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       phase = null
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:268: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     phase = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:127: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Parser.this.phase.ne(null)
[warn]     if (phase ne null) phase.applyOffset(offset)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:133: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Parser.this.phase.ne(null)
[warn]   def __inErrorAnalysis = phase ne null
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:143: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   rule.ne(null)
[warn]       try rule ne null
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Parser.scala:197: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   trace.eq(null)
[warn]         if (trace eq null) done
[warn]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:58: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def ~!~[I2 <: HList, O2 <: HList](that: Rule[I2, O2])(implicit
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:122: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (rule).
[warn]   implicit class Runnable[L <: HList](rule: RuleN[L]) {
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\Rule.scala:123: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val scheme: akka.parboiled2.Parser.DeliveryScheme[L] = _).
[warn]     def run()(implicit scheme: Parser.DeliveryScheme[L]): scheme.Result = macro ParserMacros.runImpl[L]
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLActions.scala:85: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait ActionOperator[I <: HList, O <: HList, Ops] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:125: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait CharRangeSupport {
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:90: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def ANY: Rule0 = `n/a`
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:95: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def EOI: Char = akka.parboiled2.EOI
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:100: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def MATCH: Rule0 = Rule
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:105: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def MISMATCH0: Rule0 = MISMATCH
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLBasics.scala:110: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def MISMATCH[I <: HList, O <: HList]: Rule[I, O] = null
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\RuleDSLCombinators.scala:93: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait NTimes {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:227: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   prependTo.asInstanceOf[L]
[warn]     if (start == end) prependTo.asInstanceOf[L]
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:99: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def pop(): Any = if (ValueStack.this._size.>(0))

[warn]   {

[warn]     val newSize: Int = ValueStack.this._size.-(1);

[warn]     ValueStack.this._size = newSize;

[warn]     ValueStack.this.buffer.apply(newSize)

[warn]   }

[warn] else

[warn]   throw new ValueStackUnderflowException()
[warn]   def pop(): Any =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:112: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def pullOut(down: Int): Any = scala.math.`package`.signum(down) match {

[warn]   case -1 => throw new scala.`package`.IllegalArgumentException("`down` must not be negative")

[warn]   case 0 => ValueStack.this.pop()

[warn]   case 1 => {

[warn]     if (down.>=(ValueStack.this._size))

[warn]       throw new ValueStackUnderflowExcep
[warn]   def pullOut(down: Int): Any =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:130: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def peek: Any = if (ValueStack.this._size.>(0))

[warn]   ValueStack.this.buffer.apply(ValueStack.this._size.-(1))

[warn] else

[warn]   throw new ValueStackUnderflowException()
[warn]   def peek: Any =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\ValueStack.scala:140: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def peek(down: Int): Any = scala.math.`package`.signum(down) match {

[warn]   case -1 => throw new scala.`package`.IllegalArgumentException("`down` must not be negative")

[warn]   case 0 => ValueStack.this.peek

[warn]   case 1 => if (down.>=(ValueStack.this._size))

[warn]     throw new ValueStackUnderflowException()

[warn]   els
[warn]   def peek(down: Int): Any =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:220: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops2[II <: HList, A, B] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:499: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops5[II <: HList, A, B, C, D, E] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1987: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops21[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1429: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops15[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1708: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops18[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:406: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops4[II <: HList, A, B, C, D] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1150: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops12[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:685: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops7[II <: HList, A, B, C, D, E, F, G] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:126: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops1[II <: HList, A] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1057: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops11[II <: HList, A, B, C, D, E, F, G, H, I, J, K] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1894: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops20[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1336: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops14[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:871: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops9[II <: HList, A, B, C, D, E, F, G, H, I] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1615: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops17[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:313: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops3[II <: HList, A, B, C] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:592: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops6[II <: HList, A, B, C, D, E, F] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:32: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops0[II <: HList] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:2080: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops22[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1522: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops16[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1801: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops19[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:27: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait ActionOps[I <: HList, O <: HList] { type Out }
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:964: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops10[II <: HList, A, B, C, D, E, F, G, H, I, J] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:1243: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops13[II <: HList, A, B, C, D, E, F, G, H, I, J, K, L, M] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOps.scala:778: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Ops8[II <: HList, A, B, C, D, E, F, G, H] {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOpsSupport.scala:45: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait Join[I <: HList, L1 <: HList, L2 <: HList, R] {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOpsSupport.scala:31: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait FCapture[T]
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\ActionOpsSupport.scala:52: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Aux[I <: HList, L1 <: HList, L2 <: HList, R, Acc <: HList, In <: HList, Out <: HList]
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\Lifter.scala:24: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait Lifter[M[_], I <: HList, O <: HList] {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:598: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RuleCall.this.call.asInstanceOf[Left[OpTreeContext.this.OpTree,OpTreeContext.this.c.universe.Tree]]
[warn]     def renderInner(wrapped: Boolean) = call.asInstanceOf[Left[OpTree, Tree]].a.render(wrapped)
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:722: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   OpTreeContext.this.expand(x$9, wrapped).asInstanceOf[OpTreeContext.this.c.universe.CaseDef]
[warn]       case Match(selector, cases)     ? Match(selector, cases.map(expand(_, wrapped).asInstanceOf[CaseDef]))
[warn]                                                                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:143: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Sequence(ops: Seq[OpTree]) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:151: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Cut(lhs: OpTree, rhs: OpTree) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:170: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class FirstOf(ops: Seq[OpTree]) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:179: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class CharMatch(charTree: Tree) extends TerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:187: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class StringMatch(stringTree: Tree) extends OpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:224: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class MapMatch(mapTree: Tree) extends OpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:235: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class IgnoreCaseChar(charTree: Tree) extends TerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:243: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class IgnoreCaseString(stringTree: Tree) extends OpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:280: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class CharPredicateMatch(predicateTree: Tree) extends PotentiallyNamedTerminalOpTree(predicateTree) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:288: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class AnyOf(stringTree: Tree) extends TerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:296: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NoneOf(stringTree: Tree) extends TerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:312: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Optional(op: OpTree, collector: Collector) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:330: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ZeroOrMore(op: OpTree, collector: Collector, separator: Separator = null) extends WithSeparator {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:354: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class OneOrMore(op: OpTree, collector: Collector, separator: Separator = null) extends WithSeparator {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:414: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Times(op: OpTree, init: Tree, collector: Collector, separator: Separator) extends WithSeparator {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:441: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class AndPredicate(op: OpTree) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:450: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NotPredicate(op: OpTree) extends OpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:481: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Atomic(op: OpTree) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:492: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Quiet(op: OpTree) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:503: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class SemanticPredicate(flagTree: Tree) extends TerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:509: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Capture(op: OpTree) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:520: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class RunAction(argTree: Tree, rrTree: Tree) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:563: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PushAction(argTree: Tree, hlTree: Tree) extends OpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:573: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class DropAction(hlTree: Tree) extends OpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:589: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class RuleCall(call: Either[OpTree, Tree], calleeNameTree: Tree) extends NonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:614: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class CharacterRange(lowerBound: Char, upperBound: Char) extends TerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:624: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Action(actionTree: Tree, actionTypeTree: Tree) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:659: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class RunSubParser(fTree: Tree) extends DefaultNonTerminalOpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:680: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Fail(stringTree: Tree) extends OpTree {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:684: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Named(op: OpTree, stringTree: Tree) extends DefaultNonTerminalOpTree {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:714: [scapegoat] Looks like interpolated String
[warn]   Did you forget to prefix this string with an s, f or raw to interpolate it?
[warn]   lazy val HListConsTypeSymbol = c.mirror.staticClass("shapeless.$colon$colon")
[warn]                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:132: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def OpTree(tree: Tree): OpTree =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:135: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Sequence(lhs: OpTree, rhs: OpTree): Sequence =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:162: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def FirstOf(lhs: OpTree, rhs: OpTree): FirstOf =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:228: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def IgnoreCase(argTree: Tree): OpTree = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:382: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Times(base: Tree, rule: OpTree, collector: Collector, separator: Separator = null): OpTree = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:601: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def CharRange(lowerTree: Tree, upperTree: Tree): CharacterRange = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:712: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Separator(op: OpTree): Separator = wrapped ? op.render(wrapped)
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:330: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   case class ZeroOrMore(op: OpTree, collector: Collector, separator: Separator = null) extends WithSeparator {
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:354: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   case class OneOrMore(op: OpTree, collector: Collector, separator: Separator = null) extends WithSeparator {
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:382: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def Times(base: Tree, rule: OpTree, collector: Collector, separator: Separator = null): OpTree = {
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:335: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ZeroOrMore.this.separator.eq(null)
[warn]         if (separator eq null) q"rec(__saveState)"
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:359: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OneOrMore.this.separator.eq(null)
[warn]         if (separator eq null) q"rec(__saveState)"
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:420: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Times.this.separator.eq(null)
[warn]         if (separator eq null) q"rec(count + 1, __saveState)"
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:147: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   Sequence.this.ops.map[OpTreeContext.this.c.universe.Tree, Seq[OpTreeContext.this.c.universe.Tree]](((x$2: OpTreeContext.this.OpTree) => x$2.render(wrapped)))(collection.this.Seq.canBuildFrom[OpTreeContext.this.c.universe.Tree]).reduceLeft
[warn]       ops.map(_.render(wrapped)).reduceLeft((l, r) ?
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:649: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   Action.this.actionType.last
[warn]                 case x if isSubClass(actionType.last, "akka.parboiled2.Rule") ? expand(x, wrapped)
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:529: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val tree: OpTreeContext.this.c.universe.Tree = _
[warn]               def rewrite(tree: Tree): Tree =
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\OpTreeContext.scala:646: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val tree: OpTreeContext.this.c.universe.Tree = _
[warn]             def rewrite(tree: Tree): Tree =
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\RunResult.scala:23: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait RunResult[T] {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\RunResult.scala:30: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Aux[T, Out]
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\TailSwitch.scala:32: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait TailSwitch[L <: HList, T <: HList, R <: HList] {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\TailSwitch.scala:47: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait Aux[L <: HList, LI <: HList, T <: HList, TI <: HList, R <: HList, RI <: HList, Out <: HList]
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\Unpack.scala:46: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Unpack.this.HNilUnpack.asInstanceOf[akka.parboiled2.support.Unpack.Aux[L,Unit]]
[warn]   implicit def hnil[L <: HNil]: Aux[L, Unit] = HNilUnpack.asInstanceOf[Aux[L, Unit]]
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\Unpack.scala:51: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Unpack.this.SingleUnpack.asInstanceOf[akka.parboiled2.support.Unpack.Aux[akka.shapeless.::[T,akka.shapeless.HNil],T]]
[warn]   implicit def single[T]: Aux[T :: HNil, T] = SingleUnpack.asInstanceOf[Aux[T :: HNil, T]]
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\Unpack.scala:62: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   AlternativeUnpacks.this.DontUnpack.asInstanceOf[akka.parboiled2.support.Unpack.Aux[L,L]]
[warn]   implicit def dontUnpack[L <: HList]: Unpack.Aux[L, L] = DontUnpack.asInstanceOf[Unpack.Aux[L, L]]
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\Unpack.scala:53: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def apply(hlist: akka.shapeless.::[Any,akka.shapeless.HList]): Any = hlist.head
[warn]     def apply(hlist: Any :: HList): Any = hlist.head
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\parboiled2\support\package.scala:20: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private[parboiled2] def `n/a` = throw new IllegalStateException("Untranslated compile-time only call")
[info]                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-parsing\src\main\scala\akka\shapeless\hlists.scala:31: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class ::[+H, +T <: HList](head: H, tail: T) extends HList {
[info]                  ^
[info] [warn] [scapegoat] Analysis complete: 26 files - 0 errors 80 warns 83 infos
[warn] there were 12 deprecation warnings; re-run with -deprecation for details
[warn] 79 warnings found
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 115 Scala sources and 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:338: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   private def copy(
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:214: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn] class MaterializationException(msg: String, cause: Throwable = null) extends RuntimeException(msg, cause)
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:339: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val initialInputBufferSize: Int = this.initialInputBufferSize
[warn]     initialInputBufferSize:      Int                               = this.initialInputBufferSize,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:340: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxInputBufferSize: Int = this.maxInputBufferSize
[warn]     maxInputBufferSize:          Int                               = this.maxInputBufferSize,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:341: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val dispatcher: String = this.dispatcher
[warn]     dispatcher:                  String                            = this.dispatcher,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:342: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val supervisionDecider: akka.stream.Supervision.Decider = this.supervisionDecider
[warn]     supervisionDecider:          Supervision.Decider               = this.supervisionDecider,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:343: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val subscriptionTimeoutSettings: akka.stream.StreamSubscriptionTimeoutSettings = this.subscriptionTimeoutSettings
[warn]     subscriptionTimeoutSettings: StreamSubscriptionTimeoutSettings = this.subscriptionTimeoutSettings,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:344: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val debugLogging: Boolean = this.debugLogging
[warn]     debugLogging:                Boolean                           = this.debugLogging,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:345: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val outputBurstLimit: Int = this.outputBurstLimit
[warn]     outputBurstLimit:            Int                               = this.outputBurstLimit,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:346: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val fuzzingMode: Boolean = this.fuzzingMode
[warn]     fuzzingMode:                 Boolean                           = this.fuzzingMode,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:347: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val autoFusing: Boolean = this.autoFusing
[warn]     autoFusing:                  Boolean                           = this.autoFusing,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:348: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxFixedBufferSize: Int = this.maxFixedBufferSize
[warn]     maxFixedBufferSize:          Int                               = this.maxFixedBufferSize,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:349: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val syncProcessingLimit: Int = this.syncProcessingLimit
[warn]     syncProcessingLimit:         Int                               = this.syncProcessingLimit) = {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\ActorMaterializer.scala:372: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val dispatcher: String = _
[warn]   def withDispatcher(dispatcher: String): ActorMaterializerSettings = {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:68: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       null.asInstanceOf[T]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:83: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.this.Predef.implicitly[scala.reflect.ClassTag[T]](evidence$1).runtimeClass.asInstanceOf[Class[T]]
[warn]     val c = implicitly[ClassTag[T]].runtimeClass.asInstanceOf[Class[T]]
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:94: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.reflect.`package`.classTag[T](evidence$2).runtimeClass.asInstanceOf[Class[T]]
[warn]     getAttribute(classTag[T].runtimeClass.asInstanceOf[Class[T]], default)
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:101: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.reflect.`package`.classTag[T](evidence$3).runtimeClass.asInstanceOf[Class[T]]
[warn]     getAttribute(classTag[T].runtimeClass.asInstanceOf[Class[T]], default)
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:107: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.reflect.`package`.classTag[T](evidence$4).runtimeClass.asInstanceOf[Class[T]]
[warn]     val c = classTag[T].runtimeClass.asInstanceOf[Class[T]]
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:115: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.reflect.`package`.classTag[T](evidence$5).runtimeClass.asInstanceOf[Class[T]]
[warn]     val c = classTag[T].runtimeClass.asInstanceOf[Class[T]]
[warn]                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:136: [scapegoat] List append is slow
[info]   List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).
[info]     Attributes(attributeList :+ other)
[info]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:153: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   buf.ne(null)
[warn]             if (buf ne null) concatNames(i, null, buf.append('-').append(nn))
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:153: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   concatNames(i, null, buf.append('-').append(nn))
[warn]             if (buf ne null) concatNames(i, null, buf.append('-').append(nn))
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:154: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   first.ne(null)
[warn]             else if (first ne null) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:156: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   concatNames(i, null, b.append(first).append('-').append(nn))
[warn]               concatNames(i, null, b.append(first).append('-').append(nn))
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:157: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   concatNames(i, nn, null)
[warn]             } else concatNames(i, nn, null)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:160: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   buf.eq(null)
[warn]       else if (buf eq null) first
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:163: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   concatNames(Attributes.this.attributeList.iterator, null, null)
[warn]     concatNames(attributeList.iterator, null, null) match {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Attributes.scala:184: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.event.Logging.levelFor("off").get
[warn]     final val Off: Logging.LogLevel = Logging.levelFor("off").get
[warn]                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Fusing.scala:41: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class FusedGraph[+S <: Shape @uncheckedVariance, +M](
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\KillSwitch.scala:41: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   KillSwitches.this.UniqueKillSwitchStage.asInstanceOf[akka.stream.Graph[akka.stream.FlowShape[T,T],akka.stream.UniqueKillSwitch]]
[warn]     UniqueKillSwitchStage.asInstanceOf[Graph[FlowShape[T, T], UniqueKillSwitch]]
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\KillSwitch.scala:50: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   KillSwitches.this.UniqueBidiKillSwitchStage.asInstanceOf[akka.stream.Graph[akka.stream.BidiShape[T1,T1,T2,T2],akka.stream.UniqueKillSwitch]]
[warn]     UniqueBidiKillSwitchStage.asInstanceOf[Graph[BidiShape[T1, T1, T2, T2], UniqueKillSwitch]]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\KillSwitch.scala:238: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SharedKillSwitch.this._flow.asInstanceOf[akka.stream.Graph[akka.stream.FlowShape[T,T],akka.stream.SharedKillSwitch]]
[warn]   def flow[T]: Graph[FlowShape[T, T], SharedKillSwitch] = _flow.asInstanceOf[Graph[FlowShape[T, T], SharedKillSwitch]]
[warn]                                                                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Materializer.scala:79: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class MaterializationContext(
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:19: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   that.asInstanceOf[AnyRef]
[warn]   final override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:38: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   that.asInstanceOf[AnyRef]
[warn]   final override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:78: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[akka.stream.Inlet[U]]
[warn]   def as[U]: Inlet[U] = this.asInstanceOf[Inlet[U]]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:110: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[akka.stream.Outlet[U]]
[warn]   def as[U]: Outlet[U] = this.asInstanceOf[Outlet[U]]
[warn]                                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:228: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class AmorphousShape(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]) extends Shape {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:245: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   outlets.head
[warn]     SourceShape(outlets.head)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:267: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   inlets.head
[warn]     FlowShape(inlets.head, outlets.head)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:267: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   outlets.head
[warn]     FlowShape(inlets.head, outlets.head)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:287: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   inlets.head
[warn]     SinkShape(inlets.head)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:208: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val inlets: scala.collection.immutable.Seq[akka.stream.Inlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:208: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val outlets: scala.collection.immutable.Seq[akka.stream.Outlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:230: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val inlets: scala.collection.immutable.Seq[akka.stream.Inlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = AmorphousShape(inlets, outlets)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:230: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val outlets: scala.collection.immutable.Seq[akka.stream.Outlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = AmorphousShape(inlets, outlets)
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:242: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val inlets: scala.collection.immutable.Seq[akka.stream.Inlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:242: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val outlets: scala.collection.immutable.Seq[akka.stream.Outlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:264: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val inlets: scala.collection.immutable.Seq[akka.stream.Inlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:264: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val outlets: scala.collection.immutable.Seq[akka.stream.Outlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:284: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val inlets: scala.collection.immutable.Seq[akka.stream.Inlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:284: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val outlets: scala.collection.immutable.Seq[akka.stream.Outlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:325: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val inlets: scala.collection.immutable.Seq[akka.stream.Inlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\Shape.scala:325: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val outlets: scala.collection.immutable.Seq[akka.stream.Outlet[_]] = _
[warn]   override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape = {
[warn]                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\SslTlsOptions.scala:191: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NegotiateNewSession(
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:391: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sub.asInstanceOf[org.reactivestreams.Subscriber[Any]]
[warn]     ref ! Subscribe(sub.asInstanceOf[Subscriber[Any]])
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:170: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorPublisher.this.lifecycleState.isInstanceOf[akka.stream.actor.ActorPublisher.Internal.ErrorEmitted]
[warn]   final def isErrorEmitted: Boolean = lifecycleState.isInstanceOf[ErrorEmitted]
[warn]                                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:412: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.stream.actor.ActorPublisherState = ActorPublisherState.super.get(system)
[info]   override def get(system: ActorSystem): ActorPublisherState = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:208: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         try tryOnComplete(subscriber) finally subscriber = null
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:241: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         try tryOnError(subscriber, cause) finally subscriber = null
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:331: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     subscriber = null
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:207: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorPublisher.this.subscriber.ne(null)
[warn]       if (subscriber ne null) // otherwise onComplete will be called when the subscription arrives
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:228: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorPublisher.this.subscriber.ne(null)
[warn]       if (subscriber ne null) // otherwise onComplete will be called when the subscription arrives
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:240: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorPublisher.this.subscriber.ne(null)
[warn]       if (subscriber ne null) // otherwise onError will be called when the subscription arrives
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorPublisher.scala:260: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorPublisher.this.subscriber.ne(null)
[warn]       if (subscriber ne null) // otherwise onError will be called when the subscription arrives
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\actor\ActorSubscriber.scala:311: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.stream.actor.ActorSubscriberState = ActorSubscriberState.super.get(system)
[info]   override def get(system: ActorSystem): ActorSubscriberState = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:61: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.underlying.asInstanceOf[akka.actor.ActorCell]
[warn]           ref.underlying.asInstanceOf[ActorCell].attachChild(props.withDispatcher(dispatcher), name, systemService = false)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:172: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   pub.asInstanceOf[org.reactivestreams.Publisher[Any]]
[warn]             assignPort(source.shape.out, pub.asInstanceOf[Publisher[Any]])
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:178: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   processor.asInstanceOf[org.reactivestreams.Publisher[Any]]
[warn]             assignPort(stage.outPort, processor.asInstanceOf[Publisher[Any]])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:240: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   session.materialize().asInstanceOf[Mat]
[warn]     session.materialize().asInstanceOf[Mat]
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:149: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   StreamLayout.validate(runnableGraph.module, StreamLayout.validate$default$2, StreamLayout.validate$default$3, StreamLayout.validate$default$4)

[warn] else

[warn]   ()
[warn]     if (StreamLayout.Debug) StreamLayout.validate(runnableGraph.module)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:161: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("materializing ", "").s(atomic))

[warn] else

[warn]   ()
[warn]         if (MaterializerSession.Debug) println(s"materializing $atomic")
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:87: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[akka] case class ActorMaterializerImpl(
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:268: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.stream.impl.FlowNames = FlowNames.super.get(system)
[info]   override def get(system: ActorSystem): FlowNames = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:138: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorMaterializerImpl.this.materialize[Mat](_runnableGraph, null)
[warn]     materialize(_runnableGraph, null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorMaterializerImpl.scala:305: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn] class StreamSupervisor(settings: ActorMaterializerSettings, haveShutDown: AtomicBoolean) extends Actor {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:21: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   p.asInstanceOf[akka.stream.impl.ActorPublisher[Any]]
[warn]     impl ! ExposedPublisher(p.asInstanceOf[ActorPublisher[Any]])
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:87: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[AnyRef]
[warn]       inputBuffer((nextInputElementCursor + inputBufferElements) & IndexMask) = elem.asInstanceOf[AnyRef]
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:201: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.isInstanceOf[akka.stream.impl.ReactiveStreamsCompliance.SpecViolation]
[warn]       if ((subscriber ne null) && !e.isInstanceOf[SpecViolation]) tryOnError(subscriber, e)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:70: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BatchingInputBuffer.this.inputBuffer.update(BatchingInputBuffer.this.nextInputElementCursor, null)
[warn]     inputBuffer(nextInputElementCursor) = null
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:96: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BatchingInputBuffer.this.upstream.ne(null)
[warn]       if (upstream ne null) upstream.cancel()
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:103: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   java.util.Arrays.fill(BatchingInputBuffer.this.inputBuffer, 0, BatchingInputBuffer.this.inputBuffer.length, null)
[warn]     java.util.Arrays.fill(inputBuffer, 0, inputBuffer.length, null)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:174: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SimpleOutputs.this.subscriber.ne(null)
[warn]   def isSubscribed = subscriber ne null
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:185: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SimpleOutputs.this.exposedPublisher.ne(null)
[warn]       if (exposedPublisher ne null) exposedPublisher.shutdown(None)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:186: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SimpleOutputs.this.subscriber.ne(null)
[warn]       if (subscriber ne null) tryOnComplete(subscriber)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:193: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SimpleOutputs.this.exposedPublisher.ne(null)
[warn]       if (exposedPublisher ne null) exposedPublisher.shutdown(None)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorProcessor.scala:200: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SimpleOutputs.this.exposedPublisher.ne(null)
[warn]       if (exposedPublisher ne null) exposedPublisher.shutdown(Some(e))
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorPublisher.scala:26: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   a.asInstanceOf[akka.stream.impl.ActorPublisher[Any]]
[warn]     impl ! ExposedPublisher(a.asInstanceOf[ActorPublisher[Any]])
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorPublisher.scala:54: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   current.eq(null)
[warn]       if (current eq null)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorPublisher.scala:69: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   pending.eq(null)
[warn]     if (pending eq null) Nil else pending.reverse
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorPublisher.scala:74: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorPublisher.this.pendingSubscribers.getAndSet(null)
[warn]     pendingSubscribers.getAndSet(null) match {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ActorPublisher.scala:92: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: akka.stream.impl.ReactiveStreamsCompliance.SpecViolation) => ()
[warn]       case _: SpecViolation ? // nothing to do
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:85: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[AnyRef]
[warn]     private def put(idx: Long, elem: T, maintenance: Boolean): Unit = buffer(toOffset(idx, maintenance)) = elem.asInstanceOf[AnyRef]
[warn]                                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:86: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FixedSizeBuffer.this.buffer.apply(FixedSizeBuffer.this.toOffset(idx, false)).asInstanceOf[T]
[warn]     private def get(idx: Long): T = buffer(toOffset(idx, false)).asInstanceOf[T]
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:107: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       put(readIdx, null.asInstanceOf[T], true)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:113: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       put(writeIdx, null.asInstanceOf[T], false)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:180: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[AnyRef]
[warn]         queue(tail & FixedQueueMask) = elem.asInstanceOf[AnyRef]
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:185: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FixedQueue.this.queue.apply(pos).asInstanceOf[T]
[warn]       val ret = queue(pos).asInstanceOf[T]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:192: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       if (tail == head) null.asInstanceOf[T]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:193: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FixedQueue.this.queue.apply(FixedQueue.this.head.&(Buffer.FixedQueueMask)).asInstanceOf[T]
[warn]       else queue(head & FixedQueueMask).asInstanceOf[T]
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:97: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   java.util.Arrays.fill(FixedSizeBuffer.this.buffer, null)
[warn]       java.util.Arrays.fill(buffer, null)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:186: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FixedQueue.this.queue.update(pos, null)
[warn]       queue(pos) = null
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:201: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FixedQueue.this.queue.update(FixedQueue.this.tail.&(Buffer.FixedQueueMask), null)
[warn]       queue(tail & FixedQueueMask) = null
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:205: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (startIdx).
[warn]   private final class DynamicQueue(startIdx: Int) extends ju.LinkedList[T] with Buffer[T] {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Buffers.scala:173: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val queue: BoundedBuffer.this.DynamicQueue = new BoundedBuffer.this.DynamicQueue(FixedQueue.this.head)
[warn]         val queue = new DynamicQueue(head)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\CompletedPublishers.scala:22: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[org.reactivestreams.Publisher[T]]
[warn]   def apply[T]: Publisher[T] = this.asInstanceOf[Publisher[T]]
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\CompletedPublishers.scala:41: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[org.reactivestreams.Publisher[T]]
[warn]   def apply[T]: Publisher[T] = this.asInstanceOf[Publisher[T]]
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\CompletedPublishers.scala:116: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[org.reactivestreams.Publisher[T]]
[warn]   def apply[T]: Publisher[T] = this.asInstanceOf[Publisher[T]]
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\CompletedPublishers.scala:20: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: akka.stream.impl.ReactiveStreamsCompliance.SpecViolation) => ()
[warn]       case _: SpecViolation ? // nothing we can do
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\CompletedPublishers.scala:39: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: akka.stream.impl.ReactiveStreamsCompliance.SpecViolation) => ()
[warn]       case _: SpecViolation ? // nothing we can do
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\CompletedPublishers.scala:114: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: akka.stream.impl.ReactiveStreamsCompliance.SpecViolation) => ()
[warn]       case _: SpecViolation ? // nothing we can do
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ConstantFun.scala:18: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ConstantFun.this.JavaPairFunction.asInstanceOf[akka.japi.function.Function2[A,B,akka.japi.Pair[A,B]]]
[warn]   def javaCreatePairFunction[A, B]: JFun2[A, B, JPair[A, B]] = JavaPairFunction.asInstanceOf[JFun2[A, B, JPair[A, B]]]
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ConstantFun.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ConstantFun.this.JavaIdentityFunction.asInstanceOf[akka.japi.function.Function[T,T]]
[warn]   def javaIdentityFunction[T]: JFun[T, T] = JavaIdentityFunction.asInstanceOf[JFun[T, T]]
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanIn.scala:173: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def dequeue(id: Int): Any = {

[warn]   scala.this.Predef.require(InputBunch.this.isDepleted(id).unary_!, scala.StringContext.apply("Can\'t dequeue from depleted ", "").s(id));

[warn]   scala.this.Predef.require(InputBunch.this.isPending(id), scala.StringContext.apply("No pending input at ", "").s(id));

[warn]   Input
[warn]     def dequeue(id: Int): Any = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanIn.scala:191: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def dequeueAndYield(): Any = InputBunch.this.dequeueAndYield(InputBunch.this.idToDequeue())
[warn]     def dequeueAndYield(): Any =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanIn.scala:194: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def dequeueAndYield(id: Int): Any = {

[warn]   InputBunch.this.preferredId_=(id.+(1));

[warn]   if (InputBunch.this.preferredId.==(InputBunch.this.inputCount))

[warn]     InputBunch.this.preferredId_=(0)

[warn]   else

[warn]     ();

[warn]   InputBunch.this.dequeue(id)

[warn] }
[warn]     def dequeueAndYield(id: Int): Any = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanIn.scala:200: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def dequeuePreferring(preferred: Int): Any = {

[warn]   InputBunch.this.preferredId_=(preferred);

[warn]   val id: Int = InputBunch.this.idToDequeue();

[warn]   InputBunch.this.dequeue(id)

[warn] }
[warn]     def dequeuePreferring(preferred: Int): Any = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanOut.scala:314: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("can only handle Tuple2 and akka.japi.Pair!").s()
[warn]             s"can only handle Tuple2 and akka.japi.Pair!")
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanOut.scala:183: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val output: Int = _).
[warn]     def onCancel(output: Int): Unit = ()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanoutProcessor.scala:86: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   subscription.asInstanceOf[akka.stream.impl.ActorSubscriptionWithCursor[Any]]
[warn]       moreRequested(subscription.asInstanceOf[ActorSubscriptionWithCursor[Any]], elements)
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanoutProcessor.scala:89: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   subscription.asInstanceOf[akka.stream.impl.ActorSubscriptionWithCursor[Any]]
[warn]       unregisterSubscription(subscription.asInstanceOf[ActorSubscriptionWithCursor[Any]])
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanoutProcessor.scala:49: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FanoutOutputs.this.exposedPublisher.ne(null)
[warn]       if (exposedPublisher ne null) exposedPublisher.shutdown(Some(e))
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\FanoutProcessor.scala:63: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FanoutOutputs.this.exposedPublisher.ne(null)
[warn]     if (exposedPublisher ne null) {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Modules.scala:35: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SourceModule.this.attributes.nameOrDefault(null)
[warn]     val thisN = attributes.nameOrDefault(null)
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Modules.scala:36: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   attr.nameOrDefault(null)
[warn]     val thatN = attr.nameOrDefault(null)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Modules.scala:30: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[Out] @scala.annotation.unchecked.uncheckedVariance = _
[warn]   protected def newInstance(shape: SourceShape[Out] @uncheckedVariance): SourceModule[Out, Mat]
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Modules.scala:55: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[Out] = _
[warn]   override protected def newInstance(shape: SourceShape[Out]): SourceModule[Out, Subscriber[Out]] = new SubscriberSource[Out](attributes, shape)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Modules.scala:72: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[Out] = _
[warn]   override protected def newInstance(shape: SourceShape[Out]): SourceModule[Out, NotUsed] = new PublisherSource[Out](p, attributes, shape)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Modules.scala:85: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[Out] = _
[warn]   override protected def newInstance(shape: SourceShape[Out]): SourceModule[Out, Promise[Option[Out]]] = new MaybeSource[Out](attributes, shape)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Modules.scala:101: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[Out] = _
[warn]   override protected def newInstance(shape: SourceShape[Out]): SourceModule[Out, ActorRef] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Modules.scala:121: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[Out] = _
[warn]   override protected def newInstance(shape: SourceShape[Out]): SourceModule[Out, ActorRef] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:70: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   element.==(null)
[warn]     if (element == null) throw elementMustNotBeNullException
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:64: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw subscriberMustNotBeNullException
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:67: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   cause.eq(null)
[warn]     if (cause eq null) throw exceptionMustNotBeNullException
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:73: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscription.==(null)
[warn]     if (subscription == null) throw subscriptionMustNotBeNullException
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:31: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def numberOfElementsInRequestMustBePositiveException: Throwable =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:34: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def canNotSubscribeTheSameSubscriberMultipleTimesException: Throwable =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:37: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def subscriberMustNotBeNullException: Throwable =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:40: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def exceptionMustNotBeNullException: Throwable =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:43: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def elementMustNotBeNullException: Throwable =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:46: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def subscriptionMustNotBeNullException: Throwable =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:49: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def rejectDuplicateSubscriber[T](subscriber: Subscriber[T]): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:55: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def rejectAdditionalSubscriber[T](subscriber: Subscriber[T], rejector: String): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:60: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def rejectDueToNonPositiveDemand[T](subscriber: Subscriber[T]): Unit =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:63: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def requireNonNullSubscriber[T](subscriber: Subscriber[T]): Unit =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:66: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def requireNonNullException(cause: Throwable): Unit =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:69: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def requireNonNullElement[T](element: T): Unit =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:72: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def requireNonNullSubscription(subscription: Subscription): Unit =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:81: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tryOnError[T](subscriber: Subscriber[T], error: Throwable): Unit =
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:90: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tryOnNext[T](subscriber: Subscriber[T], element: T): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:97: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tryOnSubscribe[T](subscriber: Subscriber[T], subscription: Subscription): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:103: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tryOnComplete[T](subscriber: Subscriber[T]): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:109: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tryRequest(subscription: Subscription, demand: Long): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ReactiveStreamsCompliance.scala:115: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tryCancel(subscription: Subscription): Unit = {
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ResizableMultiReaderRingBuffer.scala:113: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ResizableMultiReaderRingBuffer.this.array.apply(c.&(ResizableMultiReaderRingBuffer.this.mask)).asInstanceOf[T]
[warn]       val ret = array(c & mask).asInstanceOf[T]
[warn]                                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ResizableMultiReaderRingBuffer.scala:139: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]     s"ResizableMultiReaderRingBuffer(size=$size, writeIx=$writeIx, readIx=$readIx, cursors=${cursors.cursors.size})"
[info]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\ResizableMultiReaderRingBuffer.scala:131: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ResizableMultiReaderRingBuffer.this.array.update(ResizableMultiReaderRingBuffer.this.readIx.&(ResizableMultiReaderRingBuffer.this.mask), null)
[warn]       array(readIx & mask) = null
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:111: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   fanoutProcessor.asInstanceOf[akka.stream.impl.ActorPublisher[Any]]
[warn]     impl ! ExposedPublisher(fanoutProcessor.asInstanceOf[ActorPublisher[Any]])
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:209: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       private[this] var prev: T = null.asInstanceOf[T]
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:220: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]         prev = null.asInstanceOf[T]
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:226: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]         prev = null.asInstanceOf[T]
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:441: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[Any]
[warn]   private var reduced: Any = null.asInstanceOf[Any]
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:19: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.actor.{ ActorRef, Props }
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:19: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.actor.{ ActorRef, Props }
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:20: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.stream.Attributes.InputBuffer
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:21: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.stream._
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:62: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SinkModule.this.attributes.nameOrDefault(null)
[warn]     val thisN = attributes.nameOrDefault(null)
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:63: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   attr.nameOrDefault(null)
[warn]     val thatN = attr.nameOrDefault(null)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:445: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ReducerState.this.reduced.==(null)
[warn]     if (reduced == null) reduced = batch
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:93: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[In] = _
[warn]   override protected def newInstance(shape: SinkShape[In]): SinkModule[In, Publisher[In]] = new PublisherSink[In](attributes, shape)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:116: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[In] = _
[warn]   override protected def newInstance(shape: SinkShape[In]): SinkModule[In, Publisher[In]] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:136: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[Any] = _
[warn]   override protected def newInstance(shape: SinkShape[Any]): SinkModule[Any, Future[Done]] = new SinkholeSink(attributes, shape)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:148: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[In] = _
[warn]   override protected def newInstance(shape: SinkShape[In]): SinkModule[In, NotUsed] = new SubscriberSink[In](subscriber, attributes, shape)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:158: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[Any] = _
[warn]   override protected def newInstance(shape: SinkShape[Any]): SinkModule[Any, NotUsed] = new CancelSink(attributes, shape)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:174: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[In] = _
[warn]   override protected def newInstance(shape: SinkShape[In]): SinkModule[In, ActorRef] = new ActorSubscriberSink[In](props, attributes, shape)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sinks.scala:194: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[In] = _
[warn]   override protected def newInstance(shape: SinkShape[In]): SinkModule[In, NotUsed] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sources.scala:309: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   UnfoldResourceSourceAsync.this.readData.apply(resource).onComplete[Unit]($anon.this.callback)($anon.this.context)

[warn] } catch {

[warn]   case (x$4 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr1: PartialFunction[Throwable,Unit] = $anon.this.errorHandler;

[warn]     if (catchExpr1.isDefinedAt(x$4))

[warn]         try { readData(resource).onComplete(callback) } catch errorHandler
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sources.scala:104: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   $anon.this.pendingOffer.get
[warn]               pendingOffer.get.promise.success(QueueOfferResult.Dropped)
[warn]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sources.scala:214: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final override def onPull(): Unit = {
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sources.scala:307: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final override def onPull(): Unit = onResourceReady {
[info]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sources.scala:286: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   ((x1.asInstanceOf[S]: S): S @unchecked) match {

[warn]   case (resource @ _) => f.apply(resource)

[warn]   case (defaultCase$ @ _) => default.apply(x1)

[warn] }
[warn]     private def onResourceReady(f: (S) ? Unit): Unit = resource.future.onSuccess {
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Sources.scala:307: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   x0$5 match {

[warn]   case (resource @ _) => try {

[warn]     UnfoldResourceSourceAsync.this.readData.apply(resource).onComplete[Unit]($anon.this.callback)($anon.this.context)

[warn]   } catch {

[warn]     case (x$4 @ (_: Th
[warn]     final override def onPull(): Unit = onResourceReady {
[warn]                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Stages.scala:140: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class SymbolicGraphStage[-In, +Out, Ext](symbolicStage: SymbolicStage[In, Out])
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:277: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[(Any, Any) => Any]
[warn]           if (comp == null) Combine(f.asInstanceOf[(Any, Any) ? Any], matCompLeft, matCompRight)
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:500: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   s.asInstanceOf[org.reactivestreams.Subscriber[Any]]
[warn]     def create(s: Subscriber[_]) = Both(s.asInstanceOf[Subscriber[Any]])
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:576: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   s.asInstanceOf[org.reactivestreams.Subscriber[Any]]
[warn]     } else rec(s.asInstanceOf[Subscriber[Any]])
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:591: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   subscriber.asInstanceOf[org.reactivestreams.Subscriber[Any]]
[warn]                 case _     ? pub.subscribe(subscriber.asInstanceOf[Subscriber[Any]])
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:783: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   pub.asInstanceOf[org.reactivestreams.Publisher[T]]
[warn]             pub.asInstanceOf[Publisher[T]].subscribe(subscriber)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:796: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   pub.asInstanceOf[org.reactivestreams.Publisher[r]]
[warn]         pub.asInstanceOf[Publisher[r]].subscribe(sub)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:998: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   s.asInstanceOf[org.reactivestreams.Subscriber[Any]]
[warn]       case s: Subscriber[_]       ? publisher.subscribe(s.asInstanceOf[Subscriber[Any]])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:272: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   f.==(akka.stream.scaladsl.Keep.left[Nothing, Any])
[warn]             if (f == scaladsl.Keep.left) {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:274: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   f.==(akka.stream.scaladsl.Keep.right[Any, Nothing])
[warn]             } else if (f == scaladsl.Keep.right) {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:665: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   t.==(null)
[warn]     if (t == null) {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:205: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   StreamLayout.this.validate(this, StreamLayout.this.validate$default$2, StreamLayout.this.validate$default$3, StreamLayout.this.validate$default$4)

[warn] else

[warn]   ()
[warn]       if (Debug) validate(this)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:226: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   StreamLayout.this.validate(this, StreamLayout.this.validate$default$2, StreamLayout.this.validate$default$3, StreamLayout.this.validate$default$4)

[warn] else

[warn]   ()
[warn]       if (Debug) validate(this)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:258: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   StreamLayout.this.validate(this, StreamLayout.this.validate$default$2, StreamLayout.this.validate$default$3, StreamLayout.this.validate$default$4)

[warn] else

[warn]   ()
[warn]       if (Debug) validate(this)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:304: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   StreamLayout.this.validate(this, StreamLayout.this.validate$default$2, StreamLayout.this.validate$default$3, StreamLayout.this.validate$default$4)

[warn] else

[warn]   ()
[warn]       if (Debug) validate(this)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:843: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(({

[warn]     val arg$macro$21: Int = java.this.lang.System.identityHashCode(enclosing);

[warn]     new scala.collection.immutable.StringOps("entering scope [%08x]").format(arg$macro$21)

[warn]   }: String))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(f"entering scope [${System.identityHashCode(enclosing)}%08x]")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:855: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(({

[warn]     val arg$macro$22: Int = java.this.lang.System.identityHashCode(enclosing);

[warn]     new scala.collection.immutable.StringOps("exiting scope [%08x]").format(arg$macro$22)

[warn]   }: String))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(f"exiting scope [${System.identityHashCode(enclosing)}%08x]")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:863: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("  subscribers = ", "\\n  publishers = ", "").s(scopeSubscribers, scopePublishers))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(s"  subscribers = $scopeSubscribers\n  publishers = $scopePublishers")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:877: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("beginning materialization of ", "").s(MaterializerSession.this.topLevel))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(s"beginning materialization of $topLevel")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:903: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("registering source ", "").s(ms))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(s"registering source $ms")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:913: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(({

[warn]     val arg$macro$23: Int = java.this.lang.System.identityHashCode(module);

[warn]     val arg$macro$24: Any = akka.event.Logging.simpleName(module);

[warn]     new scala.collection.immutable.StringOps("entering module [%08x] (%s)").format(arg$macro$23, arg$macro$24)

[warn]   }: String))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(f"entering module [${System.identityHashCode(module)}%08x] (${Logging.simpleName(module)})")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:930: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   {

[warn]     scala.this.Predef.println(({

[warn]       val arg$macro$25: Int = java.this.lang.System.identityHashCode(module);

[warn]       val arg$macro$26: Any = module.materializedValueComputation;

[warn]       new scala.collection.immutable.StringOps("resolving module [%08x] computation %s").format(arg$macro$25, arg$macro$26)

[warn]     }: String));

[warn]     scala.this.Predef.println(scala.StringContext.apply("  matValSrc = ", "").s(MaterializerSession.this.matValSrc));

[warn]     scala.this.Predef.println(scala.Stri
[warn]     if (MaterializerSession.Debug) {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:943: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(({

[warn]     val arg$macro$27: Int = java.this.lang.System.identityHashCode(module);

[warn]     new scala.collection.immutable.StringOps("exiting module [%08x]").format(arg$macro$27)

[warn]   }: String))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(f"exiting module [${System.identityHashCode(module)}%08x]")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:955: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.augmentString(" ").*(spaces).+(matNode))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(" " * spaces + matNode)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:962: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.augmentString(" ").*(spaces).+(scala.StringContext.apply("result = ", "").s(ret)))

[warn] else

[warn]   ()
[warn]     if (MaterializerSession.Debug) println(" " * spaces + s"result = $ret")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:966: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.augmentString(" ").*(spaces).+(scala.StringContext.apply("triggering sources ", "").s(srcs)))

[warn] else

[warn]   ()
[warn]         if (MaterializerSession.Debug) println(" " * spaces + s"triggering sources $srcs")
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:134: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Combine(f: (Any, Any) ? Any, dep1: MaterializedValueNode, dep2: MaterializedValueNode) extends MaterializedValueNode {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:137: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Atomic(module: Module) extends MaterializedValueNode {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:140: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Transform(f: Any ? Any, dep: MaterializedValueNode) extends MaterializedValueNode {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:498: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Both(subscriber: Subscriber[Any])
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:805: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   class MaterializationPanic extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace {

[warn]   <paramaccessor> private[this] val cause: Throwable = _;

[warn]   def <init>(cause: Throwable): akka.stream.impl.MaterializerSession.MaterializationPanic = {

[warn]     MaterializationPanic.super.<init>("Materialization aborted.", cause);

[warn]     ()

[warn]   }

[warn] }
[warn]   class MaterializationPanic(cause: Throwable) extends RuntimeException("Materialization aborted.", cause) with NoStackTrace
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:106: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]     if (problems.nonEmpty && !doPrint) throw new IllegalStateException(s"module inconsistent, found ${problems.size} problems")
[info]                                                                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:132: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def equals(other: Any): Boolean = MaterializedValueNode.super.equals(other)
[info]     override def equals(other: Any): Boolean = super.equals(other)
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:343: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   final override def hashCode(): Int = Module.super.hashCode()
[info]     final override def hashCode(): Int = super.hashCode()
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:344: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   final override def equals(obj: Any): Boolean = Module.super.equals(obj)
[info]     final override def equals(obj: scala.Any): Boolean = super.equals(obj)
[info]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:277: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   comp.==(null)
[warn]           if (comp == null) Combine(f.asInstanceOf[(Any, Any) ? Any], matCompLeft, matCompRight)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:561: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   VirtualProcessor.this.compareAndSet(null, s)
[warn]         case null ? if (!compareAndSet(null, s)) rec(sub)
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:572: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   s.==(null)
[warn]     if (s == null) {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:582: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   VirtualProcessor.this.compareAndSet(null, obj)
[warn]         case null ? if (!compareAndSet(null, obj)) rec(obj)
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:599: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   s.==(null)
[warn]     if (s == null) {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:630: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   VirtualProcessor.this.compareAndSet(null, ErrorPublisher.apply(ex, "failed-VirtualProcessor"))
[warn]           if (!compareAndSet(null, ErrorPublisher(ex, "failed-VirtualProcessor"))) rec(ex)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:631: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.==(null)
[warn]           else if (t == null) throw ex
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:634: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.==(null)
[warn]           else if (t == null) throw ex
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:638: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.==(null)
[warn]           finally if (t == null) throw ex // must throw NPE, rule 2:13
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:647: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.==(null)
[warn]     val ex = if (t == null) exceptionMustNotBeNullException else t
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:653: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   VirtualProcessor.this.compareAndSet(null, EmptyPublisher)
[warn]       case null            ? if (!compareAndSet(null, EmptyPublisher)) onComplete()
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:780: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   VirtualPublisher.this.compareAndSet(null, subscriber)
[warn]         case null ? if (!compareAndSet(null, subscriber)) rec()
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:793: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   VirtualPublisher.this.compareAndSet(null, pub)
[warn]       case null ? if (!compareAndSet(null, pub)) registerPublisher(pub)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:978: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   publisher.ne(null)
[warn]         if (publisher ne null) doSubscribe(publisher, subscriberOrVirtual)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:990: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.ne(null)
[warn]         if (subscriber ne null) doSubscribe(publisher, subscriber)
[warn]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:33: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def validate(m: Module, level: Int = 0, doPrint: Boolean = false, idMap: ju.Map[AnyRef, Integer] = new ju.HashMap): Unit = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:579: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   override final def onSubscribe(s: Subscription): Unit = {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:651: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @tailrec override final def onComplete(): Unit =
[info]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:670: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]           case s: Subscriber[_]             ? try s.onError(ex) catch { case NonFatal(_) ? } finally set(Inert)
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:671: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]           case Both(s)                      ? try s.onError(ex) catch { case NonFatal(_) ? } finally set(Inert)
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:834: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MaterializerSession.this.subscribersStack.head
[warn]   private def subscribers: ju.Map[InPort, AnyRef] = subscribersStack.head
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:835: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MaterializerSession.this.publishersStack.head
[warn]   private def publishers: ju.Map[OutPort, Publisher[Any]] = publishersStack.head
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:836: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MaterializerSession.this.moduleStack.head
[warn]   private def currentLayout: Module = moduleStack.head
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:837: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MaterializerSession.this.matValSrcStack.head
[warn]   private def matValSrc: ju.Map[MaterializedValueNode, List[MaterializedValueSource[Any]]] = matValSrcStack.head
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:858: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MaterializerSession.this.subscribersStack.tail
[warn]     subscribersStack = subscribersStack.tail
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:859: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MaterializerSession.this.publishersStack.tail
[warn]     publishersStack = publishersStack.tail
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:860: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MaterializerSession.this.matValSrcStack.tail
[warn]     matValSrcStack = matValSrcStack.tail
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:861: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   MaterializerSession.this.moduleStack.tail
[warn]     moduleStack = moduleStack.tail
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:44: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val i: akka.stream.InPort = _
[warn]     def ins(i: Iterable[InPort]) = i.map(in).mkString("In[", ",", "]")
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:45: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val o: akka.stream.OutPort = _
[warn]     def outs(o: Iterable[OutPort]) = o.map(out).mkString("Out[", ",", "]")
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:47: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val p: (akka.stream.OutPort, akka.stream.InPort) = _
[warn]     def pairs(p: Iterable[(OutPort, InPort)]) = p.map(pair).mkString("[", ",", "]")
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:432: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val attributes: akka.stream.Attributes = _
[warn]     override def withAttributes(attributes: Attributes): Module = copy(attributes = attributes)
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:467: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val attributes: akka.stream.Attributes = _
[warn]     override def withAttributes(attributes: Attributes): FusedModule = copy(attributes = attributes)
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:739: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val n: Long = _
[warn]         @tailrec def bufferDemand(n: Long): Unit = {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:1017: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val attributes: akka.stream.Attributes = _
[warn]   override def withAttributes(attributes: Attributes) = copy(attributes = attributes)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamSubscriptionTimeout.scala:87: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("because exceeding it\'s subscription-timeout.").s()
[warn]           s"because exceeding it's subscription-timeout.") with NoStackTrace)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\SubscriberManagement.scala:224: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   x$2.subscriber.==(subscriber)
[warn]     case NotReached if subscriptions.exists(_.subscriber == subscriber) ? ReactiveStreamsCompliance.rejectDuplicateSubscriber(subscriber)
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Throttle.scala:80: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       currentElement = null.asInstanceOf[T]
[warn]                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Timers.scala:50: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]         final override protected def onTimer(key: Any): Unit =
[info]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Timers.scala:72: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]         final override protected def onTimer(key: Any): Unit =
[info]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Timers.scala:98: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]         final override protected def onTimer(key: Any): Unit =
[info]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Timers.scala:130: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]         final override protected def onTimer(key: Any): Unit =
[info]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Timers.scala:158: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]       final override def onTimer(key: Any): Unit =
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Transfer.scala:131: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[akka] case class WaitingForUpstreamSubscription(remaining: Int, andThen: TransferPhase) extends TransferState {
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Transfer.scala:27: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def NeedsInput: TransferState
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Transfer.scala:28: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def NeedsInputOrComplete: TransferState
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Transfer.scala:60: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def NeedsDemand: TransferState
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Transfer.scala:61: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def NeedsDemandOrCancel: TransferState
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\Transfer.scala:86: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   override def NeedsDemandOrCancel: TransferState = new TransferState {
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:147: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[AnyRef]
[warn]         inputBuffer((nextInputElementCursor + inputBufferElements) & IndexMask) = elem.asInstanceOf[AnyRef]
[warn]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:539: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("registering new shell in ", "\\n  ", "").s(ActorGraphInterpreter.this._initial, shell.toString().replace("\n", "\n  ")))

[warn] else

[warn]   ()
[warn]       if (GraphInterpreter.Debug) println(s"registering new shell in ${_initial}\n  ${shell.toString.replace("\n", "\n  ")}")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:631: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("newShells:").s()
[warn]       builder.append(s"newShells:")
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:64: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Resume(shell: GraphInterpreterShell) extends BoundaryEvent
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:65: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Abort(shell: GraphInterpreterShell) extends BoundaryEvent
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:245: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.isInstanceOf[akka.stream.impl.ReactiveStreamsCompliance.SpecViolation]
[warn]         if ((subscriber ne null) && !e.isInstanceOf[SpecViolation]) tryOnError(subscriber, e)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:297: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       subscriber = null
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:555: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var shortCircuitBuffer: util.ArrayDeque[Any] = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:117: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BatchingActorInputBoundary.this.inputBuffer.update(BatchingActorInputBoundary.this.nextInputElementCursor, null)
[warn]       inputBuffer(nextInputElementCursor) = null
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:131: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   java.util.Arrays.fill(BatchingActorInputBoundary.this.inputBuffer, 0, BatchingActorInputBoundary.this.inputBuffer.length, null)
[warn]       java.util.Arrays.fill(inputBuffer, 0, inputBuffer.length, null)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:139: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BatchingActorInputBoundary.this.upstream.ne(null)
[warn]         if (upstream ne null) tryCancel(upstream)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:234: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorOutputBoundary.this.exposedPublisher.ne(null)
[warn]         if (exposedPublisher ne null) exposedPublisher.shutdown(None)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:235: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorOutputBoundary.this.subscriber.ne(null)
[warn]         if (subscriber ne null) tryOnComplete(subscriber)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:244: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorOutputBoundary.this.exposedPublisher.ne(null)
[warn]         if (exposedPublisher ne null) exposedPublisher.shutdown(Some(e))
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:361: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreterShell.this.self.!=(null)
[warn]   def isInitialized: Boolean = self != null
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:558: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorGraphInterpreter.this.shortCircuitBuffer.==(null)
[warn]     if (shortCircuitBuffer == null) shortCircuitBuffer = new util.ArrayDeque[Any]()
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:588: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorGraphInterpreter.this.shortCircuitBuffer.!=(null)
[warn]     else if (shortCircuitBuffer != null) shortCircuitBatch()
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:619: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorGraphInterpreter.this.shortCircuitBuffer.!=(null)
[warn]       if (shortCircuitBuffer != null) shortCircuitBatch()
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:623: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorGraphInterpreter.this.shortCircuitBuffer.!=(null)
[warn]       if (shortCircuitBuffer != null) shortCircuitBatch()
[warn]                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:30: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   override final def carbonCopy: Module = CopiedModule(shape.deepCopy(), Attributes.none, this)
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:32: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   override final def replaceShape(newShape: Shape): Module =
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:595: [scapegoat] Suspicious match on class object
[warn]   Matching on an companion object of a case class is probably not what you intended.
[warn]   case ActorGraphInterpreter.Resume => ActorGraphInterpreter.this.finishShellRegistration()
[warn]         case Resume           ? finishShellRegistration()
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:621: [scapegoat] Suspicious match on class object
[warn]   Matching on an companion object of a case class is probably not what you intended.
[warn]   case ActorGraphInterpreter.Resume => {

[warn]   ActorGraphInterpreter.this.currentLimit_=(ActorGraphInterpreter.this.eventLimit);

[warn]   if (ActorGraphInterpreter.this.shortCircuitBuffer.!=(null))

[warn]     ActorGraphInterpreter.this.shortCircuitBatch()

[warn]   else

[warn]     ()

[warn] }
[warn]     case Resume ?
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:511: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]       case NonFatal(_) ?
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:362: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val self: akka.actor.ActorRef = _
[warn]   def init(self: ActorRef, subMat: SubFusingActorMaterializerImpl, enqueueToShortCircuit: (Any) ? Unit, eventLimit: Int): Int = {
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\ActorGraphInterpreter.scala:362: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val enqueueToShortCircuit: Any => Unit = _
[warn]   def init(self: ActorRef, subMat: SubFusingActorMaterializerImpl, enqueueToShortCircuit: (Any) ? Unit, eventLimit: Int): Int = {
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:32: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   fg.asInstanceOf[akka.stream.Fusing.FusedGraph[S,M]]
[warn]       case fg: FusedGraph[_, _]      ? fg
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:55: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   g.shape.copyFromPorts(struct.newInlets(g.shape.inlets), struct.newOutlets(g.shape.outlets)).asInstanceOf[S]
[warn]       struct.newOutlets(g.shape.outlets)).asInstanceOf[S]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:391: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.copyOf.asInstanceOf[akka.stream.impl.fusing.GraphStageModule].stage.asInstanceOf[akka.stream.impl.fusing.GraphStages.MaterializedValueSource[Any]]
[warn]             val ms = c.copyOf.asInstanceOf[GraphStageModule].stage.asInstanceOf[MaterializedValueSource[Any]]
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:514: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]         case null     ? null.asInstanceOf[T]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:701: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   t.!=(null)
[warn]       if (t != null) t
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:47: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   struct.dump()

[warn] else

[warn]   ()
[warn]           if (Debug) struct.dump()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:80: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   akka.stream.impl.StreamLayout.validate(module, akka.stream.impl.StreamLayout.validate$default$2, akka.stream.impl.StreamLayout.validate$default$3, akka.stream.impl.StreamLayout.validate$default$4)

[warn] else

[warn]   ()
[warn]     if (StreamLayout.Debug) validate(module)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:81: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(module)

[warn] else

[warn]   ()
[warn]     if (Debug) println(module)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:269: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   log(scala.StringContext.apply("entering ", " (hash=", ", async=", ", name=", ", dispatcher=", ")").s(m.getClass(), struct.hash(m), async, m.attributes.nameLifted, Fusing.this.dispatcher(m)))

[warn] else

[warn]   ()
[warn]     if (Debug) log(s"entering ${m.getClass} (hash=${struct.hash(m)}, async=$async, name=${m.attributes.nameLifted}, dispatcher=${dispatcher(m)})")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:572: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.augmentString("  ").*(indent).+(scala.StringContext.apply("registerInternals(", ")").s(s.outlets.map[String, Any]({

[warn]     ((obj: AnyRef) => BuildStructuralInfo.this.hash(obj))

[warn]   })(immutable.this.Seq.canBuildFrom[String]))))

[warn] else

[warn]   ()
[warn]       if (Debug) println("  " * indent + s"registerInternals(${s.outlets.map(hash)})")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:605: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.augmentString("  ").*(indent).+(scala.StringContext.apply("creating new group ", "").s(BuildStructuralInfo.this.hash(group))))

[warn] else

[warn]   ()
[warn]       if (Debug) println("  " * indent + s"creating new group ${hash(group)}")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:619: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.augmentString("  ").*(indent).+(scala.StringContext.apply("adding copy ", " ", " of ", "").s(BuildStructuralInfo.this.hash(copy), BuildStructuralInfo.this.printShape(copy.shape), BuildStructuralInfo.this.printShape(oldShape))))

[warn] else

[warn]   ()
[warn]       if (Debug) println("  " * indent + s"adding copy ${hash(copy)} ${printShape(copy.shape)} of ${printShape(oldShape)}")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:667: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.augmentString("  ").*(indent).+(scala.StringContext.apply("wiring ", " (", ") -> ", " (", ")").s(out, BuildStructuralInfo.this.hash(out), in, BuildStructuralInfo.this.hash(in))))

[warn] else

[warn]   ()
[warn]       if (Debug) println("  " * indent + s"wiring $out (${hash(out)}) -> $in (${hash(in)})")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:678: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.this.Predef.augmentString("  ").*(indent).+(scala.StringContext.apply("rewiring ", " -> ", "").s(BuildStructuralInfo.this.printShape(oldShape), BuildStructuralInfo.this.printShape(newShape))))

[warn] else

[warn]   ()
[warn]       if (Debug) println("  " * indent + s"rewiring ${printShape(oldShape)} -> ${printShape(newShape)}")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:645: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m.isInstanceOf[akka.stream.impl.fusing.GraphModule]
[warn]       if (m.isInstanceOf[GraphModule]) internalOuts.removeAll(m.shape.outlets.asJava)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:614: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                   _oldShape: Shape = null): Atomic = {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:585: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   in.!=(null)
[warn]         if (in != null) upstreams.remove(in)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:616: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   _oldShape.==(null)
[warn]         if (_oldShape == null) CopiedModule(m.shape.deepCopy(), inheritedAttributes, realModule(m))
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Fusing.scala:618: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   _oldShape.==(null)
[warn]       val oldShape = if (_oldShape == null) m.shape else _oldShape
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:184: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mv.copySrc.asInstanceOf[akka.stream.impl.fusing.GraphStages.MaterializedValueSource[Any]]
[warn]             val copy = mv.copySrc.asInstanceOf[MaterializedValueSource[Any]]
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:303: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GraphInterpreter.this._currentInterpreter.get().apply(0).asInstanceOf[akka.stream.impl.fusing.GraphInterpreter]
[warn]     _currentInterpreter.get()(0).asInstanceOf[GraphInterpreter].nonNull
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:310: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GraphInterpreter.this._currentInterpreter.get().apply(0).asInstanceOf[akka.stream.impl.fusing.GraphInterpreter]
[warn]     _currentInterpreter.get()(0).asInstanceOf[GraphInterpreter]
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:459: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   logic.handlers.apply(0).asInstanceOf[akka.stream.stage.OutHandler]
[warn]     connection.outHandler = logic.handlers(0).asInstanceOf[OutHandler]
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:472: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   logic.handlers.apply(0).asInstanceOf[akka.stream.stage.InHandler]
[warn]     connection.inHandler = logic.handlers(0).asInstanceOf[InHandler]
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:733: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   connection.slot.asInstanceOf[akka.stream.impl.fusing.GraphInterpreter.Failed]
[warn]         else connection.inHandler.onUpstreamFailure(connection.slot.asInstanceOf[Failed].ex)
[warn]                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:482: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", " SETHANDLER ", " (in) ", "").s(GraphInterpreter.this.Name, GraphInterpreter.this.inOwnerName(connection), handler))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name SETHANDLER ${inOwnerName(connection)} (in) $handler")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:490: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", " SETHANDLER ", " (out) ", "").s(GraphInterpreter.this.Name, GraphInterpreter.this.outOwnerName(connection), handler))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name SETHANDLER ${outOwnerName(connection)} (out) $handler")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:579: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", " ---------------- EXECUTE ", " (running=", ", shutdown=", ")").s(GraphInterpreter.this.Name, GraphInterpreter.this.queueStatus, GraphInterpreter.this.runningStages, GraphInterpreter.this.shutdownCounters))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name ---------------- EXECUTE $queueStatus (running=$runningStages, shutdown=$shutdownCounters)")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:678: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", " ---------------- ", " (running=", ", shutdown=", ")").s(GraphInterpreter.this.Name, GraphInterpreter.this.queueStatus, GraphInterpreter.this.runningStages, GraphInterpreter.this.shutdownCounters))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name ---------------- $queueStatus (running=$runningStages, shutdown=$shutdownCounters)")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:744: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", " PUSH ", " -> ", ", ", " (", ") [", "]").s(GraphInterpreter.this.Name, GraphInterpreter.this.outOwnerName(connection), GraphInterpreter.this.inOwnerName(connection), connection.slot, connection.inHandler, GraphInterpreter.this.inLogicName(connection)))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name PUSH ${outOwnerName(connection)} -> ${inOwnerName(connection)}, ${connection.slot} (${connection.inHandler}) [${inLogicName(connection)}]")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:751: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", " PULL ", " -> ", " (", ") [", "]").s(GraphInterpreter.this.Name, GraphInterpreter.this.inOwnerName(connection), GraphInterpreter.this.outOwnerName(connection), connection.outHandler, GraphInterpreter.this.outLogicName(connection)))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name PULL ${inOwnerName(connection)} -> ${outOwnerName(connection)} (${connection.outHandler}) [${outLogicName(connection)}]")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:772: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   if (GraphInterpreter.this.queueTail.-(GraphInterpreter.this.queueHead).>(GraphInterpreter.this.mask))

[warn]     new scala.`package`.Exception(scala.StringContext.apply("", " internal queue full (", ") + ", "").s(GraphInterpreter.this.Name, GraphInterpreter.this.queueStatus, connection)).printStackTrace()

[warn]   else

[warn]     ()

[warn] else

[warn]   ()
[warn]     if (Debug) if (queueTail - queueHead > mask) new Exception(s"$Name internal queue full ($queueStatus) + $connection").printStackTrace()
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:825: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", "   complete(", ") [", "]").s(GraphInterpreter.this.Name, connection, currentState))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name   complete($connection) [$currentState]")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:839: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", "   fail(", ", ", ") [", "]").s(GraphInterpreter.this.Name, connection, ex, currentState))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name   fail($connection, $ex) [$currentState]")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:857: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", "   cancel(", ") [", "]").s(GraphInterpreter.this.Name, connection, currentState))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$Name   cancel($connection) [$currentState]")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:805: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Error during postStop in [{}]: {}").s()
[warn]         log.error(e, s"Error during postStop in [{}]: {}", assembly.stages(logic.stageId), e.getMessage)
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:441: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Name: String =
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:30: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   final val NoEvent = null
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:207: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           inHandler = null,
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:208: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           outHandler = null
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:430: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var chasedPush: Connection = NoEvent
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:431: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var chasedPull: Connection = NoEvent
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:602: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]               chasedPush = NoEvent
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:606: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]               chasedPull = NoEvent
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:648: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           chasedPush = NoEvent
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:659: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           chasedPull = NoEvent
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:669: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           chasedPush = NoEvent
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:704: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     activeStage = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:830: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       chasedPush = NoEvent
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:848: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         chasedPush = NoEvent
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:865: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         chasedPull = NoEvent
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:211: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphAssembly.this.ins.apply(i).ne(null)
[warn]         if (ins(i) ne null) {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:220: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphAssembly.this.outs.apply(i).ne(null)
[warn]         if (outs(i) ne null) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:442: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreter.this._Name.eq(null)
[warn]     if (_Name eq null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:512: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subMat.==(null)
[warn]     _subFusingMaterializer = if (subMat == null) materializer else subMat
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:591: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreter.this.activeStage.==(null)
[warn]           if (activeStage == null) throw e
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:600: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreter.this.chasedPush.ne(null)
[warn]             if (chasedPush ne NoEvent) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:604: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreter.this.chasedPull.ne(null)
[warn]             if (chasedPull ne NoEvent) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:646: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreter.this.chasedPush.!=(null)
[warn]         while (chasedPush != NoEvent) {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:657: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreter.this.chasedPull.!=(null)
[warn]         while (chasedPull != NoEvent) {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:667: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreter.this.chasedPush.!=(null)
[warn]         if (chasedPush != NoEvent) {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:766: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphInterpreter.this.eventQueue.update(idx, null)
[warn]     eventQueue(idx) = NoEvent
[warn]                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:253: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final def apply(
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:647: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val connection: akka.stream.impl.fusing.GraphInterpreter.Connection = GraphInterpreter.this.chasedPush
[warn]           val connection = chasedPush
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphInterpreter.scala:658: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val connection: akka.stream.impl.fusing.GraphInterpreter.Connection = GraphInterpreter.this.chasedPull
[warn]           val connection = chasedPull
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphStages.scala:73: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GraphStages.this.Identity.asInstanceOf[akka.stream.impl.fusing.GraphStages.SimpleLinearGraphStage[T]]
[warn]   def identity[T] = Identity.asInstanceOf[SimpleLinearGraphStage[T]]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphStages.scala:114: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GraphStages.this._detacher.asInstanceOf[akka.stream.stage.GraphStage[akka.stream.FlowShape[T,T]]]
[warn]   def detacher[T]: GraphStage[FlowShape[T, T]] = _detacher.asInstanceOf[GraphStage[FlowShape[T, T]]]
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphStages.scala:153: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GraphStages.this.TerminationWatcher.asInstanceOf[akka.stream.stage.GraphStageWithMaterializedValue[akka.stream.FlowShape[T,T],scala.concurrent.Future[akka.Done]]]
[warn]     TerminationWatcher.asInstanceOf[GraphStageWithMaterializedValue[FlowShape[T, T], Future[Done]]]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphStages.scala:157: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   s.asInstanceOf[akka.stream.FlowMonitorState.StreamState[T]]
[warn]       case s: StreamState[_] ? s.asInstanceOf[StreamState[T]]
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphStages.scala:158: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.asInstanceOf[T]
[warn]       case msg               ? Received(msg.asInstanceOf[T])
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphStages.scala:175: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.isInstanceOf[akka.stream.FlowMonitorState.StreamState[_]]
[warn]           monitor.set(if (msg.isInstanceOf[StreamState[_]]) Received(msg) else msg)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\GraphStages.scala:38: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val attributes: akka.stream.Attributes = _
[warn]   override def withAttributes(attributes: Attributes): Module =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\IteratorInterpreter.scala:50: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private var lastFailure: Throwable = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\IteratorInterpreter.scala:83: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         lastFailure = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\IteratorInterpreter.scala:81: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   IteratorDownstream.this.lastFailure.ne(null)
[warn]       if (lastFailure ne null) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\IteratorInterpreter.scala:122: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ins.update(length, null)
[warn]     ins(length) = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\IteratorInterpreter.scala:124: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   outs.update(0, null)
[warn]     outs(0) = null
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\IteratorInterpreter.scala:141: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new GraphInterpreter(assembly, akka.stream.NoMaterializer, akka.event.NoLogging, logics, connections, ((x$4: akka.stream.stage.GraphStageLogic, x$5: Any, x$6: Any => Unit) => throw new scala.`package`.UnsupportedOperationException("IteratorInterpreter does not support asynchronous events.")), false,
[warn]     val interpreter = new GraphInterpreter(
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\IteratorInterpreter.scala:152: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   interpreter.init(null)
[warn]     interpreter.init(null)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:780: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[Out]
[warn]     private var agg: Out = null.asInstanceOf[Out]
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:782: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[In]
[warn]     private var pending: In = null.asInstanceOf[In]
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:793: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[In]
[warn]           pending = null.asInstanceOf[In]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:799: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[In]
[warn]               pending = null.asInstanceOf[In]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:803: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[Out]
[warn]         agg = null.asInstanceOf[Out]
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:868: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[In]
[warn]           pending = null.asInstanceOf[In]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:878: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[Out]
[warn]       agg = null.asInstanceOf[Out]
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:880: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[In]
[warn]       pending = null.asInstanceOf[In]
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:694: [scapegoat] Avoid Traversable.size != 0
[warn]   .size can be slow for some data structures, prefer .nonEmpty, which is O(1).
[warn]   $anon.this.buf.size.>(0)
[warn]       if (buf.size < n && buf.size > 0) {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1134: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   akka.stream.ActorMaterializerHelper.downcast($anon.this.materializer)

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => throw new scala.`package`.RuntimeException("Log stage can only provide LoggingAdapter when used with ActorMaterializer! Provide a LoggingAdapter explicitly or use the actor base
[warn]             val mat = try ActorMaterializerHelper.downcast(materializer)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1207: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   scala.StringContext.apply("", "(", ")").s("akka.stream.Log", akka.stream.ActorMaterializerHelper.downcast(t).supervisor.path)

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => akka.event.LogSource.fromString.genString("akka.stream.Log")

[warn] }
[warn]       try s"$DefaultLoggerName(${ActorMaterializerHelper.downcast(t).supervisor.path})"
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:453: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   update.!=(null)
[warn]         case Success(update) if update != null ? {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:465: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   s.==(null)
[warn]             case Success(s) if s == null ?
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:785: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   $anon.this.agg.!=(null)
[warn]       if (agg != null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:789: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   $anon.this.pending.!=(null)
[warn]       if (pending != null) {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:813: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   $anon.this.agg.==(null)
[warn]       if (agg == null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:842: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   $anon.this.pending.==(null)
[warn]       if (pending == null) pull(in)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:846: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   $anon.this.agg.==(null)
[warn]       if (agg == null) completeStage()
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:850: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   $anon.this.agg.==(null)
[warn]       if (agg == null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:855: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   $anon.this.pending.==(null)
[warn]         if (pending == null) completeStage()
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1062: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   elem.!=(null)
[warn]           case Success(elem) if elem != null ?
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1070: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   s.==(null)
[warn]               case Success(s) if s == null ? ReactiveStreamsCompliance.elementMustNotBeNullException
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:915: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if ($anon.this.iterator.hasNext.&&($anon.this.expanded.unary_!))

[warn]   ()

[warn] else

[warn]   $anon.this.completeStage()
[warn]       if (iterator.hasNext && !expanded) () // need to wait
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1597: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       currentIterator = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1565: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.currentIterator.!=(null)
[warn]     def hasNext = if (currentIterator != null) currentIterator.hasNext else false
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:522: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Intersperse.this.start.get
[warn]   if (start.isDefined) ReactiveStreamsCompliance.requireNonNullElement(start.get)
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:523: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Intersperse.this.end.get
[warn]   if (end.isDefined) ReactiveStreamsCompliance.requireNonNullElement(end.get)
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:534: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Intersperse.this.start.get
[warn]         if (start.isDefined) emitMultiple(out, Iterator(start.get, grab(in)))
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:549: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Intersperse.this.end.get
[warn]         if (end.isDefined) emit(out, end.get)
[warn]                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:451: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   $anon.this.getAsyncCallback[scala.util.Try[Out]](((result: scala.util.Try[Out]) => result match {

[info]   case (value: Out)scala.util.Success[Out]((update @ _)) if update.!=(null) => {

[info]     $anon.this.aggregator_=(update);

[info]     if ($anon.this.isClosed[In](FoldAsync.this.in))

[info]       {

[info]         $anon.this.push[Out](FoldAsync.this.out, update);

[info]         $anon.this.completeStage()

[info]       }

[info]     else

[info]       if ($anon.this.isAvailable[Out](FoldAsync.this.out).&&($anon.this.hasBeenPulled[In](FoldAsync.this.
[info]     private val futureCB = getAsyncCallback[Try[Out]]((result: Try[Out]) ? {
[info]                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1401: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final override protected def onTimer(key: Any): Unit = {
[info]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1426: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final override protected def onTimer(key: Any): Unit =
[info]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\Ops.scala:1450: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final override protected def onTimer(key: Any): Unit = allow = true
[info]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:226: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[K]
[warn]     private var nextElementKey: K = null.asInstanceOf[K]
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:227: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]     private var nextElementValue: T = null.asInstanceOf[T]
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:237: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[K]
[warn]       nextElementKey = null.asInstanceOf[K]
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:238: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       nextElementValue = null.asInstanceOf[T]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:358: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]           firstElement = null.asInstanceOf[T]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:485: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       var firstElem: T = null.asInstanceOf[T]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:487: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SubstreamHandler.this.firstElem.asInstanceOf[AnyRef]
[warn]       def hasInitialElement: Boolean = firstElem.asInstanceOf[AnyRef] ne null
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:507: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]           firstElem = null.asInstanceOf[T]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:589: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SubSink.this.status.get().asInstanceOf[akka.stream.impl.fusing.SubSink.Command => Unit]
[warn]           status.get.asInstanceOf[Command ? Unit](RequestOne)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:597: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SubSink.this.status.get().asInstanceOf[akka.stream.impl.fusing.SubSink.Command => Unit]
[warn]         status.get.asInstanceOf[Command ? Unit](Cancel)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:680: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SubSource.this.status.get().asInstanceOf[akka.stream.stage.AsyncCallback[Any]]
[warn]         status.get.asInstanceOf[AsyncCallback[Any]].invoke(ActorSubscriberMessage.OnComplete)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:688: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SubSource.this.status.get().asInstanceOf[akka.stream.stage.AsyncCallback[Any]]
[warn]         status.get.asInstanceOf[AsyncCallback[Any]].invoke(failure)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:710: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[T]
[warn]         case ActorSubscriberMessage.OnNext(elem) ? push(out, elem.asInstanceOf[T])
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:234: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   $anon.this.nextElementKey.!=(null)
[warn]     private def hasNextElement = nextElementKey != null
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:283: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   key.!=(null)
[warn]       require(key != null, "Key cannot be null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:338: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   SubstreamSource.this.firstElement.!=(null)
[warn]       def firstPush(): Boolean = firstElement != null
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:22: [scapegoat] Java conversions
[warn]   Use of Java conversions can lead to unusual behaviour. It is recommended to use JavaConverters.
[warn] import scala.collection.JavaConversions._
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:118: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private var tailSource: SubSourceOutlet[T] = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:157: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       builder = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:421: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private var substreamSource: SubSourceOutlet[T] = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:138: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   PrefixAndTailLogic.this.builder.eq(null)
[warn]     private def prefixComplete = builder eq null
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:285: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   substreamSource.!=(null)
[warn]       if (substreamSource != null) {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:327: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   substreamSource.!=(null)
[warn]       if (substreamSource != null) {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:487: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SubstreamHandler.this.firstElem.asInstanceOf[AnyRef].ne(null)
[warn]       def hasInitialElement: Boolean = firstElem.asInstanceOf[AnyRef] ne null
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:588: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SubSink.this.status.compareAndSet(null, SubSink.RequestOne)
[warn]         if (!status.compareAndSet(null, RequestOne))
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:610: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SubSink.this.status.compareAndSet(null, cb)
[warn]           if (!status.compareAndSet(null, cb)) setCB(cb)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:679: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SubSource.this.status.compareAndSet(null, akka.stream.actor.ActorSubscriberMessage.OnComplete)
[warn]       if (!status.compareAndSet(null, ActorSubscriberMessage.OnComplete))
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:687: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SubSource.this.status.compareAndSet(null, failure)
[warn]       if (!status.compareAndSet(null, failure))
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:692: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SubSource.this.status.compareAndSet(null, akka.stream.actor.ActorSubscriberMessage.OnError.apply(new akka.stream.impl.SubscriptionTimeoutException(scala.StringContext.apply("Substream Source has not been materialized in ", "").s(d))))
[warn]     status.compareAndSet(null, ActorSubscriberMessage.OnError(new SubscriptionTimeoutException(s"Substream Source has not been materialized in $d")))
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\fusing\StreamOfStreams.scala:699: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SubSource.this.status.compareAndSet(null, cb)
[warn]         case null                               ? if (!status.compareAndSet(null, cb)) setCB(cb)
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\ByteStringParser.scala:150: [scapegoat] Empty while block
[warn]   An empty while block is considered as dead code.
[warn]   while$1(){

[warn]   if (ByteReader.this.readByte().!=(0))

[warn]     {

[warn]       ();

[warn]       while$1()

[warn]     }

[warn]   else

[warn]     ()

[warn] }
[warn]     def skipZeroTerminatedString(): Unit = while (readByte() != 0) {}
[warn]                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\ByteStringParser.scala:87: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ParseResult[+T](
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FilePublisher.scala:110: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FilePublisher.this.chan.ne(null)
[warn]       if (chan ne null) chan.close()
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FilePublisher.scala:77: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   chunks.head
[warn]       onNext(chunks.head)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FilePublisher.scala:78: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   chunks.tail
[warn]       signalOnNexts(chunks.tail)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FilePublisher.scala:38: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (initialBuffer).
[warn] private[akka] final class FilePublisher(f: Path, completionPromise: Promise[IOResult], chunkSize: Int, initialBuffer: Int, maxBuffer: Int)
[warn]                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FileSubscriber.scala:38: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   FileSubscriber.this.chan_=(java.nio.channels.FileChannel.open(FileSubscriber.this.f, scala.collection.JavaConverters.setAsJavaSetConverter[java.nio.file.StandardOpenOption](FileSubscriber.this.openOptions).asJava));

[warn]   FileSubscriber.super.preStart()

[warn] } catch {

[warn]   case (ex @ (_: Exception))
[warn]   override def preStart(): Unit = try {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FileSubscriber.scala:50: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   FileSubscriber.this.bytesWritten_=(FileSubscriber.this.bytesWritten.+(FileSubscriber.this.chan.write(bytes.asByteBuffer)))

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => {

[warn]     FileSubscriber.this.closeAndComplete(akka.stream.IOResult.apply(FileSubscriber.this.bytesWritten, scala.util.Failure.
[warn]       try {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FileSubscriber.scala:64: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   FileSubscriber.this.chan.force(true)

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => FileSubscriber.this.closeAndComplete(akka.stream.IOResult.apply(FileSubscriber.this.bytesWritten, scala.util.Failure.apply[Nothing](ex)))

[warn] }
[warn]       try {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FileSubscriber.scala:79: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   if (FileSubscriber.this.chan.ne(null))

[warn]     FileSubscriber.this.chan.close()

[warn]   else

[warn]     ();

[warn]   {

[warn]     FileSubscriber.this.completionPromise.trySuccess(result);

[warn]     ()

[warn]   }

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => {

[warn]     FileSubscriber.this.completionPromise.trySuccess(akka.stream.IORe
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\FileSubscriber.scala:83: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   FileSubscriber.this.chan.ne(null)
[warn]       if (chan ne null) chan.close()
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\IOSinks.scala:40: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[akka.util.ByteString] = _
[warn]   override protected def newInstance(shape: SinkShape[ByteString]): SinkModule[ByteString, Future[IOResult]] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\IOSinks.scala:67: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[akka.util.ByteString] = _
[warn]   override protected def newInstance(shape: SinkShape[ByteString]): SinkModule[ByteString, Future[IOResult]] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\IOSources.scala:69: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.stream.impl.ErrorPublisher.apply(ex, InputStreamSource.this.attributes.nameOrDefault("inputStreamSource")).asInstanceOf[org.reactivestreams.Publisher[akka.util.ByteString]]
[warn]         ErrorPublisher(ex, attributes.nameOrDefault("inputStreamSource")).asInstanceOf[Publisher[ByteString]]
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\IOSources.scala:59: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   val is: java.io.InputStream = InputStreamSource.this.createInputStream.apply();

[warn]   val props: akka.actor.Props = InputStreamPublisher.props(is, ioResultPromise, InputStreamSource.this.chunkSize);

[warn]   val ref: akka.actor.ActorRef = materializer.actorOf(context, props);

[warn]   akka.stream.actor.Ac
[warn]     val pub = try {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\IOSources.scala:40: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[akka.util.ByteString] = _
[warn]   override protected def newInstance(shape: SourceShape[ByteString]): SourceModule[ByteString, Future[IOResult]] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\IOSources.scala:75: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[akka.util.ByteString] = _
[warn]   override protected def newInstance(shape: SourceShape[ByteString]): SourceModule[ByteString, Future[IOResult]] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\InputStreamPublisher.scala:53: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   val readBytes: Int = InputStreamPublisher.this.is.read(InputStreamPublisher.this.arr);

[warn]   readBytes match {

[warn]     case -1 => {

[warn]       InputStreamPublisher.this.log.debug("No more bytes available to read (got `-1` from `read`)");

[warn]       InputStreamPublisher.this.onCompleteThenStop()

[warn]     }

[warn]  
[warn]   def readAndEmit(): Unit = if (totalDemand > 0) try {
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\InputStreamPublisher.scala:77: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   if (InputStreamPublisher.this.is.ne(null))

[warn]     InputStreamPublisher.this.is.close()

[warn]   else

[warn]     ()

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => InputStreamPublisher.this.completionPromise.success(akka.stream.IOResult.apply(InputStreamPublisher.this.readBytesTotal, scala.util.Failure.apply[
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\InputStreamPublisher.scala:78: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   InputStreamPublisher.this.is.ne(null)
[warn]       if (is ne null) is.close()
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\InputStreamSinkStage.scala:136: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   InputStreamAdapter.this.sharedBuffer.poll(InputStreamAdapter.this.readTimeout.toMillis, MILLISECONDS) match {

[warn]     case (data: akka.util.ByteString)akka.stream.impl.io.InputStreamSinkStage.Data((data @ _)) => {

[warn]       InputStreamAdapter.this.detachedChunk_=(scala.Some.apply[akka.util.ByteSt
[warn]             try {
[warn]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\InputStreamSinkStage.scala:24: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Data(data: ByteString) extends StreamToAdapterMessage
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\InputStreamSinkStage.scala:27: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Failed(cause: Throwable) extends StreamToAdapterMessage
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\InputStreamSinkStage.scala:161: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   InputStreamAdapter.this.detachedChunk.get
[warn]     val availableInChunk = detachedChunk.get.size
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSourceStage.scala:134: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   dataQueue.take()

[warn] } catch {

[warn]   case (_: InterruptedException) => {

[warn]     java.this.lang.Thread.interrupted();

[warn]     akka.util.ByteString.empty

[warn]   }

[warn] } finally $anon.this.blockingThread_=(null)
[warn]             try {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSourceStage.scala:59: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       private var dispatcher: ExecutionContext = null // set in preStart
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSourceStage.scala:60: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       private var blockingThread: Thread = null // for postStop interrupt
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSourceStage.scala:141: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]               blockingThread = null
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSourceStage.scala:149: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.blockingThread.!=(null)
[warn]         if (blockingThread != null)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSubscriber.scala:37: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   OutputStreamSubscriber.this.os.write(bytes.toArray[Byte]((ClassTag.Byte: scala.reflect.ClassTag[Byte])));

[warn]   OutputStreamSubscriber.this.bytesWritten_=(OutputStreamSubscriber.this.bytesWritten.+(bytes.length));

[warn]   if (OutputStreamSubscriber.this.autoFlush)

[warn]     OutputStreamSubscriber.this.o
[warn]       try {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSubscriber.scala:59: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   if (OutputStreamSubscriber.this.os.ne(null))

[warn]     OutputStreamSubscriber.this.os.close()

[warn]   else

[warn]     ()

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => OutputStreamSubscriber.this.completionPromise.success(akka.stream.IOResult.apply(OutputStreamSubscriber.this.bytesWritten, scala.util.Failure.
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\OutputStreamSubscriber.scala:60: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OutputStreamSubscriber.this.os.ne(null)
[warn]       if (os ne null) os.close()
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TLSActor.scala:421: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   task.!=(null)
[warn]     if (task != null) {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:210: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TcpStreamLogic.this.role.asInstanceOf[akka.stream.impl.io.TcpConnectionStage.Outbound]
[warn]           role.asInstanceOf[Outbound].localAddressPromise.success(c.localAddress)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:261: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[akka.util.ByteString]
[warn]         connection ! Write(elem.asInstanceOf[ByteString], WriteAck)
[warn]                                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:162: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Outbound(
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:167: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Inbound(connection: ActorRef, halfClose: Boolean) extends TcpRole
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:125: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.listener.ne(null)
[warn]         if (listener ne null) {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\io\TcpStages.scala:214: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val evt: (akka.actor.ActorRef, Any) = _
[warn]           stageActor.become(connected)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\BidiFlow.scala:17: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BidiFlow.this._identity.asInstanceOf[akka.stream.javadsl.BidiFlow[A,A,B,B,akka.NotUsed]]
[warn]   def identity[A, B]: BidiFlow[A, A, B, B, NotUsed] = _identity.asInstanceOf[BidiFlow[A, A, B, B, NotUsed]]
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\FileIO.scala:64: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val options: java.util.Set[java.nio.file.StandardOpenOption] = _).
[warn]   def toFile(f: File, options: util.Set[StandardOpenOption]): javadsl.Sink[ByteString, CompletionStage[IOResult]] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Flow.scala:54: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Flow.this._identity.asInstanceOf[akka.stream.javadsl.Flow[I,O,M]]
[warn]       case f: scaladsl.Flow[I, O, M] if f.isIdentity ? _identity.asInstanceOf[Flow[I, O, M]]
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Flow.scala:1918: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   this.log(name, extract, null)
[warn]     this.log(name, extract, null)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Flow.scala:1956: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   this.log(name, akka.stream.impl.ConstantFun.javaIdentityFunction[Out], null)
[warn]     this.log(name, ConstantFun.javaIdentityFunction[Out], null)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Flow.scala:46: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def of[T](clazz: Class[T]): javadsl.Flow[T, T, NotUsed] = create[T]()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Flow.scala:1532: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val eagerComplete: Boolean = _).
[warn]   def mergeMat[T >: Out, M, M2](
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:240: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Zip.this._toPair.asInstanceOf[akka.japi.function.Function2[A,B,akka.japi.Pair[A,B]]]
[warn]     ZipWith.create(_toPair.asInstanceOf[Function2[A, B, A Pair B]])
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:35: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T], inputPorts: Int): Graph[UniformFanInShape[T, T], NotUsed] = create(inputPorts)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:52: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T], inputPorts: Int, eagerComplete: Boolean): Graph[UniformFanInShape[T, T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:79: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T], secondaryPorts: Int): Graph[scaladsl.MergePreferred.MergePreferredShape[T], NotUsed] = create(secondaryPorts)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:96: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T], secondaryPorts: Int, eagerComplete: Boolean): Graph[scaladsl.MergePreferred.MergePreferredShape[T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:135: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T], outputCount: Int): Graph[UniformFanOutShape[T, T], NotUsed] = create(outputCount)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:168: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T], outputCount: Int, partitioner: function.Function[T, Int]): Graph[UniformFanOutShape[T, T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:205: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T], outputCount: Int): Graph[UniformFanOutShape[T, T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:214: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T], outputCount: Int, waitForAllDownstreams: Boolean): Graph[UniformFanOutShape[T, T], NotUsed] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:309: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val left: Class[A] = _).
[warn]   def create[A, B](left: Class[A], right: Class[B]): Graph[FanOutShape2[A Pair B, A, B], NotUsed] = create[A, B]()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Graph.scala:340: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def create[T](clazz: Class[T]): Graph[UniformFanInShape[T, T], NotUsed] = create()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Hub.scala:32: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def of[T](clazz: Class[T], perProducerBufferSize: Int): Source[T, Sink[T, NotUsed]] = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Hub.scala:85: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   def of[T](clazz: Class[T], bufferSize: Int): Sink[T, Source[T, NotUsed]] = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Keep.scala:16: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Keep.this._left.asInstanceOf[akka.japi.function.Function2[L,R,L]]
[warn]   def left[L, R]: function.Function2[L, R, L] = _left.asInstanceOf[function.Function2[L, R, L]]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Keep.scala:17: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Keep.this._right.asInstanceOf[akka.japi.function.Function2[L,R,R]]
[warn]   def right[L, R]: function.Function2[L, R, R] = _right.asInstanceOf[function.Function2[L, R, R]]
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Keep.scala:18: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Keep.this._both.asInstanceOf[akka.japi.function.Function2[L,R,akka.japi.Pair[L,R]]]
[warn]   def both[L, R]: function.Function2[L, R, L Pair R] = _both.asInstanceOf[function.Function2[L, R, L Pair R]]
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Keep.scala:19: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Keep.this._none.asInstanceOf[akka.japi.function.Function2[L,R,akka.NotUsed]]
[warn]   def none[L, R]: function.Function2[L, R, NotUsed] = _none.asInstanceOf[function.Function2[L, R, NotUsed]]
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Keep.scala:11: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def apply(l: Any, r: Any): Any = l
[warn]   private val _left = new function.Function2[Any, Any, Any] with ((Any, Any) ? Any) { def apply(l: Any, r: Any) = l }
[warn]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Keep.scala:12: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def apply(l: Any, r: Any): Any = r
[warn]   private val _right = new function.Function2[Any, Any, Any] with ((Any, Any) ? Any) { def apply(l: Any, r: Any) = r }
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Sink.scala:235: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   rest.!=(null)
[warn]     val seq = if (rest != null) rest.asScala.map(_.asScala) else Seq()
[warn]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Sink.scala:235: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]     val seq = if (rest != null) rest.asScala.map(_.asScala) else Seq()
[info]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:35: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Source.this._empty.asInstanceOf[akka.stream.javadsl.Source[O,akka.NotUsed]]
[warn]   def empty[O](): Source[O, NotUsed] = _empty.asInstanceOf[Source[O, NotUsed]]
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:159: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.collection.JavaConverters.asJavaIteratorConverter[Int](scala.`package`.Range.inclusive(start, end, step).iterator).asJava.asInstanceOf[java.util.Iterator[Integer]]
[warn]         Range.inclusive(start, end, step).iterator.asJava.asInstanceOf[util.Iterator[Integer]]
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:280: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Source.this.empty[Nothing]().asInstanceOf[akka.stream.javadsl.Source[T,M]]
[warn]       case s if s eq scaladsl.Source.empty ? empty().asInstanceOf[Source[T, M]]
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:289: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   rest.!=(null)
[warn]     val seq = if (rest != null) Util.immutableSeq(rest).map(_.asScala) else immutable.Seq()
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:297: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   sources.!=(null)
[warn]     val seq = if (sources != null) Util.immutableSeq(sources).map(_.asScala) else immutable.Seq()
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:305: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   sources.!=(null)
[warn]     val seq = if (sources != null) Util.immutableSeq(sources).map(_.asScala) else immutable.Seq()
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:2139: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   this.log(name, extract, null)
[warn]     this.log(name, extract, null)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:2177: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   this.log(name, akka.stream.impl.ConstantFun.javaIdentityFunction[Out], null)
[warn]     this.log(name, ConstantFun.javaIdentityFunction[Out], null)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:287: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type T
[warn]   def combine[T, U](first: Source[T, _ <: Any], second: Source[T, _ <: Any], rest: java.util.List[Source[T, _ <: Any]],
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:287: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type U
[warn]   def combine[T, U](first: Source[T, _ <: Any], second: Source[T, _ <: Any], rest: java.util.List[Source[T, _ <: Any]],
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:296: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type T
[warn]   def zipN[T](sources: java.util.List[Source[T, _ <: Any]]): Source[java.util.List[T], NotUsed] = {
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:304: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type T
[warn]   def zipWithN[T, O](zipper: function.Function[java.util.List[T], O], sources: java.util.List[Source[T, _ <: Any]]): Source[O, NotUsed] = {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:304: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type O
[warn]   def zipWithN[T, O](zipper: function.Function[java.util.List[T], O], sources: java.util.List[Source[T, _ <: Any]]): Source[O, NotUsed] = {
[warn]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:289: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   scala.collection.immutable.Seq.apply[Nothing]()
[info]     val seq = if (rest != null) Util.immutableSeq(rest).map(_.asScala) else immutable.Seq()
[info]                                                                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:297: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   scala.collection.immutable.Seq.apply[Nothing]()
[info]     val seq = if (sources != null) Util.immutableSeq(sources).map(_.asScala) else immutable.Seq()
[info]                                                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:305: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   scala.collection.immutable.Seq.apply[Nothing]()
[info]     val seq = if (sources != null) Util.immutableSeq(sources).map(_.asScala) else immutable.Seq()
[info]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:208: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val s: S = _
[warn]     new Source(scaladsl.Source.unfold(s)((s: S) ? f.apply(s).asScala.map(_.toScala)))
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:216: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val s: S = _
[warn]         (s: S) ? f.apply(s).toScala.map(_.asScala.map(_.toScala))(akka.dispatch.ExecutionContexts.sameThreadExecutionContext)))
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Source.scala:306: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val seq: scala.collection.immutable.Seq[T] = _
[warn]     new Source(scaladsl.Source.zipWithN[T, O](seq ? zipper.apply(seq.asJava))(seq))
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\StreamConverters.scala:190: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type T
[warn]   def javaCollector[T, R](collector: function.Creator[Collector[T, _ <: Any, R]]): Sink[T, CompletionStage[R]] =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\StreamConverters.scala:190: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type R
[warn]   def javaCollector[T, R](collector: function.Creator[Collector[T, _ <: Any, R]]): Sink[T, CompletionStage[R]] =
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\StreamConverters.scala:203: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type T
[warn]   def javaCollectorParallelUnordered[T, R](parallelism: Int)(collector: function.Creator[Collector[T, _ <: Any, R]]): Sink[T, CompletionStage[R]] =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\StreamConverters.scala:203: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type R
[warn]   def javaCollectorParallelUnordered[T, R](parallelism: Int)(collector: function.Creator[Collector[T, _ <: Any, R]]): Sink[T, CompletionStage[R]] =
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\SubFlow.scala:1376: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   this.log(name, extract, null)
[warn]     this.log(name, extract, null)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\SubFlow.scala:1414: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   this.log(name, akka.stream.impl.ConstantFun.javaIdentityFunction[Out], null)
[warn]     this.log(name, ConstantFun.javaIdentityFunction[Out], null)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\SubSource.scala:1368: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   this.log(name, extract, null)
[warn]     this.log(name, extract, null)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\SubSource.scala:1406: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   this.log(name, akka.stream.impl.ConstantFun.javaIdentityFunction[Out], null)
[warn]     this.log(name, ConstantFun.javaIdentityFunction[Out], null)
[warn]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\Tcp.scala:89: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.stream.javadsl.Tcp = Tcp.super.get(system)
[info]   override def get(system: ActorSystem): Tcp = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\package.scala:9: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scaladsl.Keep.left[Nothing, Nothing].asInstanceOf[(M1, M2) => M]
[warn]       case x if x eq Keep.left   ? scaladsl.Keep.left.asInstanceOf[(M1, M2) ? M]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\package.scala:10: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scaladsl.Keep.right[Nothing, Nothing].asInstanceOf[(M1, M2) => M]
[warn]       case x if x eq Keep.right  ? scaladsl.Keep.right.asInstanceOf[(M1, M2) ? M]
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\javadsl\package.scala:11: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   s.asInstanceOf[(M1, M2) => M]
[warn]       case s: Function2[_, _, _] ? s.asInstanceOf[(M1, M2) ? M]
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\BidiFlow.scala:14: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BidiFlow.this.module.shape.asInstanceOf[akka.stream.BidiShape[I1,O1,I2,O2]]
[warn]   override def shape = module.shape.asInstanceOf[BidiShape[I1, O1, I2, O2]]
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\BidiFlow.scala:127: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[Any => Any]
[warn]     new BidiFlow(module.transformMaterializedValue(f.asInstanceOf[Any ? Any]))
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\BidiFlow.scala:162: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BidiFlow.this._identity.asInstanceOf[akka.stream.scaladsl.BidiFlow[A,A,B,B,akka.NotUsed]]
[warn]   def identity[A, B]: BidiFlow[A, A, B, B, NotUsed] = _identity.asInstanceOf[BidiFlow[A, A, B, B, NotUsed]]
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\BidiFlow.scala:109: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   copy.shape.inlets.head
[warn]     val in = copy.shape.inlets.head
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\BidiFlow.scala:110: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   copy.shape.outlets.head
[warn]     val out = copy.shape.outlets.head
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:30: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Flow.this.module.shape.asInstanceOf[akka.stream.FlowShape[In,Out]]
[warn]   override val shape: FlowShape[In, Out] = module.shape.asInstanceOf[FlowShape[In, Out]]
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:52: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   combine.asInstanceOf[(Any, Any) => Any]
[warn]         } else Combine(combine.asInstanceOf[(Any, Any) ? Any], Ignore, Atomic(m))
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:102: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sink.asInstanceOf[akka.stream.Graph[akka.stream.SinkShape[In],Mat2]]
[warn]       Sink.fromGraph(sink.asInstanceOf[Graph[SinkShape[In], Mat2]])
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:103: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.NotUsed.asInstanceOf[Mat]
[warn]         .mapMaterializedValue(combine(NotUsed.asInstanceOf[Mat], _))
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:117: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[Any => Any]
[warn]     new Flow(module.transformMaterializedValue(f.asInstanceOf[Any ? Any]))
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:286: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Flow.this.identity.asInstanceOf[akka.stream.scaladsl.Flow[T,T,akka.NotUsed]]
[warn]   def apply[T]: Flow[T, T, NotUsed] = identity.asInstanceOf[Flow[T, T, NotUsed]]
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:345: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[Any => Any]
[warn]     copy(module.transformMaterializedValue(f.asInstanceOf[Any ? Any]))
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:1614: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   extract.asInstanceOf[Any => Any]
[warn]     via(Log(name, extract.asInstanceOf[Any ? Any], Option(log)))
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:50: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   combine.==(Keep.left[Nothing, Any])
[warn]         if (combine == Keep.left) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:1613: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def log(name: String, extract: Out ? Any = ConstantFun.scalaIdentityFunction)(implicit log: LoggingAdapter = null): Repr[Out] =
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:59: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   flowCopy.shape.outlets.head
[warn]           .replaceShape(FlowShape(shape.in, flowCopy.shape.outlets.head)))
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:155: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   flowCopy.shape.outlets.head
[warn]         .wire(flowCopy.shape.outlets.head, shape.in))
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:204: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   outs.head
[warn]       .replaceShape(FlowShape(ins(1), outs.head)))
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Flow.scala:1845: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val secondary: secondary.Shape = _
[warn]     GraphDSL.create(secondary) { implicit b ? secondary ?
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Framing.scala:142: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   DelimiterFramingStage.this.separatorBytes.head
[warn]       private val firstSeparatorByte = separatorBytes.head
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:119: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MergePreferredShape.super.deepCopy().asInstanceOf[akka.stream.scaladsl.MergePreferred.MergePreferredShape[T]]
[warn]     override def deepCopy(): MergePreferredShape[T] = super.deepCopy().asInstanceOf[MergePreferredShape[T]]
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:353: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]     def nullOut(): Unit = other = null.asInstanceOf[T]
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:543: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   $anon.this.outPendingElem.asInstanceOf[T]
[warn]               val elem = outPendingElem.asInstanceOf[T]
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:917: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   OrElse.this.singleton.asInstanceOf[akka.stream.scaladsl.OrElse[T]]
[warn]   def apply[T]() = singleton.asInstanceOf[OrElse[T]]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1013: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   graph.shape.copyFromPorts(copy.shape.inlets, copy.shape.outlets).asInstanceOf[S]
[warn]       graph.shape.copyFromPorts(copy.shape.inlets, copy.shape.outlets).asInstanceOf[S]
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1025: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   transform.asInstanceOf[Any => Any]
[warn]       moduleInProgress = moduleInProgress.compose(copy.transformMaterializedValue(transform.asInstanceOf[Any ? Any]), Keep.right)
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1026: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   graph.shape.copyFromPorts(copy.shape.inlets, copy.shape.outlets).asInstanceOf[S]
[warn]       graph.shape.copyFromPorts(copy.shape.inlets, copy.shape.outlets).asInstanceOf[S]
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1039: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   graph.shape.copyFromPorts(copy.shape.inlets, copy.shape.outlets).asInstanceOf[S]
[warn]       graph.shape.copyFromPorts(copy.shape.inlets, copy.shape.outlets).asInstanceOf[S]
[warn]                                                                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1250: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[I2, O2, Mat](bidi: Graph[BidiShape[O, O2, I2, I], Mat])(implicit b: Builder[_]): BidiShape[O, O2, I2, I] = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1257: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[I2, O2](bidi: BidiShape[O, O2, I2, I])(implicit b: Builder[_]): BidiShape[O, O2, I2, I] = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1263: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[M](flow: Graph[FlowShape[O, I], M])(implicit b: Builder[_]): Unit = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1271: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[I2, O2, Mat](bidi: Graph[BidiShape[O, O2, I2, I], Mat])(implicit b: Builder[_]): BidiShape[O, O2, I2, I] = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1279: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[I2, O2](bidi: BidiShape[O, O2, I2, I])(implicit b: Builder[_]): BidiShape[O, O2, I2, I] = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1286: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[M2](flow: Graph[FlowShape[O, I], M2])(implicit b: Builder[_]): Unit = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1295: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[I3, O3](other: BidiShape[O1, O3, I3, I2])(implicit b: Builder[_]): BidiShape[O1, O3, I3, I2] = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1301: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[I3, O3, M](otherFlow: Graph[BidiShape[O1, O3, I3, I2], M])(implicit b: Builder[_]): BidiShape[O1, O3, I3, I2] = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1308: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>(flow: FlowShape[O1, I2])(implicit b: Builder[_]): Unit = {
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1313: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]       def <~>[M](f: Graph[FlowShape[O1, I2], M])(implicit b: Builder[_]): Unit = {
[info]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:517: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   Partition.this.out.apply(idx)
[warn]       } else if (!isClosed(out(idx))) {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:518: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   Partition.this.out.apply(idx)
[warn]         if (isAvailable(out(idx))) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:519: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   Partition.this.out.apply(idx)
[warn]           push(out(idx), elem)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1010: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   akka.stream.impl.StreamLayout.validate(graph.module, akka.stream.impl.StreamLayout.validate$default$2, akka.stream.impl.StreamLayout.validate$default$3, akka.stream.impl.StreamLayout.validate$default$4)

[warn] else

[warn]   ()
[warn]       if (StreamLayout.Debug) StreamLayout.validate(graph.module)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1023: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   akka.stream.impl.StreamLayout.validate(graph.module, akka.stream.impl.StreamLayout.validate$default$2, akka.stream.impl.StreamLayout.validate$default$3, akka.stream.impl.StreamLayout.validate$default$4)

[warn] else

[warn]   ()
[warn]       if (StreamLayout.Debug) StreamLayout.validate(graph.module)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1036: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   akka.stream.impl.StreamLayout.validate(graph.module, akka.stream.impl.StreamLayout.validate$default$2, akka.stream.impl.StreamLayout.validate$default$3, akka.stream.impl.StreamLayout.validate$default$4)

[warn] else

[warn]   ()
[warn]       if (StreamLayout.Debug) StreamLayout.validate(graph.module)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:192: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if ($anon.this.preferredEmitting.==($anon.this.maxEmitting))

[warn]   ()

[warn] else

[warn]   $anon.this.emitPreferred()
[warn]         if (preferredEmitting == maxEmitting) () // blocked
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:223: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if ($anon.this.preferredEmitting.>(0))

[warn]   ()

[warn] else

[warn]   $anon.this.emit[T](MergePreferred.this.out, $anon.this.grab[T](port), pullPort)
[warn]           if (preferredEmitting > 0) () // blocked
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:989: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("OrElse").s()
[warn]   override def toString: String = s"OrElse"
[warn]                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:476: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PartitionOutOfBoundsException(msg: String) extends IndexOutOfBoundsException(msg) with NoStackTrace
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1068: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Builder.this.moduleInProgress.isInstanceOf[akka.stream.impl.StreamLayout.CopiedModule]
[warn]       if (moduleInProgress.isInstanceOf[CopiedModule]) {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:508: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private var outPendingElem: Any = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:546: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                 outPendingElem = null
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:564: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                 outPendingElem = null
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:66: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   in.==(null)
[warn]       if (in == null) {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:532: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.outPendingElem.==(null)
[warn]       if (outPendingElem == null) completeStage()
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:626: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   out.ne(null)
[warn]       if (out ne null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1215: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   DisabledPortOps.super.<init>(null, null)
[warn]     private class DisabledPortOps[Out](msg: String) extends PortOpsImpl[Out](null, null) {
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1226: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   DisabledReversePortOps.super.<init>(null)
[warn]     final class DisabledReversePortOps[In](msg: String) extends ReversePortOps[In](null) {
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:61: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val in: akka.stream.Inlet[T] = _
[warn]     override def preStart(): Unit = in.foreach(tryPull)
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:65: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val in: akka.stream.Inlet[T] = $anon.this.pendingQueue.dequeue()
[warn]       val in = pendingQueue.dequeue()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:93: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val in: akka.stream.Inlet[T] = _
[warn]             in.foreach(cancel)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:442: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val out: akka.stream.Outlet[T] = itr.next()
[warn]         val out = itr.next()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:623: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val out: akka.stream.Outlet[T] = $anon.this.pendingQueue.dequeue()
[warn]       val out = pendingQueue.dequeue()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:1205: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val b: akka.stream.scaladsl.GraphDSL.Builder[_] = _
[warn]       override def importAndGetPort(b: Builder[_]): Outlet[Out @uncheckedVariance] = outlet
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:359: [scapegoat] Var in closure
[warn]   Closing over a var can lead to subtle bugs.
[warn]   $anon.this.dispatch($anon.this.other, (x$1: T))
[warn]     val dispatchR = dispatch(other, _: T)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Graph.scala:360: [scapegoat] Var in closure
[warn]   Closing over a var can lead to subtle bugs.
[warn]   $anon.this.dispatch((x$2: T), $anon.this.other)
[warn]     val dispatchL = dispatch(_: T, other)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:412: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BroadcastSinkLogic.this.state.getAndSet(BroadcastSinkLogic.this.noRegistrationsState).asInstanceOf[BroadcastHub.this.Open]
[warn]           state.getAndSet(noRegistrationsState).asInstanceOf[Open].registrations foreach { consumer ?
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:461: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BroadcastSinkLogic.this.state.getAndSet(BroadcastHub.this.Closed.apply(scala.Some.apply[Throwable](ex))).asInstanceOf[BroadcastHub.this.Open]
[warn]       state.getAndSet(Closed(Some(ex))).asInstanceOf[Open].registrations foreach { consumer ?
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:544: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BroadcastSinkLogic.this.state.getAndSet(BroadcastHub.this.Closed.apply(scala.None)).asInstanceOf[BroadcastHub.this.Open]
[warn]         state.getAndSet(Closed(None)).asInstanceOf[Open].registrations foreach { consumer ?
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:556: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[AnyRef]
[warn]       queue(idx) = elem.asInstanceOf[AnyRef]
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:648: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[T]
[warn]                 push(out, elem.asInstanceOf[T])
[warn]                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:360: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class Open(callbackFuture: Future[AsyncCallback[HubEvent]], registrations: List[Consumer]) extends HubState
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:361: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class Closed(failure: Option[Throwable]) extends HubState
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:58: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final class ProducerFailed extends scala.`package`.RuntimeException {

[warn]   <paramaccessor> private[this] val msg: String = _;

[warn]   <paramaccessor> private[this] val cause: Throwable = _;

[warn]   def <init>(msg: String, cause: Throwable): akka.stream.scaladsl.MergeHub.ProducerFailed = {

[warn]     ProducerFailed.super.<init>(msg, cause);

[warn]     ()

[warn]   }

[warn] }
[warn]   final class ProducerFailed(msg: String, cause: Throwable) extends RuntimeException(msg, cause)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:563: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def poll(offset: Int): AnyRef = if (offset.==(BroadcastSinkLogic.this.tail))

[warn]   null

[warn] else

[warn]   BroadcastSinkLogic.this.queue.apply(offset.&(BroadcastHub.this.Mask))
[warn]     def poll(offset: Int): AnyRef = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:484: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       var removedConsumer: Consumer = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:140: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   nextElem.ne(null)
[warn]       if (nextElem ne null) {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:196: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   event.ne(null)
[warn]       while (event ne null) {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:428: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BroadcastSinkLogic.this.queue.update(BroadcastSinkLogic.this.head.&(BroadcastHub.this.Mask), null)
[warn]                 queue(head & Mask) = null
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:513: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   BroadcastSinkLogic.this.queue.update(BroadcastSinkLogic.this.head.&(BroadcastHub.this.Mask), null)
[warn]           queue(head & Mask) = null
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:662: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.hubCallback.ne(null)
[warn]           if (hubCallback ne null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:487: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   consumersInSlot.head
[warn]         val consumer = consumersInSlot.head
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:490: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   consumersInSlot.tail
[warn]         consumersInSlot = consumersInSlot.tail
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Hub.scala:96: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (producerCount).
[warn]   final class MergedSourceLogic(_shape: Shape, producerCount: AtomicLong) extends GraphStageLogic(_shape) with OutHandler {
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Materialization.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Keep.this._left.asInstanceOf[(L, R) => L]
[warn]   def left[L, R]: (L, R) ? L = _left.asInstanceOf[(L, R) ? L]
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Materialization.scala:21: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Keep.this._right.asInstanceOf[(L, R) => R]
[warn]   def right[L, R]: (L, R) ? R = _right.asInstanceOf[(L, R) ? R]
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Materialization.scala:22: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Keep.this._both.asInstanceOf[(L, R) => (L, R)]
[warn]   def both[L, R]: (L, R) ? (L, R) = _both.asInstanceOf[(L, R) ? (L, R)]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Materialization.scala:23: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Keep.this._none.asInstanceOf[(L, R) => akka.NotUsed]
[warn]   def none[L, R]: (L, R) ? NotUsed = _none.asInstanceOf[(L, R) ? NotUsed]
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Sink.scala:29: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Sink.this.module.shape.asInstanceOf[akka.stream.SinkShape[In]]
[warn]   override val shape: SinkShape[In] = module.shape.asInstanceOf[SinkShape[In]]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Sink.scala:54: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[Any => Any]
[warn]     new Sink(module.transformMaterializedValue(f.asInstanceOf[Any ? Any]))
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Source.scala:39: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Source.this.module.shape.asInstanceOf[akka.stream.SourceShape[Out]]
[warn]   override val shape: SourceShape[Out] = module.shape.asInstanceOf[SourceShape[Out]]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Source.scala:46: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[akka.stream.scaladsl.Source[T,Mat3]]
[warn]     if (flow.module eq GraphStages.Identity.module) this.asInstanceOf[Source[T, Mat3]]
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Source.scala:75: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[Any => Any]
[warn]     new Source[Out, Mat2](module.transformMaterializedValue(f.asInstanceOf[Any ? Any]))
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Source.scala:52: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   flowCopy.shape.outlets.head
[warn]           .replaceShape(SourceShape(flowCopy.shape.outlets.head)))
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Source.scala:68: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   sinkCopy.shape.inlets.head
[warn]     RunnableGraph(module.fuse(sinkCopy, shape.out, sinkCopy.shape.inlets.head, combine))
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:111: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   collectorFactory.apply().asInstanceOf[java.util.stream.Collector[T,Any,R]]
[warn]       new CollectorState[T, R](collectorFactory().asInstanceOf[Collector[T, Any, R]])) { (state, elem) ? () ? state().update(elem) }
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:130: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   collectorFactory.apply().asInstanceOf[java.util.stream.Collector[T,Any,R]]
[warn]         val collector = collectorFactory().asInstanceOf[Collector[T, Any, R]]
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:169: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           var nextElement: Option[T] = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:177: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   $anon.this.nextElement.get
[warn]             val next = nextElement.get
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:181: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = queue.cancel()
[warn]         }, 0), false).onClose(new Runnable { def run = queue.cancel() }))
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:109: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type T
[warn]   def javaCollector[T, R](collectorFactory: () ? java.util.stream.Collector[T, _ <: Any, R]): Sink[T, Future[R]] =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:109: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type R
[warn]   def javaCollector[T, R](collectorFactory: () ? java.util.stream.Collector[T, _ <: Any, R]): Sink[T, Future[R]] =
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:125: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type T
[warn]   def javaCollectorParallelUnordered[T, R](parallelism: Int)(collectorFactory: () ? java.util.stream.Collector[T, _ <: Any, R]): Sink[T, Future[R]] = {
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\StreamConverters.scala:125: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type R
[warn]   def javaCollectorParallelUnordered[T, R](parallelism: Int)(collectorFactory: () ? java.util.stream.Collector[T, _ <: Any, R]): Sink[T, Future[R]] = {
[warn]                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\scaladsl\Tcp.scala:56: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.stream.scaladsl.Tcp = Tcp.super.get(system)
[info]   override def get(system: ActorSystem): Tcp = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:136: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.underlying.asInstanceOf[akka.actor.ActorCell]
[warn]       case ref: RepointableActorRef if ref.isStarted ? ref.underlying.asInstanceOf[ActorCell]
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:312: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GraphStageLogic.this.handlers.apply(in.id).asInstanceOf[akka.stream.stage.InHandler]
[warn]     handlers(in.id).asInstanceOf[InHandler]
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:330: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GraphStageLogic.this.handlers.apply(out.id.+(GraphStageLogic.this.inCount)).asInstanceOf[akka.stream.stage.OutHandler]
[warn]     handlers(out.id + inCount).asInstanceOf[OutHandler]
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:389: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[AnyRef]
[warn]     if ((connection.portState & (InReady | InFailed)) == InReady && (elem.asInstanceOf[AnyRef] ne Empty)) {
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:391: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[T]
[warn]       elem.asInstanceOf[T]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:395: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   connection.slot.asInstanceOf[akka.stream.impl.fusing.GraphInterpreter.Failed]
[warn]       val failed = connection.slot.asInstanceOf[Failed]
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:396: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   failed.previousElem.asInstanceOf[T]
[warn]       val elem = failed.previousElem.asInstanceOf[T]
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:420: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   connection.slot.asInstanceOf[AnyRef]
[warn]     if (normalArrived) connection.slot.asInstanceOf[AnyRef] ne Empty
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:425: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[AnyRef]
[warn]           case Failed(_, elem) ? elem.asInstanceOf[AnyRef] ne Empty
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:549: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   new Array[AnyRef](n).asInstanceOf[Array[T]]
[warn]       val result = new Array[AnyRef](n).asInstanceOf[Array[T]]
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:767: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.asInstanceOf[GraphStageLogic.this.Emitting[T]]
[warn]       case e: Emitting[_] ? e.asInstanceOf[Emitting[T]].addFollowUp(next)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:774: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[GraphStageLogic.this.Emitting[U]]
[warn]     private def as[U] = this.asInstanceOf[Emitting[U]]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:885: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[Any => Unit]
[warn]         interpreter.onAsyncInput(GraphStageLogic.this, event, handler.asInstanceOf[Any ? Unit])
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:974: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]     private var elem: T = null.asInstanceOf[T]
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:981: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.asInstanceOf[T]
[warn]           elem = e.asInstanceOf[T]
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1006: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       elem = null.asInstanceOf[T]
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:449: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   elem.!=(null)
[warn]     if ((portState & (OutReady | OutClosed | InClosed)) == OutReady && (elem != null)) {
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:997: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   SubSinkInlet.this.elem.!=(null)
[warn]     def isAvailable: Boolean = elem != null
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1004: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   SubSinkInlet.this.elem.!=(null)
[warn]       require(elem != null, s"cannot grab element from port ($this) when data have not yet arrived")
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:56: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info]   final case class StageActorRefNotInitializedException()
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1313: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class NotInitialized(list: List[T]) extends CallbackState
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1314: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class Initialized(f: T ? Unit) extends CallbackState
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1315: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class Stopped(f: T ? Unit) extends CallbackState
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:625: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GraphStageLogic.this.getHandler(in).isInstanceOf[GraphStageLogic.this.Reading[_]]
[warn]     if (getHandler(in).isInstanceOf[Reading[_]])
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:784: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   next.isInstanceOf[GraphStageLogic.this.EmittingCompletion[_]]
[warn]             if (next.isInstanceOf[EmittingCompletion[_]]) complete(out)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:946: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       _stageActor = null
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1038: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private var handler: OutHandler = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:241: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphStageLogic.this._interpreter.==(null)
[warn]     if (_interpreter == null)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:297: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphStageLogic.this._interpreter.!=(null)
[warn]     if (_interpreter != null) _interpreter.setHandler(conn(in), handler)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:320: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphStageLogic.this._interpreter.!=(null)
[warn]     if (_interpreter != null) _interpreter.setHandler(conn(out), handler)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:779: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Emitting.this.followUps.!=(null)
[warn]       if (followUps != null) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:791: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Emitting.this.followUps.==(null)
[warn]       if (followUps == null) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:800: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Emitting.this.followUps.==(null)
[warn]       if (followUps == null) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:865: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphStageLogic.this._interpreter.!=(null)
[warn]     if (_interpreter != null) {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:944: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   GraphStageLogic.this._stageActor.ne(null)
[warn]     if (_stageActor ne null) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1140: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TimerGraphStageLogic.this._timerAsyncCallback.eq(null)
[warn]     if (_timerAsyncCallback eq null)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1168: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TimerGraphStageLogic.this.keyToTimers.ne(null)
[warn]     if (keyToTimers ne null) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:33: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val attr: akka.stream.Attributes = _
[warn]     override def withAttributes(attr: Attributes) = GraphStageWithMaterializedValue.this.withAttributes(attr)
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:396: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val elem: T = failed.previousElem.asInstanceOf[T]
[warn]       val elem = failed.previousElem.asInstanceOf[T]
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:995: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val handler: akka.stream.stage.InHandler = _
[warn]     def setHandler(handler: InHandler): Unit = this.handler = handler
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\GraphStage.scala:1073: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val handler: akka.stream.stage.OutHandler = _
[warn]     def setHandler(handler: OutHandler): Unit = this.handler = handler
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:79: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PushPullGraphLogic.this.currentStage.restart().asInstanceOf[akka.stream.stage.AbstractStage[In,Out,akka.stream.stage.Directive,akka.stream.stage.Directive,akka.stream.stage.Context[Out],akka.stream.stage.LifecycleContext]]
[warn]           currentStage = currentStage.restart().asInstanceOf[AbstractStage[In, Out, Directive, Directive, Context[Out], LifecycleContext]]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:179: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   stageAndMat._1.asInstanceOf[akka.stream.stage.AbstractStage[In,Out,akka.stream.stage.Directive,akka.stream.stage.Directive,akka.stream.stage.Context[Out],akka.stream.stage.LifecycleContext]]
[warn]         stageAndMat._1.asInstanceOf[AbstractStage[In, Out, Directive, Directive, Context[Out], LifecycleContext]]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:493: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   nextState.asInstanceOf[akka.stream.stage.StageState[Any,Any]]
[warn]         become(emittingState(iter, andThen = Become(nextState.asInstanceOf[StageState[Any, Any]])))
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:579: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   newState.asInstanceOf[akka.stream.stage.StageState[In,Out]]
[warn]             case Become(newState) ? become(newState.asInstanceOf[StageState[In, Out]])
[warn]                                                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:568: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class EmittingState(iter: Iterator[Out], andThen: AndThen) extends State {
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:596: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait AsyncDirective extends Directive
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:602: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed abstract class FreeDirective private () extends UpstreamDirective with DownstreamDirective with TerminationDirective with AsyncDirective
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:599: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait DownstreamDirective extends SyncDirective
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:600: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait TerminationDirective extends SyncDirective
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:598: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait UpstreamDirective extends SyncDirective
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:597: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait SyncDirective extends Directive
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:595: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait Directive
[warn]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\stage\Stage.scala:386: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def decide(t: Throwable): akka.stream.Supervision.Directive = DetachedStage.super.decide(t)
[info]   override def decide(t: Throwable): Supervision.Directive = super.decide(t)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:37: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape.this._registered.next().asInstanceOf[akka.stream.Inlet[T]]
[warn]     val p = if (_registered.hasNext) _registered.next().asInstanceOf[Inlet[T]] else Inlet[T](s"${_name}.$name")
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:48: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   outlets.head.asInstanceOf[akka.stream.Outlet[O]]
[warn]     construct(Ports[O](outlets.head.asInstanceOf[Outlet[O]], inlets))
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:62: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   UniformFanInShape.super.deepCopy().asInstanceOf[akka.stream.UniformFanInShape[T,O]]
[warn]   override def deepCopy(): UniformFanInShape[T, O] = super.deepCopy().asInstanceOf[UniformFanInShape[T, O]]
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:73: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape1N.super.deepCopy().asInstanceOf[akka.stream.FanInShape1N[T0,T1,O]]
[warn]   override def deepCopy(): FanInShape1N[T0, T1, O] = super.deepCopy().asInstanceOf[FanInShape1N[T0, T1, O]]
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:87: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape2.super.deepCopy().asInstanceOf[akka.stream.FanInShape2[T0,T1,O]]
[warn]   override def deepCopy(): FanInShape2[T0, T1, O] = super.deepCopy().asInstanceOf[FanInShape2[T0, T1, O]]
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:97: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape3.super.deepCopy().asInstanceOf[akka.stream.FanInShape3[T0,T1,T2,O]]
[warn]   override def deepCopy(): FanInShape3[T0, T1, T2, O] = super.deepCopy().asInstanceOf[FanInShape3[T0, T1, T2, O]]
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:108: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape4.super.deepCopy().asInstanceOf[akka.stream.FanInShape4[T0,T1,T2,T3,O]]
[warn]   override def deepCopy(): FanInShape4[T0, T1, T2, T3, O] = super.deepCopy().asInstanceOf[FanInShape4[T0, T1, T2, T3, O]]
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:120: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape5.super.deepCopy().asInstanceOf[akka.stream.FanInShape5[T0,T1,T2,T3,T4,O]]
[warn]   override def deepCopy(): FanInShape5[T0, T1, T2, T3, T4, O] = super.deepCopy().asInstanceOf[FanInShape5[T0, T1, T2, T3, T4, O]]
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:133: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape6.super.deepCopy().asInstanceOf[akka.stream.FanInShape6[T0,T1,T2,T3,T4,T5,O]]
[warn]   override def deepCopy(): FanInShape6[T0, T1, T2, T3, T4, T5, O] = super.deepCopy().asInstanceOf[FanInShape6[T0, T1, T2, T3, T4, T5, O]]
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:147: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape7.super.deepCopy().asInstanceOf[akka.stream.FanInShape7[T0,T1,T2,T3,T4,T5,T6,O]]
[warn]   override def deepCopy(): FanInShape7[T0, T1, T2, T3, T4, T5, T6, O] = super.deepCopy().asInstanceOf[FanInShape7[T0, T1, T2, T3, T4, T5, T6, O]]
[warn]                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:162: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape8.super.deepCopy().asInstanceOf[akka.stream.FanInShape8[T0,T1,T2,T3,T4,T5,T6,T7,O]]
[warn]   override def deepCopy(): FanInShape8[T0, T1, T2, T3, T4, T5, T6, T7, O] = super.deepCopy().asInstanceOf[FanInShape8[T0, T1, T2, T3, T4, T5, T6, T7, O]]
[warn]                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:178: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape9.super.deepCopy().asInstanceOf[akka.stream.FanInShape9[T0,T1,T2,T3,T4,T5,T6,T7,T8,O]]
[warn]   override def deepCopy(): FanInShape9[T0, T1, T2, T3, T4, T5, T6, T7, T8, O] = super.deepCopy().asInstanceOf[FanInShape9[T0, T1, T2, T3, T4, T5, T6, T7, T8, O]]
[warn]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:195: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape10.super.deepCopy().asInstanceOf[akka.stream.FanInShape10[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,O]]
[warn]   override def deepCopy(): FanInShape10[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, O] = super.deepCopy().asInstanceOf[FanInShape10[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, O]]
[warn]                                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:213: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape11.super.deepCopy().asInstanceOf[akka.stream.FanInShape11[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,O]]
[warn]   override def deepCopy(): FanInShape11[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O] = super.deepCopy().asInstanceOf[FanInShape11[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, O]]
[warn]                                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:232: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape12.super.deepCopy().asInstanceOf[akka.stream.FanInShape12[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,O]]
[warn]   override def deepCopy(): FanInShape12[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, O] = super.deepCopy().asInstanceOf[FanInShape12[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, O]]
[warn]                                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:252: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape13.super.deepCopy().asInstanceOf[akka.stream.FanInShape13[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,O]]
[warn]   override def deepCopy(): FanInShape13[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, O] = super.deepCopy().asInstanceOf[FanInShape13[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, O]]
[warn]                                                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:273: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape14.super.deepCopy().asInstanceOf[akka.stream.FanInShape14[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,O]]
[warn]   override def deepCopy(): FanInShape14[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, O] = super.deepCopy().asInstanceOf[FanInShape14[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, O]]
[warn]                                                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:295: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape15.super.deepCopy().asInstanceOf[akka.stream.FanInShape15[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,O]]
[warn]   override def deepCopy(): FanInShape15[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, O] = super.deepCopy().asInstanceOf[FanInShape15[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, O]]
[warn]                                                                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:318: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape16.super.deepCopy().asInstanceOf[akka.stream.FanInShape16[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,O]]
[warn]   override def deepCopy(): FanInShape16[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, O] = super.deepCopy().asInstanceOf[FanInShape16[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, O]]
[warn]                                                                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:342: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape17.super.deepCopy().asInstanceOf[akka.stream.FanInShape17[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,O]]
[warn]   override def deepCopy(): FanInShape17[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, O] = super.deepCopy().asInstanceOf[FanInShape17[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, O]]
[warn]                                                                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:367: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape18.super.deepCopy().asInstanceOf[akka.stream.FanInShape18[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,O]]
[warn]   override def deepCopy(): FanInShape18[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, O] = super.deepCopy().asInstanceOf[FanInShape18[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, O]]
[warn]                                                                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:393: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape19.super.deepCopy().asInstanceOf[akka.stream.FanInShape19[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,O]]
[warn]   override def deepCopy(): FanInShape19[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, O] = super.deepCopy().asInstanceOf[FanInShape19[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, O]]
[warn]                                                                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:420: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape20.super.deepCopy().asInstanceOf[akka.stream.FanInShape20[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,O]]
[warn]   override def deepCopy(): FanInShape20[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, O] = super.deepCopy().asInstanceOf[FanInShape20[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, O]]
[warn]                                                                                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:448: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape21.super.deepCopy().asInstanceOf[akka.stream.FanInShape21[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,O]]
[warn]   override def deepCopy(): FanInShape21[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, O] = super.deepCopy().asInstanceOf[FanInShape21[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, O]]
[warn]                                                                                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:477: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanInShape22.super.deepCopy().asInstanceOf[akka.stream.FanInShape22[T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,O]]
[warn]   override def deepCopy(): FanInShape22[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, O] = super.deepCopy().asInstanceOf[FanInShape22[T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, O]]
[warn]                                                                                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:65: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val n: Int = _
[warn]   def in(n: Int): Inlet[T @uncheckedVariance] = inSeq(n)
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanInShape.scala:77: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val n: Int = _
[warn]   def in(n: Int): Inlet[T1 @uncheckedVariance] = {
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:36: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape.this._registered.next().asInstanceOf[akka.stream.Outlet[T]]
[warn]     val p = if (_registered.hasNext) _registered.next().asInstanceOf[Outlet[T]] else Outlet[T](s"${_name}.$name")
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:47: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   inlets.head.asInstanceOf[akka.stream.Inlet[I]]
[warn]     construct(Ports[I](inlets.head.asInstanceOf[Inlet[I]], outlets))
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:61: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   UniformFanOutShape.super.deepCopy().asInstanceOf[akka.stream.UniformFanOutShape[I,O]]
[warn]   override def deepCopy(): UniformFanOutShape[I, O] = super.deepCopy().asInstanceOf[UniformFanOutShape[I, O]]
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:71: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape2.super.deepCopy().asInstanceOf[akka.stream.FanOutShape2[I,O0,O1]]
[warn]   override def deepCopy(): FanOutShape2[I, O0, O1] = super.deepCopy().asInstanceOf[FanOutShape2[I, O0, O1]]
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:81: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape3.super.deepCopy().asInstanceOf[akka.stream.FanOutShape3[I,O0,O1,O2]]
[warn]   override def deepCopy(): FanOutShape3[I, O0, O1, O2] = super.deepCopy().asInstanceOf[FanOutShape3[I, O0, O1, O2]]
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:92: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape4.super.deepCopy().asInstanceOf[akka.stream.FanOutShape4[I,O0,O1,O2,O3]]
[warn]   override def deepCopy(): FanOutShape4[I, O0, O1, O2, O3] = super.deepCopy().asInstanceOf[FanOutShape4[I, O0, O1, O2, O3]]
[warn]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:104: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape5.super.deepCopy().asInstanceOf[akka.stream.FanOutShape5[I,O0,O1,O2,O3,O4]]
[warn]   override def deepCopy(): FanOutShape5[I, O0, O1, O2, O3, O4] = super.deepCopy().asInstanceOf[FanOutShape5[I, O0, O1, O2, O3, O4]]
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:117: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape6.super.deepCopy().asInstanceOf[akka.stream.FanOutShape6[I,O0,O1,O2,O3,O4,O5]]
[warn]   override def deepCopy(): FanOutShape6[I, O0, O1, O2, O3, O4, O5] = super.deepCopy().asInstanceOf[FanOutShape6[I, O0, O1, O2, O3, O4, O5]]
[warn]                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:131: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape7.super.deepCopy().asInstanceOf[akka.stream.FanOutShape7[I,O0,O1,O2,O3,O4,O5,O6]]
[warn]   override def deepCopy(): FanOutShape7[I, O0, O1, O2, O3, O4, O5, O6] = super.deepCopy().asInstanceOf[FanOutShape7[I, O0, O1, O2, O3, O4, O5, O6]]
[warn]                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:146: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape8.super.deepCopy().asInstanceOf[akka.stream.FanOutShape8[I,O0,O1,O2,O3,O4,O5,O6,O7]]
[warn]   override def deepCopy(): FanOutShape8[I, O0, O1, O2, O3, O4, O5, O6, O7] = super.deepCopy().asInstanceOf[FanOutShape8[I, O0, O1, O2, O3, O4, O5, O6, O7]]
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:162: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape9.super.deepCopy().asInstanceOf[akka.stream.FanOutShape9[I,O0,O1,O2,O3,O4,O5,O6,O7,O8]]
[warn]   override def deepCopy(): FanOutShape9[I, O0, O1, O2, O3, O4, O5, O6, O7, O8] = super.deepCopy().asInstanceOf[FanOutShape9[I, O0, O1, O2, O3, O4, O5, O6, O7, O8]]
[warn]                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:179: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape10.super.deepCopy().asInstanceOf[akka.stream.FanOutShape10[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9]]
[warn]   override def deepCopy(): FanOutShape10[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9] = super.deepCopy().asInstanceOf[FanOutShape10[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9]]
[warn]                                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:197: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape11.super.deepCopy().asInstanceOf[akka.stream.FanOutShape11[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10]]
[warn]   override def deepCopy(): FanOutShape11[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10] = super.deepCopy().asInstanceOf[FanOutShape11[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]]
[warn]                                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:216: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape12.super.deepCopy().asInstanceOf[akka.stream.FanOutShape12[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11]]
[warn]   override def deepCopy(): FanOutShape12[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11] = super.deepCopy().asInstanceOf[FanOutShape12[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11]]
[warn]                                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:236: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape13.super.deepCopy().asInstanceOf[akka.stream.FanOutShape13[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12]]
[warn]   override def deepCopy(): FanOutShape13[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12] = super.deepCopy().asInstanceOf[FanOutShape13[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12]]
[warn]                                                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:257: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape14.super.deepCopy().asInstanceOf[akka.stream.FanOutShape14[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13]]
[warn]   override def deepCopy(): FanOutShape14[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13] = super.deepCopy().asInstanceOf[FanOutShape14[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13]]
[warn]                                                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:279: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape15.super.deepCopy().asInstanceOf[akka.stream.FanOutShape15[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13,O14]]
[warn]   override def deepCopy(): FanOutShape15[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14] = super.deepCopy().asInstanceOf[FanOutShape15[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14]]
[warn]                                                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:302: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape16.super.deepCopy().asInstanceOf[akka.stream.FanOutShape16[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13,O14,O15]]
[warn]   override def deepCopy(): FanOutShape16[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15] = super.deepCopy().asInstanceOf[FanOutShape16[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15]]
[warn]                                                                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:326: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape17.super.deepCopy().asInstanceOf[akka.stream.FanOutShape17[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13,O14,O15,O16]]
[warn]   override def deepCopy(): FanOutShape17[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16] = super.deepCopy().asInstanceOf[FanOutShape17[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16]]
[warn]                                                                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:351: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape18.super.deepCopy().asInstanceOf[akka.stream.FanOutShape18[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13,O14,O15,O16,O17]]
[warn]   override def deepCopy(): FanOutShape18[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17] = super.deepCopy().asInstanceOf[FanOutShape18[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17]]
[warn]                                                                                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:377: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape19.super.deepCopy().asInstanceOf[akka.stream.FanOutShape19[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13,O14,O15,O16,O17,O18]]
[warn]   override def deepCopy(): FanOutShape19[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18] = super.deepCopy().asInstanceOf[FanOutShape19[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18]]
[warn]                                                                                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:404: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape20.super.deepCopy().asInstanceOf[akka.stream.FanOutShape20[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13,O14,O15,O16,O17,O18,O19]]
[warn]   override def deepCopy(): FanOutShape20[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19] = super.deepCopy().asInstanceOf[FanOutShape20[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19]]
[warn]                                                                                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:432: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape21.super.deepCopy().asInstanceOf[akka.stream.FanOutShape21[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13,O14,O15,O16,O17,O18,O19,O20]]
[warn]   override def deepCopy(): FanOutShape21[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20] = super.deepCopy().asInstanceOf[FanOutShape21[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20]]
[warn]                                                                                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:461: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FanOutShape22.super.deepCopy().asInstanceOf[akka.stream.FanOutShape22[I,O0,O1,O2,O3,O4,O5,O6,O7,O8,O9,O10,O11,O12,O13,O14,O15,O16,O17,O18,O19,O20,O21]]
[warn]   override def deepCopy(): FanOutShape22[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20, O21] = super.deepCopy().asInstanceOf[FanOutShape22[I, O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20, O21]]
[warn]                                                                                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\FanOutShape.scala:64: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val n: Int = _
[warn]   def out(n: Int): Outlet[O @uncheckedVariance] = outArray(n)
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:87: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create9[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], combineMat: function.Function9[M1, M2, M3, M4, M5, M6, M7, M8, M9, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:95: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create10[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], combineMat: function.Function10[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:103: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create11[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], combineMat: function.Function11[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:111: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create12[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], combineMat: function.Function12[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:119: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create13[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], combineMat: function.Function13[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:127: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create14[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S14 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], g14: Graph[S14, M14], combineMat: function.Function14[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:135: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create15[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S14 <: Shape, S15 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], g14: Graph[S14, M14], g15: Graph[S15, M15], combineMat: function.Function15[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:143: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create16[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S14 <: Shape, S15 <: Shape, S16 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], g14: Graph[S14, M14], g15: Graph[S15, M15], g16: Graph[S16, M16], combineMat: function.Function16[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:151: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create17[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S14 <: Shape, S15 <: Shape, S16 <: Shape, S17 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], g14: Graph[S14, M14], g15: Graph[S15, M15], g16: Graph[S16, M16], g17: Graph[S17, M17], combineMat: function.Function17[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:159: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create18[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S14 <: Shape, S15 <: Shape, S16 <: Shape, S17 <: Shape, S18 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], g14: Graph[S14, M14], g15: Graph[S15, M15], g16: Graph[S16, M16], g17: Graph[S17, M17], g18: Graph[S18, M18], combineMat: function.Function18[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:167: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create19[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S14 <: Shape, S15 <: Shape, S16 <: Shape, S17 <: Shape, S18 <: Shape, S19 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], g14: Graph[S14, M14], g15: Graph[S15, M15], g16: Graph[S16, M16], g17: Graph[S17, M17], g18: Graph[S18, M18], g19: Graph[S19, M19], combineMat: function.Function19[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:175: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create20[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S14 <: Shape, S15 <: Shape, S16 <: Shape, S17 <: Shape, S18 <: Shape, S19 <: Shape, S20 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], g14: Graph[S14, M14], g15: Graph[S15, M15], g16: Graph[S16, M16], g17: Graph[S17, M17], g18: Graph[S18, M18], g19: Graph[S19, M19], g20: Graph[S20, M20], combineMat: function.Function20[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\javadsl\GraphCreate.scala:183: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create21[S1 <: Shape, S2 <: Shape, S3 <: Shape, S4 <: Shape, S5 <: Shape, S6 <: Shape, S7 <: Shape, S8 <: Shape, S9 <: Shape, S10 <: Shape, S11 <: Shape, S12 <: Shape, S13 <: Shape, S14 <: Shape, S15 <: Shape, S16 <: Shape, S17 <: Shape, S18 <: Shape, S19 <: Shape, S20 <: Shape, S21 <: Shape, S <: Shape, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M21, M](g1: Graph[S1, M1], g2: Graph[S2, M2], g3: Graph[S3, M3], g4: Graph[S4, M4], g5: Graph[S5, M5], g6: Graph[S6, M6], g7: Graph[S7, M7], g8: Graph[S8, M8], g9: Graph[S9, M9], g10: Graph[S10, M10], g11: Graph[S11, M11], g12: Graph[S12, M12], g13: Graph[S13, M13], g14: Graph[S14, M14], g15: Graph[S15, M15], g16: Graph[S16, M16], g17: Graph[S17, M17], g18: Graph[S18, M18], g19: Graph[S19, M19], g20: Graph[S20, M20], g21: Graph[S21, M21], combineMat: function.Function21[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M21, M],
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:184: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:208: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:233: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:259: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:286: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:314: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:343: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14], g15: Graph[Shape, M15])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape, g15.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:373: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14], g15: Graph[Shape, M15], g16: Graph[Shape, M16])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape, g15.Shape, g16.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:404: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14], g15: Graph[Shape, M15], g16: Graph[Shape, M16], g17: Graph[Shape, M17])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape, g15.Shape, g16.Shape, g17.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:436: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14], g15: Graph[Shape, M15], g16: Graph[Shape, M16], g17: Graph[Shape, M17], g18: Graph[Shape, M18])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape, g15.Shape, g16.Shape, g17.Shape, g18.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:469: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14], g15: Graph[Shape, M15], g16: Graph[Shape, M16], g17: Graph[Shape, M17], g18: Graph[Shape, M18], g19: Graph[Shape, M19])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape, g15.Shape, g16.Shape, g17.Shape, g18.Shape, g19.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:503: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14], g15: Graph[Shape, M15], g16: Graph[Shape, M16], g17: Graph[Shape, M17], g18: Graph[Shape, M18], g19: Graph[Shape, M19], g20: Graph[Shape, M20])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape, g15.Shape, g16.Shape, g17.Shape, g18.Shape, g19.Shape, g20.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:538: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M21](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14], g15: Graph[Shape, M15], g16: Graph[Shape, M16], g17: Graph[Shape, M17], g18: Graph[Shape, M18], g19: Graph[Shape, M19], g20: Graph[Shape, M20], g21: Graph[Shape, M21])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M21) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape, g15.Shape, g16.Shape, g17.Shape, g18.Shape, g19.Shape, g20.Shape, g21.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\GraphApply.scala:574: [scapegoat] Max parameters
[info]   Methods having a large number of parameters are more difficult to reason about, consider refactoring this code.
[info]   def create[S <: Shape, Mat, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M21, M22](g1: Graph[Shape, M1], g2: Graph[Shape, M2], g3: Graph[Shape, M3], g4: Graph[Shape, M4], g5: Graph[Shape, M5], g6: Graph[Shape, M6], g7: Graph[Shape, M7], g8: Graph[Shape, M8], g9: Graph[Shape, M9], g10: Graph[Shape, M10], g11: Graph[Shape, M11], g12: Graph[Shape, M12], g13: Graph[Shape, M13], g14: Graph[Shape, M14], g15: Graph[Shape, M15], g16: Graph[Shape, M16], g17: Graph[Shape, M17], g18: Graph[Shape, M18], g19: Graph[Shape, M19], g20: Graph[Shape, M20], g21: Graph[Shape, M21], g22: Graph[Shape, M22])(combineMat: (M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14, M15, M16, M17, M18, M19, M20, M21, M22) ? Mat)(buildBlock: GraphDSL.Builder[Mat] ? (g1.Shape, g2.Shape, g3.Shape, g4.Shape, g5.Shape, g6.Shape, g7.Shape, g8.Shape, g9.Shape, g10.Shape, g11.Shape, g12.Shape, g13.Shape, g14.Shape, g15.Shape, g16.Shape, g17.Shape, g18.Shape, g19.Shape, g20.Shape, g21.Shape, g22.Shape) ? S): Graph[S, Mat] = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:181: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator2[In,A1,A2]]
[warn]      creator.asInstanceOf[UnzipWithCreator2[In, A1, A2]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:190: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator3[In,A1,A2,A3]]
[warn]      creator.asInstanceOf[UnzipWithCreator3[In, A1, A2, A3]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:199: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator4[In,A1,A2,A3,A4]]
[warn]      creator.asInstanceOf[UnzipWithCreator4[In, A1, A2, A3, A4]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:208: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator5[In,A1,A2,A3,A4,A5]]
[warn]      creator.asInstanceOf[UnzipWithCreator5[In, A1, A2, A3, A4, A5]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:217: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator6[In,A1,A2,A3,A4,A5,A6]]
[warn]      creator.asInstanceOf[UnzipWithCreator6[In, A1, A2, A3, A4, A5, A6]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:226: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator7[In,A1,A2,A3,A4,A5,A6,A7]]
[warn]      creator.asInstanceOf[UnzipWithCreator7[In, A1, A2, A3, A4, A5, A6, A7]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:235: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator8[In,A1,A2,A3,A4,A5,A6,A7,A8]]
[warn]      creator.asInstanceOf[UnzipWithCreator8[In, A1, A2, A3, A4, A5, A6, A7, A8]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:244: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator9[In,A1,A2,A3,A4,A5,A6,A7,A8,A9]]
[warn]      creator.asInstanceOf[UnzipWithCreator9[In, A1, A2, A3, A4, A5, A6, A7, A8, A9]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:253: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator10[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10]]
[warn]      creator.asInstanceOf[UnzipWithCreator10[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:262: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator11[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11]]
[warn]      creator.asInstanceOf[UnzipWithCreator11[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:271: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator12[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12]]
[warn]      creator.asInstanceOf[UnzipWithCreator12[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:280: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator13[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13]]
[warn]      creator.asInstanceOf[UnzipWithCreator13[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:289: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator14[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14]]
[warn]      creator.asInstanceOf[UnzipWithCreator14[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:298: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator15[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15]]
[warn]      creator.asInstanceOf[UnzipWithCreator15[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:307: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator16[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16]]
[warn]      creator.asInstanceOf[UnzipWithCreator16[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:316: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator17[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16,A17]]
[warn]      creator.asInstanceOf[UnzipWithCreator17[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:325: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator18[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16,A17,A18]]
[warn]      creator.asInstanceOf[UnzipWithCreator18[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:334: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator19[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16,A17,A18,A19]]
[warn]      creator.asInstanceOf[UnzipWithCreator19[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19]].create(unzipper)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\target\src_managed\main\akka\stream\scaladsl\UnzipWithApply.scala:343: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   creator.asInstanceOf[akka.stream.scaladsl.UnzipWithApply.UnzipWithCreator20[In,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16,A17,A18,A19,A20]]
[warn]      creator.asInstanceOf[UnzipWithCreator20[In, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20]].create(unzipper)
[warn]                          ^
[info] [warn] [scapegoat] Analysis complete: 115 files - 0 errors 690 warns 126 infos
[warn] non-nullary method overrides nullary method
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream\src\main\scala\akka\stream\impl\StreamLayout.scala:707: The outer reference in this type test cannot be checked at run time.
[warn]     final case class Buffering(demand: Long) extends SubscriptionState
[warn]                      ^
[warn] there were 19 deprecation warnings; re-run with -deprecation for details
[warn] 666 warnings found
[info] Compiling 12 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:248: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   if (false)

[warn]     scala.this.Predef.println(scala.this.Predef.any2stringadd[akka.actor.InternalActorRef](mbox.actor.self).+(" processing message ").+(handle))

[warn]   else

[warn]     ();

[warn]   mbox.actor.invoke(handle);

[warn]   intex = checkThreadInterruption(intex);

[warn]   true

[warn] } catch {

[warn]   case (ie @ (_: Interru
[warn]           try {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:273: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   mbox.ctdLock.tryLock(50L, MILLISECONDS)

[warn] } catch {

[warn]   case (ie @ (_: InterruptedException)) => {

[warn]     java.this.lang.Thread.interrupted();

[warn]     intex = ie;

[warn]     false

[warn]   }

[warn] }
[warn]       val gotLock = try {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:222: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private def runQueue(mbox: CallingThreadMailbox, queue: MessageQueue, interruptedEx: InterruptedException = null) {
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:233: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ie.ne(null)
[warn]       if (ie ne null) {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:247: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   handle.ne(null)
[warn]         if (handle ne null) {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:309: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   CallingThreadMailbox.super.<init>(null)
[warn]   extends Mailbox(null) with DefaultSystemMessageQueue {
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:47: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.testkit.CallingThreadMailbox, Set[java.lang.ref.WeakReference[akka.dispatch.MessageQueue]]]()
[info]   private var queues = Map[CallingThreadMailbox, Set[WeakReference[MessageQueue]]]()
[info]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\CallingThreadDispatcher.scala:163: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val mbox: akka.testkit.CallingThreadMailbox = _
[warn]     mbox foreach CallingThreadDispatcherQueues(actor.system).unregisterQueues
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\SocketUtil.scala:27: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   SocketUtil.this.temporaryServerAddresses(1, address, udp).head
[warn]     temporaryServerAddresses(1, address, udp).head
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:42: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   _system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     _system.asInstanceOf[ActorSystemImpl],
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:46: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   _supervisor.asInstanceOf[akka.actor.InternalActorRef]
[warn]     _supervisor.asInstanceOf[InternalActorRef],
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:93: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any]({

[warn]   <artifact> val qual$2: akka.pattern.AskableActorRef = akka.pattern.`package`.ask(this);

[warn]   <artifact> val x$3: akka.testkit.TestActorRef.InternalGetActor.type = TestActorRef.InternalGetActor;

[warn]   <artifact> val x$4: akka.util.Timeout = t;

[warn]   <artifact> val x$5: akka.actor.ActorRef = qual$2.?$default$3(x$3);

[warn]   qual$2.?(x$3)(x$4, x$5)

[warn] }, t.duration).asInstanceOf[T]
[warn]         Await.result(this.?(InternalGetActor)(t), t.duration).asInstanceOf[T]
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:137: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     apply[T](props, system.asInstanceOf[ActorSystemImpl].guardian, name)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:140: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     val sysImpl = system.asInstanceOf[ActorSystemImpl]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:141: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   supervisor.asInstanceOf[akka.actor.InternalActorRef]
[warn]     new TestActorRef(sysImpl, props, supervisor.asInstanceOf[InternalActorRef], randomName)
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:145: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     val sysImpl = system.asInstanceOf[ActorSystemImpl]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:146: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   supervisor.asInstanceOf[akka.actor.InternalActorRef]
[warn]     new TestActorRef(sysImpl, props, supervisor.asInstanceOf[InternalActorRef], name)
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:161: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     system.asInstanceOf[ExtendedActorSystem].dynamicAccess
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:166: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     system.asInstanceOf[ExtendedActorSystem].dynamicAccess
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:171: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     system.asInstanceOf[ExtendedActorSystem]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:80: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   } finally underlying.currentMessage = null
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:152: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   akka.actor.ActorInitializationException.apply(null, "Could not instantiate Actor\nMake sure Actor is NOT defined inside a class/trait,\nif so put it outside the class/trait, f.e. in a companion object,\nOR try to change: \'actorOf(Props[MyActor]\' to \'actorOf(Props(new MyActor)\'.", exception)
[warn]     case exception ? throw ActorInitializationException(
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:162: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem].dynamicAccess.createInstanceFor[T](t.runtimeClass, immutable.this.Nil)(t).recover[T](TestActorRef.this.dynamicCreateRecover[Nothing]).get
[warn]       .createInstanceFor[T](t.runtimeClass, Nil).recover(dynamicCreateRecover).get
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:167: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem].dynamicAccess.createInstanceFor[T](t.runtimeClass, immutable.this.Nil)(t).recover[T](TestActorRef.this.dynamicCreateRecover[Nothing]).get
[warn]       .createInstanceFor[T](t.runtimeClass, Nil).recover(dynamicCreateRecover).get
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:172: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem].dynamicAccess.createInstanceFor[T](t.runtimeClass, immutable.this.Nil)(t).recover[T](TestActorRef.this.dynamicCreateRecover[Nothing]).get
[warn]       .dynamicAccess.createInstanceFor[T](t.runtimeClass, Nil).recover(dynamicCreateRecover).get
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:27: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val props: akka.actor.Props = _props.withDispatcher(if (_props.deploy.dispatcher.==(""))

[warn]   CallingThreadDispatcher.Id

[warn] else

[warn]   _props.dispatcher)
[warn]     val props =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:31: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val dispatcher: akka.dispatch.MessageDispatcher = _system.dispatchers.lookup(props.dispatcher)
[warn]     val dispatcher = _system.dispatchers.lookup(props.dispatcher)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:32: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private val disregard: AnyVal = _supervisor match {

[warn]   case (l @ (_: akka.actor.LocalActorRef)) => l.underlying.reserveChild(name)

[warn]   case (r @ (_: akka.actor.RepointableActorRef)) => r.underlying mat
[warn]     private val disregard = _supervisor match {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:54: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val props: akka.actor.Props = _
[warn]   protected override def newActorCell(system: ActorSystemImpl, ref: InternalActorRef, props: Props,
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestActorRef.scala:55: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val dispatcher: akka.dispatch.MessageDispatcher = _
[warn]                                       dispatcher: MessageDispatcher, supervisor: InternalActorRef): ActorCell =
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestBarrier.scala:35: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: java.util.concurrent.TimeoutException)) => throw new TestBarrierTimeoutException(scala
[warn]       case e: TimeoutException ?
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:466: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   t.runtimeClass.asInstanceOf[Class[T]]
[warn]     new DeadLettersFilter(t.runtimeClass.asInstanceOf[Class[T]])(Int.MaxValue)
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:524: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   f.apply(event)

[warn] } catch {

[warn]   case (e @ (_: Exception)) => false

[warn] }
[warn]   def filter(event: LogEvent): Boolean = filters exists (f ? try { f(event) } catch { case e: Exception ? false })
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:508: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.isInstanceOf[akka.dispatch.sysmsg.Terminate]
[warn]       if (!msg.isInstanceOf[Terminate]) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:512: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.isInstanceOf[akka.dispatch.sysmsg.SystemMessage]
[warn]             if (msg.isInstanceOf[SystemMessage]) "received dead system message: " + msg
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:174: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def apply[A <: Throwable: ClassTag](message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:174: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def apply[A <: Throwable: ClassTag](message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:174: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def apply[A <: Throwable: ClassTag](message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:183: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def error(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:183: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def error(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:183: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def error(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:202: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def warning(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:202: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def warning(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:202: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def warning(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:222: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def info(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:222: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def info(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:222: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def info(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:242: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def debug(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:242: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def debug(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:242: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def debug(message: String = null, source: String = null, start: String = "", pattern: String = null, occurrences: Int = Int.MaxValue): EventFilter =
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:131: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   msg.!=(null)
[warn]     val msgstr = if (msg != null) msg.toString else "null"
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:317: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ErrorFilter.this.<init>(throwable, null, null, false, false, 2147483647)
[warn]   def this(throwable: Class[_]) = this(throwable, null, null, false, false, Int.MaxValue)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestEventListener.scala:132: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   EventFilter.this.source.get
[warn]     (source.isDefined && source.get == src || source.isEmpty) &&
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:90: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     val impl = system.asInstanceOf[ActorSystemImpl]
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:91: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   impl.guardian.asInstanceOf[akka.actor.InternalActorRef]
[warn]     new TestFSMRef(impl, Props(factory), impl.guardian.asInstanceOf[InternalActorRef], TestActorRef.randomName)
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:95: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     val impl = system.asInstanceOf[ActorSystemImpl]
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:96: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   impl.guardian.asInstanceOf[akka.actor.InternalActorRef]
[warn]     new TestFSMRef(impl, Props(factory), impl.guardian.asInstanceOf[InternalActorRef], name)
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:100: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     val impl = system.asInstanceOf[ActorSystemImpl]
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:101: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   supervisor.asInstanceOf[akka.actor.InternalActorRef]
[warn]     new TestFSMRef(impl, Props(factory), supervisor.asInstanceOf[InternalActorRef], name)
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:105: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     val impl = system.asInstanceOf[ActorSystemImpl]
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:106: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   supervisor.asInstanceOf[akka.actor.InternalActorRef]
[warn]     new TestFSMRef(impl, Props(factory), supervisor.asInstanceOf[InternalActorRef], TestActorRef.randomName)
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:60: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def setState(stateName: S = fsm.stateName, stateData: D = fsm.stateData, timeout: FiniteDuration = null, stopReason: Option[FSM.Reason] = None) {
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:67: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   def setTimer(name: String, msg: Any, timeout: FiniteDuration, repeat: Boolean = false) {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:74: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   def cancelTimer(name: String) { fsm.cancelTimer(name) }
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestFSMRef.scala:79: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   def isTimerActive(name: String) = fsm.isTimerActive(name)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:162: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TestKitBase.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val impl = system.asInstanceOf[ExtendedActorSystem]
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:389: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[T]
[warn]     o.asInstanceOf[T]
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:445: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   t.runtimeClass.asInstanceOf[Class[T]]
[warn]   def expectMsgType[T](implicit t: ClassTag[T]): T = expectMsgClass_internal(remainingOrDefault, t.runtimeClass.asInstanceOf[Class[T]])
[warn]                                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:454: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   t.runtimeClass.asInstanceOf[Class[T]]
[warn]   def expectMsgType[T](max: FiniteDuration)(implicit t: ClassTag[T]): T = expectMsgClass_internal(max.dilated, t.runtimeClass.asInstanceOf[Class[T]])
[warn]                                                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:474: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[C]
[warn]     o.asInstanceOf[C]
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:495: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[T]
[warn]     o.asInstanceOf[T]
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:516: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[C]
[warn]     o.asInstanceOf[C]
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:552: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   recv.asInstanceOf[scala.collection.immutable.Seq[T]]
[warn]     recv.asInstanceOf[immutable.Seq[T]]
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:575: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   recv.asInstanceOf[scala.collection.immutable.Seq[T]]
[warn]     recv.asInstanceOf[immutable.Seq[T]]
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:601: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   recv.asInstanceOf[scala.collection.immutable.Seq[T]]
[warn]     recv.asInstanceOf[immutable.Seq[T]]
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:862: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actorSystem.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]           actorSystem.asInstanceOf[ActorSystemImpl].printTree)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:941: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[B]
[warn]   final def isDefinedAt(x: A): Boolean = try { cache = `match`(x); true } catch { case NoMatch ? cache = null.asInstanceOf[B]; false }
[warn]                                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:388: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   obj.==(o)
[warn]     assert(obj == o, s"expected $obj, found $o" + hintOrEmptyString)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:494: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   x$2.==(o)
[warn]     assert(obj exists (_ == o), s"found unexpected $o")
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:549: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   x.==(x$3)
[warn]     val missing = obj filterNot (x ? recv exists (x == _))
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:550: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   x.==(x$4)
[warn]     val unexpected = recv filterNot (x ? obj exists (x == _))
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:69: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   DelegatingSupervisorStrategy.this.delegates.get(child).getOrElse[akka.actor.SupervisorStrategy](akka.actor.SupervisorStrategy.stoppingStrategy)
[warn]     private def delegate(child: ActorRef) = delegates.get(child).getOrElse(stoppingStrategy)
[warn]                                                                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:384: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def expectMsg_internal[T](max: Duration, obj: T, hint: Option[String] = None): T = {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:470: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def expectMsgClass_internal[C](max: FiniteDuration, c: Class[C]): C = {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:491: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def expectMsgAnyOf_internal[T](max: FiniteDuration, obj: T*): T = {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:512: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def expectMsgAnyClassOf_internal[C](max: FiniteDuration, obj: Class[_ <: C]*): C = {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:547: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def expectMsgAllOf_internal[T](max: FiniteDuration, obj: T*): immutable.Seq[T] = {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:614: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def expectNoMsg_internal(max: FiniteDuration) {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:679: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def receiveN_internal(n: Int, max: Duration): immutable.Seq[AnyRef] = {
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:429: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fishForMessage(max: scala.concurrent.duration.Duration = scala.concurrent.duration.Duration.Undefined, hint: String = "")(f: PartialFunction[Any,Boolean]): Any = {

[warn]   val _max: scala.concurrent.duration.FiniteDuration = TestKitBase.this.remainingOrDilated(max);

[warn]   val end: scala.concurrent.durat
[warn]   def fishForMessage(max: Duration = Duration.Undefined, hint: String = "")(f: PartialFunction[Any, Boolean]): Any = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:695: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def receiveOne(max: scala.concurrent.duration.Duration): AnyRef = {

[warn]   val message: akka.testkit.TestActor.Message = if (max.==(scala.concurrent.duration.`package`.DurationInt(0).seconds))

[warn]     TestKitBase.this.queue.pollFirst()

[warn]   else

[warn]     if (max.isFinite())

[warn]       TestKitBase.this.queue.pollFirs
[warn]   def receiveOne(max: Duration): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:934: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type A
[warn] private[testkit] abstract class CachingPartialFunction[A, B <: AnyRef] extends scala.runtime.AbstractPartialFunction[A, B] {
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:431: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val end: scala.concurrent.duration.FiniteDuration = TestKitBase.this.now.+(_max)
[warn]     val end = now + _max
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKit.scala:814: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   implicit val system: akka.actor.ActorSystem = _system
[warn] class TestKit(_system: ActorSystem) extends { implicit val system = _system } with TestKitBase
[warn]                                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\TestKitExtension.scala:12: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.testkit.TestKitSettings = TestKitExtension.super.get(system)
[info]   override def get(system: ActorSystem): TestKitSettings = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\package.scala:50: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TestDuration.this.duration.*(TestKitExtension.apply(system).TestTimeFactor).asInstanceOf[scala.concurrent.duration.FiniteDuration]
[warn]       (duration * TestKitExtension(system).TestTimeFactor).asInstanceOf[FiniteDuration]
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\package.scala:33: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   eventFilters.toSeq
[warn]   def filterEvents[T](eventFilters: EventFilter*)(block: ? T)(implicit system: ActorSystem): T = filterEvents(eventFilters.toSeq)(block)
[warn]                                                                                                                            ^
[info] [warn] [scapegoat] Analysis complete: 12 files - 0 errors 89 warns 9 infos
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\SocketUtil.scala:35: method invocation uses reflection
[info]       serverSocket.bind(new InetSocketAddress(hostname, 0))
[info]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\SocketUtil.scala:36: method invocation uses reflection
[info]       (serverSocket, new InetSocketAddress(hostname, serverSocket.getLocalPort))
[info]                                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\main\scala\akka\testkit\SocketUtil.scala:37: method invocation uses reflection
[info]     } collect { case (socket, address) ? socket.close(); address }
[info]                                                      ^
[warn] 88 warnings found
[info] Compiling 3 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-fsm-scala\target\classes...
[info] Compiling 4 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\ActorSystemActivator.scala:76: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   context.getService[_$2](reference).asInstanceOf[T]
[warn]     context.getService(reference).asInstanceOf[T]
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\ActorSystemActivator.scala:102: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   properties.asInstanceOf[java.util.Dictionary[String,Any]]
[warn]       properties.asInstanceOf[Dictionary[String, Any]]))
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\ActorSystemActivator.scala:34: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val system: akka.actor.ActorSystem = _
[warn]   def configure(context: BundleContext, system: ActorSystem): Unit
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\ActorSystemActivator.scala:53: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val system: akka.actor.ActorSystem = _
[warn]   def addLogServiceListener(context: BundleContext, system: ActorSystem) {
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\ActorSystemActivator.scala:97: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val system: akka.actor.ActorSystem = _
[warn]   def registerService(context: BundleContext, system: ActorSystem): Unit = {
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\BundleDelegatingClassLoader.scala:25: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new BundleDelegatingClassLoader(context.getBundle(), null)
[warn]   def apply(context: BundleContext): BundleDelegatingClassLoader = new BundleDelegatingClassLoader(context.getBundle, null)
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\BundleDelegatingClassLoader.scala:79: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   wiring.==(null)
[warn]             if (wiring == null) Set.empty
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\BundleDelegatingClassLoader.scala:44: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   remaining.tail
[warn]         case Failure(_)   ? find(remaining.tail)
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\BundleDelegatingClassLoader.scala:55: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   remaining.tail
[warn]         case None    ? find(remaining.tail)
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\BundleDelegatingClassLoader.scala:73: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   remaining.head
[warn]         val (b, rest) = (remaining.head, remaining.tail)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\BundleDelegatingClassLoader.scala:73: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   remaining.tail
[warn]         val (b, rest) = (remaining.head, remaining.tail)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\BundleDelegatingClassLoader.scala:68: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val bundle: org.osgi.framework.Bundle = _
[warn]   private def findTransitiveBundles(bundle: Bundle): Set[Bundle] = {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\OsgiActorSystemFactory.scala:39: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val context: org.osgi.framework.BundleContext = _).
[warn]   def actorSystemConfig(context: BundleContext): Config = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-osgi\src\main\scala\akka\osgi\OsgiActorSystemFactory.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val context: org.osgi.framework.BundleContext = _
[warn]   def actorSystemConfig(context: BundleContext): Config = {
[warn]                         ^
[info] [warn] [scapegoat] Analysis complete: 4 files - 0 errors 14 warns 0 infos
[warn] 14 warnings found
[info] Compiling 4 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-scala\target\classes...
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-java-lambda\target\classes...
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-main-java\target\classes...
[info] Compiling 1 Scala source to D:\data\akka-akka\akka-akka-4f9dc51\akka-agent\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-agent\src\main\scala\akka\agent\Agent.scala:31: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = SecretAgent.this.ref.single.update(newValue)
[warn]     def send(newValue: T): Unit = withinTransaction(new Runnable { def run = ref.single.update(newValue) })
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-agent\src\main\scala\akka\agent\Agent.scala:33: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = SecretAgent.this.ref.single.transform(f)
[warn]     def send(f: T ? T): Unit = withinTransaction(new Runnable { def run = ref.single.transform(f) })
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-agent\src\main\scala\akka\agent\Agent.scala:37: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = try {

[warn]   SecretAgent.this.updater.suspend()

[warn] } finally ec.execute({

[warn]   final class $anon extends Object with Runnable {

[warn]     def <init>(): <$anon: Runnable> = {

[warn]       $anon.super.<init>();

[warn]       ()

[warn]     };

[warn]     def run: Unit = try {

[warn]       SecretAgent.this.ref.single.transform(f)

[warn]         def run =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-agent\src\main\scala\akka\agent\Agent.scala:48: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = {

[warn]   SecretAgent.this.updater.suspend();

[warn]   {

[warn]     result.completeWith(scala.concurrent.Future.apply[T](try {

[warn]       SecretAgent.this.ref.single.transformAndGet(f)

[warn]     } finally SecretAgent.this.updater.resume())(ec));

[warn]     ()

[warn]   }

[warn] }
[warn]         def run = {
[warn]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-agent\src\main\scala\akka\agent\Agent.scala:59: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     private final def withinTransaction(run: Runnable): Unit = {
[info]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-agent\src\main\scala\akka\agent\Agent.scala:69: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     private final def doAlter(f: ? T): Future[T] = {
[info]                       ^
[info] [warn] [scapegoat] Analysis complete: 1 files - 0 errors 4 warns 2 infos
[warn] four warnings found
[info] Compiling 1 Scala source to D:\data\akka-akka\akka-akka-4f9dc51\akka-slf4j\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-slf4j\src\main\scala\akka\event\slf4j\Slf4jLogger.scala:76: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   message.asInstanceOf[AnyRef]
[warn]       withMdc(logSource, event) { Logger(logClass, logSource).warn("{}", message.asInstanceOf[AnyRef]) }
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-slf4j\src\main\scala\akka\event\slf4j\Slf4jLogger.scala:79: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   message.asInstanceOf[AnyRef]
[warn]       withMdc(logSource, event) { Logger(logClass, logSource).info("{}", message.asInstanceOf[AnyRef]) }
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-slf4j\src\main\scala\akka\event\slf4j\Slf4jLogger.scala:82: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   message.asInstanceOf[AnyRef]
[warn]       withMdc(logSource, event) { Logger(logClass, logSource).debug("{}", message.asInstanceOf[AnyRef]) }
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-slf4j\src\main\scala\akka\event\slf4j\Slf4jLogger.scala:42: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   c.==(classOf[akka.event.DummyClassForStringSources])
[warn]     case c if c == classOf[DummyClassForStringSources] ? apply(logSource)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-slf4j\src\main\scala\akka\event\slf4j\Slf4jLogger.scala:121: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn] class Slf4jLoggingFilter(settings: ActorSystem.Settings, eventStream: EventStream) extends LoggingFilter {
[warn]                          ^
[info] [warn] [scapegoat] Analysis complete: 1 files - 0 errors 5 warns 0 infos
[warn] 5 warnings found
[info] Compiling 1 Scala source to D:\data\akka-akka\akka-akka-4f9dc51\akka-kernel\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-kernel\src\main\scala\akka\kernel\Main.scala:84: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   classLoader.loadClass(c).newInstance().asInstanceOf[akka.kernel.Bootable]
[warn]     val bootables: immutable.Seq[Bootable] = bootClasses map { c ? classLoader.loadClass(c).newInstance.asInstanceOf[Bootable] }
[warn]                                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-kernel\src\main\scala\akka\kernel\Main.scala:98: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.actor.ActorSystem.GlobalHome.get
[warn]       val home = ActorSystem.GlobalHome.get
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-kernel\src\main\scala\akka\kernel\Main.scala:130: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = {

[warn]   Main.this.log("");

[warn]   Main.this.log("Shutting down Akka...");

[warn]   bootables.foreach[Unit](((bootable: akka.kernel.Bootable) => {

[warn]     Main.this.log("Shutting down ".+(bootable.getClass().getName()));

[warn]     bootable.shutdown()

[warn]   }));

[warn]   Main.this.log("Successfully shut down Akka")
[warn]       def run = {
[warn]           ^
[info] [warn] [scapegoat] Analysis complete: 1 files - 0 errors 3 warns 0 infos
[warn] three warnings found
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 37 Scala sources and 6 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:90: abstract type pattern D is unchecked since it is eliminated by erasure
[warn]     case SnapshotOffer(_, PersistentFSMSnapshot(stateIdentifier, data: D, timeout)) ? startWith(statesMap(stateIdentifier), data, timeout)
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\MessageSerializer.scala:57: non-variable type argument Any in type pattern akka.persistence.fsm.PersistentFSM.PersistentFSMSnapshot[Any] is unchecked since it is eliminated by erasure
[warn]     case p: PersistentFSMSnapshot[Any]  ? persistentFSMSnapshotBuilder(p).build.toByteArray
[warn]             ^
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\AtLeastOnceDelivery.scala:57: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   UnconfirmedDelivery.this.message.asInstanceOf[AnyRef]
[warn]     def getMessage(): AnyRef = message.asInstanceOf[AnyRef]
[warn]                                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\AtLeastOnceDelivery.scala:22: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class AtLeastOnceDeliverySnapshot(currentDeliveryId: Long, unconfirmedDeliveries: immutable.Seq[UnconfirmedDelivery])
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\AtLeastOnceDelivery.scala:39: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class UnconfirmedWarning(unconfirmedDeliveries: immutable.Seq[UnconfirmedDelivery]) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\AtLeastOnceDelivery.scala:53: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class UnconfirmedDelivery(deliveryId: Long, destination: ActorPath, message: Any) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\AtLeastOnceDelivery.scala:69: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Delivery(destination: ActorPath, message: Any, timestamp: Long, attempt: Int)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\AtLeastOnceDelivery.scala:57: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def getMessage(): AnyRef = UnconfirmedDelivery.this.message.asInstanceOf[AnyRef]
[warn]     def getMessage(): AnyRef = message.asInstanceOf[AnyRef]
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Eventsourced.scala:319: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[Any => Unit]
[warn]     pendingInvocations addLast StashingHandlerInvocation(event, handler.asInstanceOf[Any ? Unit])
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Eventsourced.scala:336: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[Any => Unit]
[warn]         pendingInvocations addLast StashingHandlerInvocation(event, handler.asInstanceOf[Any ? Unit])
[warn]                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Eventsourced.scala:371: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[Any => Unit]
[warn]     pendingInvocations addLast AsyncHandlerInvocation(event, handler.asInstanceOf[Any ? Unit])
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Eventsourced.scala:387: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[Any => Unit]
[warn]         pendingInvocations addLast AsyncHandlerInvocation(event, handler.asInstanceOf[Any ? Unit])
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Eventsourced.scala:418: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[Any => Unit]
[warn]       pendingInvocations addLast AsyncHandlerInvocation(event, handler.asInstanceOf[Any ? Unit])
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Eventsourced.scala:66: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var currentState: State = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Eventsourced.scala:439: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Eventsourced.this.currentState.==(null)
[warn]     if (currentState == null) true else currentState.recoveryRunning
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\JournalProtocol.scala:125: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class RecoverySuccess(highestSequenceNr: Long)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistence.scala:133: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[persistence] case class PluginHolder(actor: ActorRef, adapters: EventAdapters, config: Config)
[info]                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistence.scala:129: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.persistence.Persistence = Persistence.super.get(system)
[info]   override def get(system: ActorSystem): Persistence = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistence.scala:172: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Persistence.this.system.dynamicAccess.createInstanceFor[akka.persistence.StashOverflowStrategyConfigurator](Persistence.this.config.getString("internal-stash-overflow-strategy"), akka.util.Collections.EmptyImmutableSeq)((ClassTag.apply[akka.persistence.StashOverflowStrategyConfigurator](classOf[akka.persistence.StashOverflowStrategyConfigurator]): scala.reflect.ClassTag[akka.persistence.StashOverflowStrategyConfigurator])).map[akka.persistence.StashOverflowStrategy](((x$1: akka.persistence.Stash
[warn]       .map(_.create(system.settings.config)).get
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistence.scala:289: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Persistence.this.system.dynamicAccess.getClassFor[Any](pluginClassName)((ClassTag.Any: scala.reflect.ClassTag[Any])).get
[warn]     val pluginClass = system.dynamicAccess.getClassFor[Any](pluginClassName).get
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistence.scala:310: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val system: akka.actor.ExtendedActorSystem = _
[warn]     override def createExtension(system: ExtendedActorSystem): PluginHolder = {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistence.scala:314: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val config: com.typesafe.config.Config = system.settings.config.getConfig(PluginHolderExtensionId.this.configPath).withFallback(system.settings.config.getConfig(PluginHolderExtensionId.this.fallbackPa
[warn]       val config: Config = system.settings.config.getConfig(configPath)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistent.scala:141: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     sender:        ActorRef = null,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistent.scala:169: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val payload: Any = _
[warn]   def withPayload(payload: Any): PersistentRepr =
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistent.scala:172: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val manifest: String = _
[warn]   def withManifest(manifest: String): PersistentRepr =
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistent.scala:176: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val sequenceNr: Long = _
[warn]   def update(sequenceNr: Long, persistenceId: String, deleted: Boolean, sender: ActorRef, writerUuid: String) =
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistent.scala:176: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val persistenceId: String = _
[warn]   def update(sequenceNr: Long, persistenceId: String, deleted: Boolean, sender: ActorRef, writerUuid: String) =
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistent.scala:176: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val deleted: Boolean = _
[warn]   def update(sequenceNr: Long, persistenceId: String, deleted: Boolean, sender: ActorRef, writerUuid: String) =
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistent.scala:176: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val sender: akka.actor.ActorRef = _
[warn]   def update(sequenceNr: Long, persistenceId: String, deleted: Boolean, sender: ActorRef, writerUuid: String) =
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\Persistent.scala:176: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val writerUuid: String = _
[warn]   def update(sequenceNr: Long, persistenceId: String, deleted: Boolean, sender: ActorRef, writerUuid: String) =
[warn]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentActor.scala:104: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final class RecoveryTimedOut extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace {

[warn]   <paramaccessor> private[this] val message: String = _;

[warn]   def <init>(message: String): akka.persistence.RecoveryTimedOut = {

[warn]     RecoveryTimedOut.super.<init>(message);

[warn]     ()

[warn]   }

[warn] }
[warn] final class RecoveryTimedOut(message: String) extends RuntimeException(message) with NoStackTrace
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentActor.scala:206: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val event: A = _
[warn]     persist(event)(event ? handler(event))
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentActor.scala:247: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val event: A = _
[warn]     super[Eventsourced].persistAsync(event)(event ? handler(event))
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentActor.scala:278: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val event: A = _
[warn]     super[Eventsourced].deferAsync(event)(event ? handler(event))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentActor.scala:337: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val event: A = _
[warn]     persist(event)(event ? handler(event))
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentActor.scala:373: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val event: A = _
[warn]     persistAsync(event)(event ? handler(event))
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentActor.scala:408: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val event: A = _
[warn]     super.deferAsync(event)(event ? handler(event))
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\PersistentView.scala:285: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("replay started").s()
[warn]     override def toString: String = s"replay started"
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:104: [scapegoat] Collection promotion to Any
[warn]   The `:+` (append) operator on collections accepts any argument you give it, which means that you can end up with e.g. `Seq[Any]` if your types don't match.
[warn]   eventsToPersist.:+[Any, scala.collection.immutable.Seq[Any]]
[warn]       eventsToPersist = eventsToPersist :+ StateChangeEvent(nextState.stateName.identifier, nextState.timeout)
[warn]                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:147: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[persistence] case class StateChangeEvent(stateIdentifier: String, timeout: Option[FiniteDuration]) extends PersistentFsmEvent
[info]                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:157: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[persistence] case class PersistentFSMSnapshot[D](stateIdentifier: String, data: D, timeout: Option[FiniteDuration]) extends Message
[info]                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:262: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   object `->` {
[info]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:253: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Timer.this.ref.get
[warn]         ref.get.cancel()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:290: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stateName: S = stateName
[warn]     private[akka] def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies, notifies: Boolean = notifies, domainEvents: Seq[E] = domainEvents, afterTransitionDo: D ? Unit = afterTransitionDo): State[S, D, E] = {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:290: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stateData: D = stateData
[warn]     private[akka] def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies, notifies: Boolean = notifies, domainEvents: Seq[E] = domainEvents, afterTransitionDo: D ? Unit = afterTransitionDo): State[S, D, E] = {
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:290: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val timeout: Option[scala.concurrent.duration.FiniteDuration] = timeout
[warn]     private[akka] def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies, notifies: Boolean = notifies, domainEvents: Seq[E] = domainEvents, afterTransitionDo: D ? Unit = afterTransitionDo): State[S, D, E] = {
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:290: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stopReason: Option[akka.persistence.fsm.PersistentFSM.Reason] = stopReason
[warn]     private[akka] def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies, notifies: Boolean = notifies, domainEvents: Seq[E] = domainEvents, afterTransitionDo: D ? Unit = afterTransitionDo): State[S, D, E] = {
[warn]                                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:290: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val replies: List[Any] = replies
[warn]     private[akka] def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies, notifies: Boolean = notifies, domainEvents: Seq[E] = domainEvents, afterTransitionDo: D ? Unit = afterTransitionDo): State[S, D, E] = {
[warn]                                                                                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:290: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val notifies: Boolean = notifies
[warn]     private[akka] def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies, notifies: Boolean = notifies, domainEvents: Seq[E] = domainEvents, afterTransitionDo: D ? Unit = afterTransitionDo): State[S, D, E] = {
[warn]                                                                                                                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:290: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val domainEvents: Seq[E] = domainEvents
[warn]     private[akka] def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies, notifies: Boolean = notifies, domainEvents: Seq[E] = domainEvents, afterTransitionDo: D ? Unit = afterTransitionDo): State[S, D, E] = {
[warn]                                                                                                                                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:290: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val afterTransitionDo: D => Unit = afterTransitionDo
[warn]     private[akka] def copy(stateName: S = stateName, stateData: D = stateData, timeout: Option[FiniteDuration] = timeout, stopReason: Option[Reason] = stopReason, replies: List[Any] = replies, notifies: Boolean = notifies, domainEvents: Seq[E] = domainEvents, afterTransitionDo: D ? Unit = afterTransitionDo): State[S, D, E] = {
[warn]                                                                                                                                                                                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:301: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val timeout: scala.concurrent.duration.Duration = _
[warn]     def forMax(timeout: Duration): State[S, D, E] = timeout match {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSM.scala:330: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val notifies: Boolean = _
[warn]     private[akka] def withNotification(notifies: Boolean): State[S, D, E] = {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:582: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LoggingPersistentFSM.this.stateName.asInstanceOf[AnyRef]
[warn]       states(pos) = stateName.asInstanceOf[AnyRef]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:601: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x._2.asInstanceOf[S]
[warn]     val log = events zip states filter (_._1 ne null) map (x ? LogEntry(x._2.asInstanceOf[S], x._1.stateData, x._1.event))
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:709: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   transitionHandlerBuilder.build().asInstanceOf[AbstractPersistentFSMBase.this.TransitionHandler]
[warn]     onTransition(transitionHandlerBuilder.build().asInstanceOf[TransitionHandler])
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:735: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   stopBuilder.build().asInstanceOf[PartialFunction[AbstractPersistentFSMBase.this.StopEvent,Unit]]
[warn]     onTermination(stopBuilder.build().asInstanceOf[PartialFunction[StopEvent, Unit]])
[warn]                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:275: [scapegoat] List append is slow
[info]   List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).
[info]   final def onTransition(transitionHandler: TransitionHandler): Unit = transitionEvent :+= transitionHandler
[info]                                                                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:625: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def NullFunction[S, D]: PartialFunction[S, D] = PersistentFSM.NullFunction
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:139: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   final def when(stateName: S, stateTimeout: FiniteDuration = null)(stateFunction: StateFunction): Unit =
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:485: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         this.nextState = null
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:313: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   PersistentFSMBase.this.currentState.!=(null)
[warn]     if (currentState != null) makeTransition(currentState)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:320: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   PersistentFSMBase.this.currentState.!=(null)
[warn]     if (currentState != null) currentState.stateName
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:327: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   PersistentFSMBase.this.currentState.!=(null)
[warn]     if (currentState != null) currentState.stateData
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:660: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   AbstractPersistentFSMBase.this.when(stateName, null, stateFunctionBuilder)
[warn]     when(stateName, null, stateFunctionBuilder)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:418: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   PersistentFSMBase.this.timeoutFuture.get
[warn]           timeoutFuture.get.cancel()
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:443: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   PersistentFSMBase.this.timeoutFuture.get
[warn]         timeoutFuture.get.cancel()
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:490: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   timeout.get
[warn]         val t = timeout.get
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:518: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   nextState.stopReason.get
[warn]       val reason = nextState.stopReason.get
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:457: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nextState: akka.persistence.fsm.PersistentFSM.State[S,D,E] = if (stateFunc.isDefinedAt(event))

[warn]   stateFunc.apply(event)

[warn] else

[warn]   PersistentFSMBase.this.handleEvent.apply(event)
[warn]     val nextState = if (stateFunc isDefinedAt event) {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:466: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nextState: PersistentFSMBase.this.State = _
[warn]   private[akka] def applyState(nextState: State): Unit = {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:476: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nextState: PersistentFSMBase.this.State = _
[warn]   private[akka] def makeTransition(nextState: State): Unit = {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\fsm\PersistentFSMBase.scala:516: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nextState: PersistentFSMBase.this.State = _
[warn]   private def terminate(nextState: State): Unit = {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\AsyncWriteJournal.scala:66: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$1.isInstanceOf[akka.persistence.AtomicWrite]
[warn]         val atomicWriteCount = messages.count(_.isInstanceOf[AtomicWrite])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\AsyncWriteJournal.scala:287: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ro.get
[warn]       if (ro.isDefined) resequence(ro.get)
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\AsyncWriteJournal.scala:79: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   prepared.get
[warn]               s"Expected [${prepared.get.size}], but got [${results.size}]")
[warn]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\AsyncWriteProxy.scala:112: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ReplaySuccess(highestSequenceNr: Long)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapter.scala:121: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[akka] case class NoopWriteEventAdapter(private val readEventAdapter: ReadEventAdapter) extends EventAdapter {
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapter.scala:132: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[akka] case class NoopReadEventAdapter(private val writeEventAdapter: WriteEventAdapter) extends EventAdapter {
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapter.scala:92: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def empty: EventSeq = EmptyEventSeq
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapter.scala:95: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def single(event: Any): EventSeq = new SingleEventSeq(event)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapter.scala:98: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @varargs final def create(events: Any*): EventSeq = EventsSeq(events.toList)
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapter.scala:99: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def apply(events: Any*): EventSeq = EventsSeq(events.toList)
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:44: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Using EventAdapter: {} for event [{}]").s()
[warn]             log.debug(s"Using EventAdapter: {} for event [{}]", value.getClass.getName, clazz.getName)
[warn]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:118: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[akka] case class CombinedReadEventAdapter(adapters: immutable.Seq[EventAdapter]) extends EventAdapter {
[info]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:163: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   v.isInstanceOf[java.util.ArrayList[_]]
[warn]         case (k, v: util.ArrayList[_]) if v.isInstanceOf[util.ArrayList[_]] ? k → v.asScala.map(_.toString).toList
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:171: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   IdentityEventAdapters.super.<init>(null, null, null)
[warn] private[akka] case object IdentityEventAdapters extends EventAdapters(null, null, null) {
[warn]                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:152: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   private final def configToMap(config: Config, path: String): Map[String, String] = {
[info]                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:159: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   private final def configToListMap(config: Config, path: String): Map[String, immutable.Seq[String]] = {
[info]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:94: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   as.head
[warn]         yield if (as.size == 1) (system.dynamicAccess.getClassFor[Any](k).get, handlers(as.head))
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:88: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   EventAdapters.this.instantiateAdapter(v, system).get
[warn]     val handlers = for ((k: String, v: String) ← adapters) yield k → instantiateAdapter(v, system).get
[warn]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:94: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.dynamicAccess.getClassFor[Any](k)((ClassTag.Any: scala.reflect.ClassTag[Any])).get
[warn]         yield if (as.size == 1) (system.dynamicAccess.getClassFor[Any](k).get, handlers(as.head))
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:95: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.dynamicAccess.getClassFor[Any](k)((ClassTag.Any: scala.reflect.ClassTag[Any])).get
[warn]       else (system.dynamicAccess.getClassFor[Any](k).get, CombinedReadEventAdapter(as.map(handlers)))
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:106: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.dynamicAccess.getClassFor[Any](adapterFQN)((ClassTag.Any: scala.reflect.ClassTag[Any])).get
[warn]     val clazz = system.dynamicAccess.getClassFor[Any](adapterFQN).get
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\EventAdapters.scala:83: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toString on instance of String.
[warn]   boundAdapter.toString
[warn]       adapterNames(boundAdapter.toString),
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\PersistencePluginProxy.scala:107: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PersistencePluginProxy.this.context.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     context.system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\PersistencePluginProxy.scala:56: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.persistence.journal.PersistencePluginProxyExtensionImpl = PersistencePluginProxyExtension.super.get(system)
[info]   override def get(system: ActorSystem): PersistencePluginProxyExtensionImpl = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\PersistencePluginProxy.scala:27: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   akka.persistence.Persistence.apply(system).journalFor(null)
[warn]     Persistence(system).journalFor(null)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\PersistencePluginProxy.scala:29: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   akka.persistence.Persistence.apply(system).snapshotStoreFor(null)
[warn]       Persistence(system).snapshotStoreFor(null)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\ReplayFilter.scala:112: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   ReplayFilter.this.oldWriters.head
[warn]             oldWriters.remove(oldWriters.head)
[warn]                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\Tagged.scala:18: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class Tagged(payload: Any, tags: Set[String]) {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\WriteJournalBase.scala:40: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   adapter.isInstanceOf[akka.persistence.journal.NoopWriteEventAdapter]
[warn]     if (adapter == IdentityEventAdapter || adapter.isInstanceOf[NoopWriteEventAdapter])
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbJournal.scala:22: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val configPath: String = "akka.persistence.journal.leveldb"
[warn] private[persistence] class LeveldbJournal extends { val configPath = "akka.persistence.journal.leveldb" } with AsyncWriteJournal with LeveldbStore {
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbJournal.scala:44: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]         }.recover {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbRecovery.scala:41: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (nextKey.sequenceNr.>(toSequenceNr))

[warn]   ()

[warn] else

[warn]   if (Key.isDeletionKey(nextKey))

[warn]     go(iter, nextKey, ctr, replayCallback)

[warn]   else

[warn]     if (key.persistenceId.==(nextKey.persistenceId))

[warn]       {

[warn]         val msg: akka.persistence.PersistentRepr = LeveldbRecovery.this.persistentFromBytes(nextEntry.getValue());

[warn]         val del: Boolean = deletion(iter, nextKey);

[warn]         if (ctr.<(max))

[warn]           {

[warn]             if (del.unary_!)

[warn]               replayCallback.apply(msg)

[warn]             else

[warn]  
[warn]         if (nextKey.sequenceNr > toSequenceNr) {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbRecovery.scala:90: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (nextKey.sequenceNr.>(toSequenceNr))

[warn]   ()

[warn] else

[warn]   if (key.persistenceId.==(nextKey.persistenceId))

[warn]     {

[warn]       val msg: akka.persistence.PersistentRepr = LeveldbRecovery.this.persistentFromBytes(nextEntry.getValue());

[warn]       if (ctr.<(max))

[warn]         {

[warn]           replayCallback.apply(akka.persistence.journal.leveldb.LeveldbJournal.ReplayedTaggedMessage.apply(msg, tag, nextKey.sequenceNr));

[warn]           go(iter, nextKey, ctr.+(1L), replayCallback)

[warn]         }

[warn]       else

[warn]         ()

[warn]     }

[warn]   
[warn]         if (nextKey.sequenceNr > toSequenceNr) {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbRecovery.scala:37: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val replayCallback: akka.persistence.PersistentRepr => Unit = _
[warn]     def go(iter: DBIterator, key: Key, ctr: Long, replayCallback: PersistentRepr ? Unit) {
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbRecovery.scala:86: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val replayCallback: akka.persistence.journal.leveldb.LeveldbJournal.ReplayedTaggedMessage => Unit = _
[warn]     def go(iter: DBIterator, key: Key, ctr: Long, replayCallback: ReplayedTaggedMessage ? Unit) {
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbStore.scala:137: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   LeveldbStore.this.serialization.serialize(p).get
[warn]   def persistentToBytes(p: PersistentRepr): Array[Byte] = serialization.serialize(p).get
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\LeveldbStore.scala:138: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   LeveldbStore.this.serialization.deserialize[akka.persistence.PersistentRepr](a, classOf[akka.persistence.PersistentRepr]).get
[warn]   def persistentFromBytes(a: Array[Byte]): PersistentRepr = serialization.deserialize(a, classOf[PersistentRepr]).get
[warn]                                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\SharedLeveldbStore.scala:28: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$1.isInstanceOf[akka.persistence.AtomicWrite]
[warn]       val atomicWriteCount = messages.count(_.isInstanceOf[AtomicWrite])
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\SharedLeveldbStore.scala:40: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   prepared.get
[warn]             s"Expected [${prepared.get.size}], but got [${results.size}]")
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\SharedLeveldbStore.scala:20: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val configPath: String = "akka.persistence.journal.leveldb-shared.store"
[warn] class SharedLeveldbStore extends { val configPath = "akka.persistence.journal.leveldb-shared.store" } with LeveldbStore {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\journal\leveldb\SharedLeveldbStore.scala:66: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       }.recover {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\MessageSerializer.scala:90: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   unconfirmed.message.asInstanceOf[AnyRef]
[warn]           setPayload(persistentPayloadBuilder(unconfirmed.message.asInstanceOf[AnyRef]))
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\MessageSerializer.scala:107: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   persistentFSMSnapshot.data.asInstanceOf[AnyRef]
[warn]       .setData(persistentPayloadBuilder(persistentFSMSnapshot.data.asInstanceOf[AnyRef]))
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\MessageSerializer.scala:132: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.duration.Duration.apply(persistentStateChange.getTimeout()).asInstanceOf[scala.concurrent.duration.FiniteDuration]
[warn]       else if (persistentStateChange.hasTimeout) Some(Duration(persistentStateChange.getTimeout).asInstanceOf[duration.FiniteDuration])
[warn]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\MessageSerializer.scala:158: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   persistent.payload.asInstanceOf[AnyRef]
[warn]     builder.setPayload(persistentPayloadBuilder(persistent.payload.asInstanceOf[AnyRef]))
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\MessageSerializer.scala:219: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MessageSerializer.this.serialization.deserialize(persistentPayload.getPayload().toByteArray(), persistentPayload.getSerializerId(), manifest).get
[warn]       manifest).get
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\SnapshotSerializer.scala:48: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   data.asInstanceOf[AnyRef]
[warn]     case Snapshot(data) ? snapshotToBinary(data.asInstanceOf[AnyRef])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\SnapshotSerializer.scala:56: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = Snapshot.apply(SnapshotSerializer.this.snapshotFromBinary(bytes))
[warn]   def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\serialization\SnapshotSerializer.scala:148: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SnapshotSerializer.this.serialization.deserialize(snapshotBytes, header.serializerId, header.manifest.getOrElse[String]("")).get
[warn]     serialization.deserialize(snapshotBytes, header.serializerId, header.manifest.getOrElse("")).get
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\snapshot\local\LocalSnapshotStore.scala:128: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   files.eq(null)
[warn]     if (files eq null) Nil // if the dir was removed
[warn]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\snapshot\local\LocalSnapshotStore.scala:159: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     private final def matches(pid: String, snr: String, tms: String): Boolean = {
[info]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\snapshot\local\LocalSnapshotStore.scala:95: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   metadata.init
[warn]           load(metadata.init) // try older snapshot
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\snapshot\local\LocalSnapshotStore.scala:105: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   LocalSnapshotStore.this.serializationExtension.deserialize[akka.persistence.serialization.Snapshot](akka.persistence.serialization.`package`.streamToBytes(inputStream), classOf[akka.persistence.serialization.Snapshot]).get
[warn]     serializationExtension.deserialize(streamToBytes(inputStream), classOf[Snapshot]).get
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\snapshot\local\LocalSnapshotStore.scala:150: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val dir: java.io.File = _
[warn]     def accept(dir: File, name: String): Boolean = {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\main\scala\akka\persistence\snapshot\local\LocalSnapshotStore.scala:164: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val dir: java.io.File = _
[warn]     def accept(dir: File, name: String): Boolean =
[warn]                ^
[info] [warn] [scapegoat] Analysis complete: 37 files - 0 errors 102 warns 25 infos
[warn] there were three deprecation warnings; re-run with -deprecation for details
[warn] 104 warnings found
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 156 Scala sources and 126 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\OutgoingConnectionBlueprint.scala:80: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$1.asInstanceOf[scala.concurrent.Promise[Unit]]
[warn]         HttpResponseParser.ResponseContext(ctx.request.method, ctx.sendEntityTrigger.map(_.asInstanceOf[Promise[Unit]]))
[warn]                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\OutgoingConnectionBlueprint.scala:229: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]             entitySource = null
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\OutgoingConnectionBlueprint.scala:170: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.entitySource.ne(null)
[warn]       private def entitySubstreamStarted = entitySource ne null
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolConductor.scala:39: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   inlets.head.asInstanceOf[akka.stream.Inlet[akka.http.impl.engine.client.PoolFlow.RequestContext]]
[warn]         inlets.head.asInstanceOf[Inlet[RequestContext]],
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolConductor.scala:40: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   inlets.last.asInstanceOf[akka.stream.Inlet[akka.http.impl.engine.client.PoolSlot.RawSlotEvent]]
[warn]         inlets.last.asInstanceOf[Inlet[RawSlotEvent]],
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolConductor.scala:41: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   outlets.asInstanceOf[scala.collection.immutable.Seq[akka.stream.Outlet[akka.http.impl.engine.client.PoolConductor.SlotCommand]]]
[warn]         outlets.asInstanceOf[immutable.Seq[Outlet[SlotCommand]]])
[warn]                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolConductor.scala:23: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Ports(
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolConductor.scala:114: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class Busy(openRequests: Int) extends SlotState { require(openRequests > 0) }
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolConductor.scala:87: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$4.isInstanceOf[akka.http.impl.engine.client.PoolSlot.SlotEvent.RetryRequest]
[warn]       retrySplit.out(0).filter(!_.isInstanceOf[SlotEvent.RetryRequest]) ~> flatten ~> slotSelector.in1
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolConductor.scala:117: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (log).
[warn]   private class SlotSelector(slotSettings: PoolSlotsSetting, pipeliningLimit: Int, log: LoggingAdapter)
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolConductor.scala:37: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val inlets: scala.collection.immutable.Seq[akka.stream.Inlet[_]] = _
[warn]     override def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): Shape =
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolFlow.scala:93: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   conductor.slotOuts.apply(ix)
[warn]         conductor.slotOuts(ix) ~> slot.in
[warn]                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolFlow.scala:22: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class RequestContext(request: HttpRequest, responsePromise: Promise[HttpResponse], retriesLeft: Int) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolFlow.scala:25: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ResponseContext(rc: RequestContext, response: Try[HttpResponse])
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolFlow.scala:71: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val system: akka.actor.ActorSystem = _).
[warn]   def apply(
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolInterfaceActor.scala:154: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PoolInterfaceActor.this.hcps.setup.settings.idleTimeout.asInstanceOf[scala.concurrent.duration.FiniteDuration]
[warn]       val timeout = hcps.setup.settings.idleTimeout.asInstanceOf[FiniteDuration]
[warn]                                                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolMasterActor.scala:39: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.http.impl.engine.client.PoolGateway, akka.http.impl.engine.client.PoolMasterActor.PoolInterfaceStatus]()
[info]   private[this] var poolStatus = Map[PoolGateway, PoolInterfaceStatus]()
[info]                                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolMasterActor.scala:40: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.actor.ActorRef, akka.http.impl.engine.client.PoolGateway]()
[info]   private[this] var poolInterfaces = Map[ActorRef, PoolGateway]()
[info]                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolSlot.scala:83: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]           emitMultiple(eventsOut, SlotEvent.Disconnected(slotIx, retries.size + failures.size) :: retries, () ? if (failures.isEmpty && !hasBeenPulled(in)) pull(in))
[info]                                                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolSlot.scala:83: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]           emitMultiple(eventsOut, SlotEvent.Disconnected(slotIx, retries.size + failures.size) :: retries, () ? if (failures.isEmpty && !hasBeenPulled(in)) pull(in))
[info]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolSlot.scala:95: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]             firstRequest = null
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolSlot.scala:92: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.firstRequest.!=(null)
[warn]           if (firstRequest != null) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\client\PoolSlot.scala:48: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (log).
[warn]   private class SlotProcessor(slotIx: Int, connectionFlow: Flow[HttpRequest, HttpResponse, Any], log: LoggingAdapter)(implicit fm: Materializer)
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:43: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait StateResult // phantom type for ensuring soundness of our parsing method setup
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:41: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BodyPartParser.boundaryChar.firstMismatch(BodyPartParser.this.boundary).get
[warn]     s"'boundary' parameter of multipart Content-Type contains illegal character '${boundaryChar.firstMismatch(boundary).get}'")
[warn]                                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:168: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   cth.get
[warn]             else if (cth.get == h) parseHeaderLines(input, lineEnd, headers, headerCount, cth)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:228: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.output.head
[warn]         val head = output.head
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:229: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.output.tail
[warn]         output = output.tail
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:133: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]           case NotEnoughDataException ? continue(input.takeRight(needle.length + 2), 0)(parsePreamble)
[warn]                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:155: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]           case null ? continue(input, lineStart)(parseHeaderLinesAux(headers, headerCount, cth))
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:219: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]               continue(input drop emitEnd, 0)(parseEntity(null, null, simpleEmit, simpleEmit))
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\BodyPartParser.scala:220: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]             } else continue(input, offset)(parseEntity(headers, contentType, emitPartChunk, emitFinalPartChunk))
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:186: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   HttpHeaderParser.this.values.apply(msb.-(1)).asInstanceOf[akka.http.scaladsl.model.HttpHeader]
[warn]           resultHeader = values(msb - 1).asInstanceOf[HttpHeader]
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:451: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   items.apply(pivot)
[warn]         items(pivot) match {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:515: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                        mode: IllegalResponseHeaderValueProcessingMode)(sb: JStringBuilder = null, ix: Int = start): (String, Int) = {
[warn]                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:528: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   sb.!=(null)
[warn]             if (' ' <= c && c <= '\u007F') if (sb != null) sb.append(c) else null // legal 7-Bit ASCII
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:534: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   sb.!=(null)
[warn]                 case -1 ? if (sb != null) sb.append(c).append(byteChar(input, ix + 1)) else null
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:543: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   sb.!=(null)
[warn]                 case -1 ? if (sb != null) sb.append(c).append(byteChar(input, ix + 1)).append(byteChar(input, ix + 2)) else null
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:553: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   sb.!=(null)
[warn]                 case -1 ? if (sb != null) sb.append(c).append(byteChar(input, ix + 1)).append(byteChar(input, ix + 2)).append(byteChar(input, ix + 3)) else null
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:116: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case HttpHeaderParser.OutOfTrieSpaceException => ()
[warn]           case OutOfTrieSpaceException ? // if we cannot insert a value then we simply don't
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:174: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case HttpHeaderParser.OutOfTrieSpaceException => ()
[warn]         } catch { case OutOfTrieSpaceException ? /* if we cannot insert then we simply don't */ }
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpHeaderParser.scala:112: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nodeIx: Int = HttpHeaderParser.this.nodeCount
[warn]           val nodeIx = nodeCount
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:39: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var lastSession: SSLSession = null // used to prevent having to recreate header on each message
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:40: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var tlsSessionInfoHeader: `Tls-Session-Info` = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:194: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       var errorInfo: ErrorInfo = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:198: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   errorInfo.eq(null)
[warn]       if (errorInfo eq null) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:309: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   cth.get
[warn]     StrictEntityCreator(if (cth.isDefined) HttpEntity.empty(cth.get.contentType) else HttpEntity.Empty)
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:84: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   HttpMessageParser.this.result.head
[warn]       val head = result.head
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:47: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val protocol: akka.http.scaladsl.model.HttpProtocol = _
[warn]   protected def parseEntity(headers: List[HttpHeader], protocol: HttpProtocol, input: ByteString, bodyStart: Int,
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:101: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]     catch { case NotEnoughDataException ? continue(input, offset)(startNewMessage) }
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:131: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]         case null ? continue(input, lineStart)(parseHeaderLinesAux(headers, headerCount, ch, clh, cth, teh, e100c, hh))
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:179: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]         continue(parseFixedLengthBody(remainingBodyBytes - remainingInputBytes, isLastMessage))
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:188: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]     } else continue(input, bodyStart)(parseFixedLengthBody(remainingBodyBytes, isLastMessage))
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpMessageParser.scala:339: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val completionHandling: akka.http.impl.engine.parsing.HttpMessageParser.CompletionHandling = _
[warn]   protected final def setCompletionHandling(completionHandling: CompletionHandling): Unit =
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpRequestParser.scala:46: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val settings: akka.http.scaladsl.settings.ParserSettings = HttpRequestParser.this.settings
[warn]     override val settings = self.settings
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpRequestParser.scala:47: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val headerParser: akka.http.impl.engine.parsing.HttpHeaderParser = HttpRequestParser.this.headerParser.createShallowCopy()
[warn]     override val headerParser = self.headerParser.createShallowCopy()
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpRequestParser.scala:155: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: List[akka.http.scaladsl.model.HttpHeader] = headers
[warn]           headers:      List[HttpHeader]                            = headers) = {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpResponseParser.scala:141: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpResponseParser.this.contextForCurrentResponse.get
[warn]         contextForCurrentResponse.get.oneHundredContinueTrigger match {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpResponseParser.scala:157: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpResponseParser.this.contextForCurrentResponse.get
[warn]             contextForCurrentResponse.get.oneHundredContinueTrigger.foreach(_.trySuccess(()))
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpResponseParser.scala:171: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpResponseParser.this.contextForCurrentResponse.get
[warn]     if (statusCode.allowsEntity && (contextForCurrentResponse.get.requestMethod != HttpMethods.HEAD)) {
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpResponseParser.scala:66: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   HttpResponseParser.this.result.head
[warn]       val head = result.head
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpResponseParser.scala:94: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val input: akka.util.ByteString = _
[warn]       continue(input, offset)(startNewMessage)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\parsing\HttpResponseParser.scala:139: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: List[akka.http.scaladsl.model.HttpHeader] = headers
[warn]       headers:      List[HttpHeader]                              = headers) = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\BodyPartRenderer.scala:98: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   parts.head
[warn]         renderBoundary(r, boundary, suppressInitialCrLf = part eq parts.head)
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpRequestRendererFactory.scala:114: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.stream.scaladsl.Source.fromFuture[akka.NotUsed](future).drop(1L).asInstanceOf[akka.stream.scaladsl.Source[akka.util.ByteString,Any]]
[warn]           val barrier = Source.fromFuture(future).drop(1).asInstanceOf[Source[ByteString, Any]]
[warn]                                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpRequestRendererFactory.scala:162: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Strict(bytes: ByteString) extends RequestRenderingOutput {
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpRequestRendererFactory.scala:165: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Streamed(byteStream: Source[ByteString, Any]) extends RequestRenderingOutput
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpRequestRendererFactory.scala:101: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpRequestRendererFactory.this.userAgentHeader.get
[warn]           if (!userAgentSeen && userAgentHeader.isDefined) r ~~ userAgentHeader.get ~~ CrLf
[warn]                                                                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpResponseRendererFactory.scala:269: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Strict(bytes: ResponseRenderingOutput) extends StrictOrStreamed
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpResponseRendererFactory.scala:270: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Streamed(source: Source[ResponseRenderingOutput, Any]) extends StrictOrStreamed
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpResponseRendererFactory.scala:276: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class SwitchToWebSocket(handler: Either[Graph[FlowShape[FrameEvent, FrameEvent], Any], Graph[FlowShape[Message, Message], Any]]) extends CloseMode
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpResponseRendererFactory.scala:292: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[http] case class HttpData(bytes: ByteString) extends ResponseRenderingOutput
[info]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpResponseRendererFactory.scala:293: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[http] case class SwitchToWebSocket(httpResponseBytes: ByteString, handler: Either[Graph[FlowShape[FrameEvent, FrameEvent], Any], Graph[FlowShape[Message, Message], Any]]) extends ResponseRenderingOutput
[info]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpResponseRendererFactory.scala:133: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                      connHeader: Connection = null, serverSeen: Boolean = false,
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpResponseRendererFactory.scala:42: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   scala.Tuple2.apply[Long, Null](0L, null)
[warn]   @volatile private[this] var cachedDateHeader: (Long, Array[Byte]) = (0L, null)
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\HttpResponseRendererFactory.scala:165: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   connHeader.eq(null)
[warn]                   val connectionHeader = if (connHeader eq null) x else Connection(x.tokens ++ connHeader.tokens)
[warn]                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\RenderSupport.scala:45: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def CrLf = Rendering.CrLf
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\RenderSupport.scala:51: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def CancelSecond[T, Mat](first: Source[T, Mat], second: Source[T, Any]): Source[T, Mat] = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\rendering\RenderSupport.scala:63: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   preRendered.ne(null)
[warn]       if (preRendered ne null) r ~~ preRendered // re-use pre-rendered
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:546: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   $anon.this.OneHundredContinueStage.asInstanceOf[akka.stream.stage.GraphStage[akka.stream.FlowShape[T,T]]]
[warn]             _.via(OneHundredContinueStage.asInstanceOf[GraphStage[FlowShape[T, T]]])
[warn]                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:696: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class SubscriptionTimeout(andThen: () ? Unit)
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:386: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   r.createEntity.isInstanceOf[akka.http.impl.engine.parsing.ParserOutput.StreamedEntityCreator[_, _]]
[warn]               messageEndPending = r.createEntity.isInstanceOf[StreamedEntityCreator[_, _]]
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:171: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                 entitySource = null
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:114: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.entitySource.ne(null)
[warn]         if (entitySource ne null) {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:336: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TimeoutAccessImpl.this.update(null, handler)
[warn]     override def updateHandler(handler: HttpRequest ? HttpResponse): Unit = update(null, handler)
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:127: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   $anon.this.remoteAddress.get
[warn]               headers.`Remote-Address`(RemoteAddress(remoteAddress.get)) +: hdrs
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:288: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.openTimeouts.tail
[warn]           openTimeouts = openTimeouts.tail
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:417: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.openRequests.head
[warn]           val requestStart = openRequests.head
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:418: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.openRequests.tail
[warn]           openRequests = openRequests.tail
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:326: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val request: akka.http.scaladsl.model.HttpRequest = _
[warn]     override def apply(request: HttpRequest) =
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\server\HttpServerBluePrint.scala:522: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val shape: akka.stream.FlowShape[akka.http.impl.engine.parsing.ParserOutput,akka.http.impl.engine.parsing.ParserOutput] = akka.stream.FlowShape.apply[akka.http.impl.engine.parsing.Parser
[warn]         override val shape: FlowShape[ParserOutput, ParserOutput] = FlowShape(in, out)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameEvent.scala:31: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val data: akka.util.ByteString = _
[warn]   def withData(data: ByteString): FrameStart = copy(data = data)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameEvent.scala:40: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val data: akka.util.ByteString = _
[warn]   def withData(data: ByteString): FrameData = copy(data = data)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameEventParser.scala:138: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   message.get
[warn]       else Some((code, message.get))
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameEventParser.scala:74: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val mask: Int = _
[warn]         def isFlagSet(mask: Int): Boolean = (flags & mask) != 0
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameEventParser.scala:117: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val bytes: Array[Byte] = _
[warn]     @tailrec def rec(bytes: Array[Byte], offset: Int, mask: Int): Int =
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameEventParser.scala:117: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val mask: Int = _
[warn]     @tailrec def rec(bytes: Array[Byte], offset: Int, mask: Int): Int =
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameEventRenderer.scala:42: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Frame data complete but `lastPart` flag not set").s()
[warn]             if (!lastPart) throw new IllegalStateException(s"Frame data complete but `lastPart` flag not set")
[warn]                                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameHandler.scala:216: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class UserHandlerErredOut(cause: Throwable) extends BypassEvent
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameHandler.scala:66: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   TextMessageHandler.this.decoder.decode(data, last).get
[warn]             TextMessagePart(decoder.decode(data, endOfInput = last).get, last)
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameHandler.scala:113: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val data: akka.http.impl.engine.ws.FrameData = _
[warn]           override def handleFrameData(data: FrameData): Unit = {
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\FrameOutHandler.scala:136: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FrameOutHandler.this.current.asInstanceOf[FrameOutHandler.this.CompletionHandlingState]
[warn]     current.asInstanceOf[CompletionHandlingState].onComplete(ctx)
[warn]                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\Handshake.scala:157: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class NegotiatedWebSocketSettings(subprotocol: Option[String])
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\Handshake.scala:269: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   subs.get
[warn]           else if (subs.nonEmpty && subprotocols.contains(subs.get)) Right(NegotiatedWebSocketSettings(Some(subs.get)))
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\Handshake.scala:269: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   subs.get
[warn]           else if (subs.nonEmpty && subprotocols.contains(subs.get)) Right(NegotiatedWebSocketSettings(Some(subs.get)))
[warn]                                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\Handshake.scala:67: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val hostHeaderPresent: Boolean = _).
[warn]     def websocketUpgrade(headers: List[HttpHeader], hostHeaderPresent: Boolean): OptionVal[UpgradeToWebSocket] = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\MessageToFrameRenderer.scala:20: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val serverSide: Boolean = _).
[warn]   def create(serverSide: Boolean): Flow[Message, FrameStart, NotUsed] = {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\Protocol.scala:54: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Other(override val code: Byte) extends AbstractOpcode(code)
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\Protocol.scala:84: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[http] case class ProtocolException(cause: String) extends RuntimeException(cause)
[info]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\WebSocket.scala:75: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Truncated message, peer closed connection in the middle of message.").s()
[warn]           else if (inMessage) failStage(new ProtocolException(s"Truncated message, peer closed connection in the middle of message."))
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\engine\ws\WebSocket.scala:74: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   code.get
[warn]           if (code.exists(Protocol.CloseCodes.isError)) failStage(new PeerClosedConnectionException(code.get, reason))
[warn]                                                                                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\JavaQuery.scala:22: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class JavaQuery(query: sm.Uri.Query) extends jm.Query {
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\JavaUri.scala:16: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class JavaUri(uri: sm.Uri) extends jm.Uri {
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptCharsetHeader.scala:14: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `accept-charset` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptCharsetHeader.scala:18: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `charset-range-decl` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptCharsetHeader.scala:27: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `charset-range-def` = rule {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptCharsetHeader.scala:14: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptCharsetHeader.this.cursor
[warn]   def `accept-charset` = rule {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptCharsetHeader.scala:18: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptCharsetHeader.this.cursor
[warn]   def `charset-range-decl` = rule {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptCharsetHeader.scala:27: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptCharsetHeader.this.cursor
[warn]   def `charset-range-def` = rule {
[warn]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptEncodingHeader.scala:13: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `accept-encoding` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptEncodingHeader.scala:17: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `encoding-range-decl` = rule {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptEncodingHeader.scala:13: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptEncodingHeader.this.cursor
[warn]   def `accept-encoding` = rule {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptEncodingHeader.scala:17: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptEncodingHeader.this.cursor
[warn]   def `encoding-range-decl` = rule {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptEncodingHeader.scala:26: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptEncodingHeader.this.cursor
[warn]   def codings = rule { ws('*') ~ push(HttpEncodingRange.`*`) | token ~> getEncoding }
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptHeader.scala:20: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `media-range-decl` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptHeader.scala:36: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `media-range-def` = rule {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptHeader.scala:16: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptHeader.this.cursor
[warn]   def accept = rule {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptHeader.scala:20: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptHeader.this.cursor
[warn]   def `media-range-decl` = rule {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptHeader.scala:36: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptHeader.this.cursor
[warn]   def `media-range-def` = rule {
[warn]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptLanguageHeader.scala:13: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `accept-language` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptLanguageHeader.scala:17: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `language-range-decl` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptLanguageHeader.scala:26: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `language-range` = rule { ws('*') ~ push(LanguageRange.`*`) | language ~> (LanguageRange(_)) }
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptLanguageHeader.scala:13: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptLanguageHeader.this.cursor
[warn]   def `accept-language` = rule {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptLanguageHeader.scala:17: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptLanguageHeader.this.cursor
[warn]   def `language-range-decl` = rule {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\AcceptLanguageHeader.scala:26: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = AcceptLanguageHeader.this.cursor
[warn]   def `language-range` = rule { ws('*') ~ push(LanguageRange.`*`) | language ~> (LanguageRange(_)) }
[warn]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:14: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cache-control` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:18: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cache-directive` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:33: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `field-names` = rule { `quoted-tokens` | token ~> (Seq(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:35: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `quoted-tokens` = rule { '"' ~ zeroOrMore(`quoted-tokens-elem`).separatedBy(listSep) ~ '"' }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:37: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `quoted-tokens-elem` = rule {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:14: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CacheControlHeader.this.cursor
[warn]   def `cache-control` = rule {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:18: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CacheControlHeader.this.cursor
[warn]   def `cache-directive` = rule(
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:33: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CacheControlHeader.this.cursor
[warn]   def `field-names` = rule { `quoted-tokens` | token ~> (Seq(_)) }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CacheControlHeader.this.cursor
[warn]   def `quoted-tokens` = rule { '"' ~ zeroOrMore(`quoted-tokens-elem`).separatedBy(listSep) ~ '"' }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CacheControlHeader.scala:37: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CacheControlHeader.this.cursor
[warn]   def `quoted-tokens-elem` = rule {
[warn]                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:14: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def ALPHA = CharPredicate.Alpha
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:15: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def LOWER_ALPHA = CharPredicate.LowerAlpha
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:16: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def UPPER_ALPHA = CharPredicate.UpperAlpha
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:17: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def CR = '\r'
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:19: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def DIGIT = CharPredicate.Digit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:20: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def ALPHANUM = CharPredicate.AlphaNum
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:21: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def DQUOTE = '"'
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:22: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def HEXDIG = CharPredicate.HexDigit
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:23: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def HTAB = '\t'
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def LF = '\n'
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:25: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def SP = ' '
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:26: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def VCHAR = CharPredicate.Visible
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CharacterClasses.scala:80: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def DIGIT19 = CharPredicate.Digit19
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:249: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `cookie-value-rfc-6265` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:310: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `origin-list-or-null` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:362: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `suffix-byte-range-spec` = rule { '-' ~ `suffix-length` ~> (ByteRange.suffix(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:20: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def CRLF = rule { CR ~ LF }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:22: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def OCTET = rule { ANY }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:28: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def OWS = rule { zeroOrMore(optional(CRLF) ~ oneOrMore(WSP)) } // extended with `obs-fold`
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:30: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def RWS = rule { oneOrMore(optional(CRLF) ~ oneOrMore(WSP)) } // extended with `obs-fold`
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:39: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `quoted-string`: Rule1[String] = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:45: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `obs-text` = rule { "\u0080" - "\uFFFE" }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:47: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `quoted-pair` = rule { '\\' ~ (`quotable-base` | `obs-text`) ~ appendSB() }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:54: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `nested-comment` = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:61: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `quoted-cpair` = `quoted-pair`
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:67: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `expires-date`: Rule1[DateTime] = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:76: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `HTTP-date`: Rule1[DateTime] = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:80: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `IMF-fixdate` = rule { // mixture of the spec-ed `IMF-fixdate` and `rfc850-date`
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:86: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `day-name` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:99: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `time-of-day` = rule { hour ~ ':' ~ minute ~ ':' ~ second }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:111: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `day-name-l` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:115: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `asctime-date` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:139: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `media-type`: RuleN[String :: String :: Seq[(String, String)] :: HNil] = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:160: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `primary-tag` = rule { capture(oneOrMore(ALPHA)) ~ OWS }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:162: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `sub-tag` = rule { capture(oneOrMore(ALPHANUM)) ~ OWS }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:168: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `auth-scheme` = rule { token }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:170: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `auth-param` = rule { token ~ ws('=') ~ word }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:181: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `challenge-or-credentials`: Rule2[String, Seq[(String, String)]] = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:192: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `delta-seconds` = rule { longNumberCappedAtIntMaxValue }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:198: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `entity-tag` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:202: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `opaque-tag` = rule { '"' ~ capture(zeroOrMore(`etagc-base` | `obs-text`)) ~ '"' }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:211: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `basic-credential-def` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:215: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `basic-cookie` = rule { `token68` }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:218: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `oauth2-bearer-token` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:222: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `generic-credentials` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:230: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `optional-cookie-pair`: Rule1[Option[HttpCookiePair]] = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:236: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cookie-pair`: Rule1[HttpCookiePair] = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:240: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cookie-name` = rule { token }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:243: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cookie-value`: Rule1[String]
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:249: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cookie-value-rfc-6265` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:253: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cookie-value-raw` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:257: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cookie-av` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:261: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `expires-av` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:265: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `max-age-av` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:269: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `domain-av` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:275: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `domain-value` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:279: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `path-av` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:284: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `path-value` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:288: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `secure-av` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:292: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `httponly-av` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:297: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `extension-av` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:310: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `origin-list-or-null` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:314: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `origin-list` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:322: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `byte-content-range` = rule { `bytes-unit` ~ (`byte-range-resp` | `unsatisfied-range`) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:324: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `byte-range` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:328: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `byte-range-resp` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:332: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `byte-range-set` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:336: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `byte-range-spec` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:340: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `byte-ranges-specifier` = rule { `bytes-unit` ~ ws('=') ~ `byte-range-set` }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:342: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `bytes-unit` = rule { "bytes" ~ OWS ~ push(RangeUnits.Bytes) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:344: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `complete-length` = rule { longNumberCapped }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:346: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `first-byte-pos` = rule { longNumberCapped }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:348: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `last-byte-pos` = rule { longNumberCapped }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:350: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `other-content-range` = rule { `other-range-unit` ~ `other-range-resp` }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:352: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `other-range-resp` = rule { capture(zeroOrMore(ANY)) ~> ContentRange.Other }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:354: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `other-range-set` = rule { oneOrMore(VCHAR) ~ OWS }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:356: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `other-range-unit` = rule { token ~> RangeUnits.Other }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:358: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `other-ranges-specifier` = rule { `other-range-unit` ~ ws('=') ~ `other-range-set` }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:360: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `range-unit` = rule { `bytes-unit` | `other-range-unit` }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:362: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `suffix-byte-range-spec` = rule { '-' ~ `suffix-length` ~> (ByteRange.suffix(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:364: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `suffix-length` = rule { longNumberCapped }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:366: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `unsatisfied-range` = rule { '*' ~ '/' ~ `complete-length` ~> (ContentRange.Unsatisfiable(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:374: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `product-version` = rule { token }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:376: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `product-or-comment` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:389: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `transfer-coding` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:396: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `transfer-extension` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:400: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `transfer-parameter` = rule { token ~ ws('=') ~ word ~> (_ → _) }
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:55: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var saved: String = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:20: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def CRLF = rule { CR ~ LF }
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:28: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def OWS = rule { zeroOrMore(optional(CRLF) ~ oneOrMore(WSP)) } // extended with `obs-fold`
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:30: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def RWS = rule { oneOrMore(optional(CRLF) ~ oneOrMore(WSP)) } // extended with `obs-fold`
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def word = rule { token | `quoted-string` }
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:37: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def token: Rule1[String] = rule { capture(token0) ~ OWS }
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `quoted-string`: Rule1[String] = rule {
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:43: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def qdtext = rule { `qdtext-base` | `obs-text` }
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:47: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `quoted-pair` = rule { '\\' ~ (`quotable-base` | `obs-text`) ~ appendSB() }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:50: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def comment: Rule0 = rule {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:59: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def ctext = rule { (`ctext-base` | `obs-text`) ~ appendSB() }
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:67: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `expires-date`: Rule1[DateTime] = rule {
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:76: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `HTTP-date`: Rule1[DateTime] = rule {
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:80: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `IMF-fixdate` = rule { // mixture of the spec-ed `IMF-fixdate` and `rfc850-date`
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:86: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `day-name` = rule(
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:89: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def date1 = rule { day ~ `date-sep` ~ month ~ `date-sep` ~ year }
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:93: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def month = rule(
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:99: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `time-of-day` = rule { hour ~ ':' ~ minute ~ ':' ~ second }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:109: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def date2 = rule { day ~ '-' ~ month ~ '-' ~ digit2 ~> (y ? if (y <= 69) y + 2000 else y + 1900) }
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:111: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `day-name-l` = rule(
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:115: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `asctime-date` = rule {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:121: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def date3 = rule { month ~ ' ' ~ (digit2 | ' ' ~ digit) }
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:127: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def weight = rule { ws(';') ~ ws('q') ~ ws('=') ~ qvalue } // a bit more lenient than the spec
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:129: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def qvalue = rule { // a bit more lenient than the spec
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:139: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `media-type`: RuleN[String :: String :: Seq[(String, String)] :: HNil] = rule {
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:147: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def parameter = rule { attribute ~ ws('=') ~ value ~> ((_, _)) }
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:156: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def language = rule {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:160: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `primary-tag` = rule { capture(oneOrMore(ALPHA)) ~ OWS }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:162: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `sub-tag` = rule { capture(oneOrMore(ALPHANUM)) ~ OWS }
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:170: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `auth-param` = rule { token ~ ws('=') ~ word }
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:172: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `token68` = rule { capture(oneOrMore(`token68-start`) ~ zeroOrMore('=')) ~ OWS }
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:174: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def challenge = rule {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:181: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `challenge-or-credentials`: Rule2[String, Seq[(String, String)]] = rule {
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:198: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `entity-tag` = rule {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:202: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `opaque-tag` = rule { '"' ~ capture(zeroOrMore(`etagc-base` | `obs-text`)) ~ '"' }
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:207: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def credentials = rule {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:211: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `basic-credential-def` = rule {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:218: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `oauth2-bearer-token` = rule {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:222: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `generic-credentials` = rule {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:230: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `optional-cookie-pair`: Rule1[Option[HttpCookiePair]] = rule {
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:236: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `cookie-pair`: Rule1[HttpCookiePair] = rule {
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:249: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `cookie-value-rfc-6265` = rule {
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:253: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `cookie-value-raw` = rule {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:257: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `cookie-av` = rule {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:261: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `expires-av` = rule {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:265: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `max-age-av` = rule {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:269: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `domain-av` = rule {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:275: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `domain-value` = rule {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:279: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `path-av` = rule {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:284: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `path-value` = rule {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:288: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `secure-av` = rule {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:292: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `httponly-av` = rule {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:297: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `extension-av` = rule {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:310: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `origin-list-or-null` = rule {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:314: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `origin-list` = rule {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:322: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `byte-content-range` = rule { `bytes-unit` ~ (`byte-range-resp` | `unsatisfied-range`) }
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:324: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `byte-range` = rule {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:328: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `byte-range-resp` = rule {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:332: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `byte-range-set` = rule {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:336: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `byte-range-spec` = rule {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:340: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `byte-ranges-specifier` = rule { `bytes-unit` ~ ws('=') ~ `byte-range-set` }
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:342: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `bytes-unit` = rule { "bytes" ~ OWS ~ push(RangeUnits.Bytes) }
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:350: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `other-content-range` = rule { `other-range-unit` ~ `other-range-resp` }
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:352: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `other-range-resp` = rule { capture(zeroOrMore(ANY)) ~> ContentRange.Other }
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:354: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `other-range-set` = rule { oneOrMore(VCHAR) ~ OWS }
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:356: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `other-range-unit` = rule { token ~> RangeUnits.Other }
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:358: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `other-ranges-specifier` = rule { `other-range-unit` ~ ws('=') ~ `other-range-set` }
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:360: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `range-unit` = rule { `bytes-unit` | `other-range-unit` }
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:362: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `suffix-byte-range-spec` = rule { '-' ~ `suffix-length` ~> (ByteRange.suffix(_)) }
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:366: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `unsatisfied-range` = rule { '*' ~ '/' ~ `complete-length` ~> (ContentRange.Unsatisfiable(_)) }
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:372: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def product = rule { token ~ (ws('/') ~ `product-version` | push("")) }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:376: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `product-or-comment` = rule(
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:381: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def products = rule {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:389: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `transfer-coding` = rule(
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:396: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `transfer-extension` = rule {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:400: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def `transfer-parameter` = rule { token ~ ws('=') ~ word ~> (_ → _) }
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:405: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def token0 = rule { oneOrMore(tchar) }
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:407: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def listSep = rule { ',' ~ OWS }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:409: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def digit = rule { DIGIT ~ push(digitInt(lastChar)) }
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:411: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def digit2 = rule { DIGIT ~ DIGIT ~ push(digitInt(charAt(-2)) * 10 + digitInt(lastChar)) }
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:413: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def digit4 = rule {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:417: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def ws(c: Char) = rule { c ~ OWS }
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:418: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def ws(s: String) = rule { s ~ OWS }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:421: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def longNumberCappedAtIntMaxValue = rule {
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:426: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def longNumberCapped = rule(
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:440: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def httpMethodDef = rule {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\CommonRules.scala:450: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = CommonRules.this.cursor
[warn]   def uriReference: Rule1[Uri] = rule { runSubParser(newUriParser(_).`URI-reference-pushed`) }
[warn]                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:13: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `content-disposition` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:17: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `disposition-type` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:23: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `disp-ext-type` = rule { token }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:25: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `disposition-parm` = rule { (`filename-parm` | `disp-ext-parm`) ~> (_ → _) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:27: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `filename-parm` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:31: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `disp-ext-parm` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:35: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `ext-token` = rule { // token which ends with '*'
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:39: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `ext-value` = rule { word } // support full `ext-value` notation from http://tools.ietf.org/html/rfc5987#section-3.2.1
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:13: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = ContentDispositionHeader.this.cursor
[warn]   def `content-disposition` = rule {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:17: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = ContentDispositionHeader.this.cursor
[warn]   def `disposition-type` = rule(
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:25: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = ContentDispositionHeader.this.cursor
[warn]   def `disposition-parm` = rule { (`filename-parm` | `disp-ext-parm`) ~> (_ → _) }
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:27: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = ContentDispositionHeader.this.cursor
[warn]   def `filename-parm` = rule(
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:31: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = ContentDispositionHeader.this.cursor
[warn]   def `disp-ext-parm` = rule(
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentDispositionHeader.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = ContentDispositionHeader.this.cursor
[warn]   def `ext-token` = rule { // token which ends with '*'
[warn]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentTypeHeader.scala:14: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `content-type` = rule {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentTypeHeader.scala:23: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     builder: StringMapBuilder      = null): ContentType =
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentTypeHeader.scala:26: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   builder.eq(null)
[warn]         val parameters = if (builder eq null) Map.empty[String, String] else builder.result()
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentTypeHeader.scala:40: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   builder.eq(null)
[warn]         val b = if (builder eq null) Map.newBuilder[String, String] else builder
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentTypeHeader.scala:32: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   charset.get
[warn]             val cs = if (charset.isDefined) charset.get else HttpCharsets.`UTF-8`
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\ContentTypeHeader.scala:14: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = ContentTypeHeader.this.cursor
[warn]   def `content-type` = rule {
[warn]                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:44: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `header-field-value`: Rule1[String] = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:47: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `field-value` = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:55: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `field-value-chunk` = rule { oneOrMore(`field-value-char` ~ appendSB()) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:56: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `field-value-char` = rule { VCHAR | `obs-text` }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:57: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def FWS = rule { zeroOrMore(WSP) ~ zeroOrMore(`obs-fold`) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:58: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `obs-fold` = rule { CRLF ~ oneOrMore(WSP) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:77: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `cookie-value`: Rule1[String] =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:175: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Settings(
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:44: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = HeaderParser.this.cursor
[warn]   def `header-field-value`: Rule1[String] = rule {
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:55: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = HeaderParser.this.cursor
[warn]   def `field-value-chunk` = rule { oneOrMore(`field-value-char` ~ appendSB()) }
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:56: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = HeaderParser.this.cursor
[warn]   def `field-value-char` = rule { VCHAR | `obs-text` }
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:57: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = HeaderParser.this.cursor
[warn]   def FWS = rule { zeroOrMore(WSP) ~ zeroOrMore(`obs-fold`) }
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:58: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = HeaderParser.this.cursor
[warn]   def `obs-fold` = rule { CRLF ~ oneOrMore(WSP) }
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\HeaderParser.scala:75: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val input: akka.parboiled2.ParserInput = _
[warn]   def newUriParser(input: ParserInput): UriParser = new UriParser(input, uriParsingMode = settings.uriParsingMode)
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:12: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `ip-v4-address` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:16: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `ip-number` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `ip-v6-address`: Rule1[Array[Byte]] = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:61: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `ip-v6-reference`: Rule1[String] = rule { capture('[' ~ oneOrMore(HEXDIG | anyOf(":.")) ~ ']') }
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:26: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var a: Array[Byte] = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:12: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]   def `ip-v4-address` = rule {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:16: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]   def `ip-number` = rule {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:27: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def zero(ix: Int) = rule { run(a(ix) = 0.toByte) }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:28: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def zero2(ix: Int) = rule { run { a(ix) = 0.toByte; a(ix + 1) = 0.toByte; } }
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:29: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def h4(ix: Int) = rule { HEXDIG ~ run(a(ix) = hv(lastChar).toByte) }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:30: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def h8(ix: Int) = rule { HEXDIG ~ HEXDIG ~ run(a(ix) = (hv(charAt(-2)) * 16 + hv(lastChar)).toByte) }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:31: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def h16(ix: Int) = rule { h8(ix) ~ h8(ix + 1) | h4(ix) ~ h8(ix + 1) | zero(ix) ~ h8(ix + 1) | zero(ix) ~ h4(ix + 1) }
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:32: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def h16c(ix: Int) = rule { h16(ix) ~ ':' ~ !':' }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:33: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def ch16o(ix: Int) = rule { optional(':' ~ !':') ~ (h16(ix) | zero2(ix)) }
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:34: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def ls32 = rule { h16(12) ~ ':' ~ h16(14) | `ip-v4-address` ~> (System.arraycopy(_, 0, a, 12, 4)) }
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def cc(ix: Int) = rule { ':' ~ ':' ~ zero2(ix) }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:36: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def tail2 = rule { h16c(2) ~ tail4 }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:37: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def tail4 = rule { h16c(4) ~ tail6 }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:38: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def tail6 = rule { h16c(6) ~ tail8 }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def tail8 = rule { h16c(8) ~ tail10 }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:40: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]     def tail10 = rule { h16c(10) ~ ls32 }
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\IpAddressParsing.scala:61: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = IpAddressParsing.this.cursor
[warn]   def `ip-v6-reference`: Rule1[String] = rule { capture('[' ~ oneOrMore(HEXDIG | anyOf(":.")) ~ ']') }
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:20: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `link-value` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `link-param` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:35: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `relation-types` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:39: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `relation-type` = rule { `reg-rel-type` | `ext-rel-type` }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:41: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `reg-rel-type` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:45: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `ext-rel-type` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:51: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def UriReference(terminationChar: Char) = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:55: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def URI = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:65: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `link-media-type` = rule { `media-type` ~> ((mt, st, pm) ? getMediaType(mt, st, pm contains "charset", pm.toMap)) }
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:16: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def `link` = rule {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:20: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def `link-value` = rule {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:24: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def `link-param` = rule(
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def `relation-types` = rule(
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def `relation-type` = rule { `reg-rel-type` | `ext-rel-type` }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:41: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def `reg-rel-type` = rule {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:51: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def UriReference(terminationChar: Char) = rule {
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:55: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def URI = rule {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\LinkHeader.scala:65: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = LinkHeader.this.cursor
[warn]   def `link-media-type` = rule { `media-type` ~> ((mt, st, pm) ? getMediaType(mt, st, pm contains "charset", pm.toMap)) }
[warn]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:24: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `access-control-allow-credentials` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:29: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `access-control-allow-headers` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:34: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `access-control-allow-methods` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:39: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `access-control-allow-origin` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:44: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `access-control-expose-headers` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:49: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `access-control-max-age` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:54: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `access-control-request-headers` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:59: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def `access-control-request-method` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:18: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `accept-ranges` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `access-control-allow-credentials` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:29: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `access-control-allow-headers` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:34: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `access-control-allow-methods` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:39: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `access-control-allow-origin` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:44: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `access-control-expose-headers` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:49: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `access-control-max-age` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:54: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `access-control-request-headers` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:59: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `access-control-request-method` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:81: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `content-encoding` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:87: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `content-length` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:92: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `content-range` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:137: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `if-match` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:142: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `if-modified-since` = rule { `HTTP-date` ~ EOI ~> (`If-Modified-Since`(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:145: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `if-none-match` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:152: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `if-range` = rule { (`entity-tag` ~> (Left(_)) | `HTTP-date` ~> (Right(_))) ~ EOI ~> (`If-Range`(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:155: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `if-unmodified-since` = rule { `HTTP-date` ~ EOI ~> (`If-Unmodified-Since`(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:158: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `last-modified` = rule { `HTTP-date` ~ EOI ~> (`Last-Modified`(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:169: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `proxy-authenticate` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:174: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `proxy-authorization` = rule { credentials ~ EOI ~> (`Proxy-Authorization`(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:189: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `strict-transport-security` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:194: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `transfer-encoding` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:199: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `set-cookie` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:213: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `user-agent` = rule { products ~ EOI ~> (`User-Agent`(_)) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:216: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `www-authenticate` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:224: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `x-forwarded-for` = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:229: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `x-real-ip` = rule {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:18: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `accept-ranges` = rule {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:24: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `access-control-allow-credentials` = rule(
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:29: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `access-control-allow-headers` = rule {
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:34: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `access-control-allow-methods` = rule {
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `access-control-allow-origin` = rule(
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:44: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `access-control-expose-headers` = rule {
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:49: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `access-control-max-age` = rule {
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:54: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `access-control-request-headers` = rule {
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:59: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `access-control-request-method` = rule {
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:64: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def age = rule { `delta-seconds` ~ EOI ~> (Age(_)) }
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:67: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def allow = rule {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:72: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def authorization = rule { credentials ~ EOI ~> (Authorization(_)) }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:75: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def connection = rule {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:81: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `content-encoding` = rule {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:87: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `content-length` = rule {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:92: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `content-range` = rule {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:97: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `cookie` = rule {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:111: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `date` = rule {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:116: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def etag = rule { `entity-tag` ~ EOI ~> (ETag(_)) }
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:119: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `expect` = rule {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:124: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `expires` = rule { `expires-date` ~ EOI ~> (Expires(_)) }
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:132: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def host = rule {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:137: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `if-match` = rule(
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:142: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `if-modified-since` = rule { `HTTP-date` ~ EOI ~> (`If-Modified-Since`(_)) }
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:145: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `if-none-match` = rule {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:152: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `if-range` = rule { (`entity-tag` ~> (Left(_)) | `HTTP-date` ~> (Right(_))) ~ EOI ~> (`If-Range`(_)) }
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:155: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `if-unmodified-since` = rule { `HTTP-date` ~ EOI ~> (`If-Unmodified-Since`(_)) }
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:158: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `last-modified` = rule { `HTTP-date` ~ EOI ~> (`Last-Modified`(_)) }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:161: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def location = rule {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:166: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `origin` = rule { `origin-list-or-null` ~ EOI ~> (Origin(_)) }
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:169: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `proxy-authenticate` = rule {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:174: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `proxy-authorization` = rule { credentials ~ EOI ~> (`Proxy-Authorization`(_)) }
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:177: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `range` = rule { `byte-ranges-specifier` /*| `other-ranges-specifier` */ ~ EOI ~> (Range(_, _)) }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:180: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def referer = rule {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:187: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def server = rule { products ~ EOI ~> (Server(_)) }
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:189: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `strict-transport-security` = rule {
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:194: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `transfer-encoding` = rule {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:199: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `set-cookie` = rule {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:204: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def upgrade = rule {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:208: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def protocol = rule {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:213: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `user-agent` = rule { products ~ EOI ~> (`User-Agent`(_)) }
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:216: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `www-authenticate` = rule {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:225: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]     def addr = rule { (`ip-v4-address` | `ip-v6-address`) ~> (RemoteAddress(_)) | "unknown" ~ push(RemoteAddress.Unknown) }
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\SimpleHeaders.scala:229: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = SimpleHeaders.this.cursor
[warn]   def `x-real-ip` = rule {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:29: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def clearSB(): Rule0 = rule { run(sb.setLength(0)) }
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:31: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def appendSB(): Rule0 = rule { run(sb.append(lastChar)) }
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:33: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def appendSB(offset: Int): Rule0 = rule { run(sb.append(charAt(offset))) }
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def appendSB(c: Char): Rule0 = rule { run(sb.append(c)) }
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:37: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def appendSB(s: String): Rule0 = rule { run(sb.append(s)) }
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def prependSB(): Rule0 = rule { run(doPrepend(lastChar)) }
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:41: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def prependSB(offset: Int): Rule0 = rule { run(doPrepend(charAt(offset))) }
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:43: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def prependSB(c: Char): Rule0 = rule { run(doPrepend(c)) }
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:45: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def prependSB(s: String): Rule0 = rule { run(doPrepend(s)) }
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\StringBuilding.scala:47: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = StringBuilding.this.cursor
[warn]   def setSB(s: String): Rule0 = rule { run(doSet(s)) }
[warn]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:97: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def URI = rule { scheme ~ ':' ~ `hier-part` ~ optional('?' ~ rawQueryString) ~ optional('#' ~ fragment) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:101: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `hier-part` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:107: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `URI-reference` = rule { URI | `relative-ref` }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:109: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `URI-reference-pushed`: Rule1[Uri] = rule { `URI-reference` ~ push(createUriReference()) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:111: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `absolute-URI` = rule { scheme ~ ':' ~ `hier-part` ~ optional('?' ~ rawQueryString) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:113: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `relative-ref` = rule { `relative-part` ~ optional('?' ~ rawQueryString) ~ optional('#' ~ fragment) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:115: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `relative-part` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:133: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `hostAndPort-pushed` = rule { hostAndPort ~ push(_host) ~ push(_port) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:148: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `IP-literal` = rule { '[' ~ ipv6Host ~ ']' } // IPvFuture not currently recognized
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:153: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `reg-name` = rule(
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:158: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `path-abempty`  = rule { clearSB() ~ slashSegments ~ savePath() }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:159: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `path-absolute` = rule { clearSB() ~ '/' ~ appendSB('/') ~ optional(`segment-nz` ~ slashSegments) ~ savePath() }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:160: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `path-noscheme` = rule { clearSB() ~ `segment-nz-nc` ~ slashSegments ~ savePath() }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:161: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `path-rootless` = rule { clearSB() ~ `segment-nz` ~ slashSegments ~ savePath() }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:162: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `path-empty` = rule { MATCH }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:167: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `segment-nz` = rule { oneOrMore(pchar) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:168: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `segment-nz-nc` = rule { oneOrMore(!':' ~ pchar) }
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:216: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `pct-encoded` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:226: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `absolute-path` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:231: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `request-target` = rule(
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:97: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def URI = rule { scheme ~ ':' ~ `hier-part` ~ optional('?' ~ rawQueryString) ~ optional('#' ~ fragment) }
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:99: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def origin = rule { scheme ~ ':' ~ '/' ~ '/' ~ hostAndPort }
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:101: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `hier-part` = rule(
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:107: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `URI-reference` = rule { URI | `relative-ref` }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:109: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `URI-reference-pushed`: Rule1[Uri] = rule { `URI-reference` ~ push(createUriReference()) }
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:111: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `absolute-URI` = rule { scheme ~ ':' ~ `hier-part` ~ optional('?' ~ rawQueryString) }
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:113: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `relative-ref` = rule { `relative-part` ~ optional('?' ~ rawQueryString) ~ optional('#' ~ fragment) }
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:115: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `relative-part` = rule(
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:121: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def scheme = rule(
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:125: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def authority = rule { optional(userinfo) ~ hostAndPort }
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:127: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def userinfo = rule {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:131: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def hostAndPort = rule { host ~ optional(':' ~ port)  }
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:133: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `hostAndPort-pushed` = rule { hostAndPort ~ push(_host) ~ push(_port) }
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:135: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def host = rule { `IP-literal` | ipv4Host | `reg-name` }
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:138: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def relaxedHost = rule { `IP-literal` | ipv6Host | ipv4Host | `reg-name` }
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:140: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def port = rule {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:148: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `IP-literal` = rule { '[' ~ ipv6Host ~ ']' } // IPvFuture not currently recognized
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:150: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def ipv4Host = rule { capture(`ip-v4-address`) ~ &(colonSlashEOI) ~> ((b, a) => _host = IPv4Host(b, a)) }
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:151: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def ipv6Host = rule { capture(`ip-v6-address`) ~> ((b, a) => _host = IPv6Host(b, a)) }
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:153: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `reg-name` = rule(
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:158: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `path-abempty`  = rule { clearSB() ~ slashSegments ~ savePath() }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:159: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `path-absolute` = rule { clearSB() ~ '/' ~ appendSB('/') ~ optional(`segment-nz` ~ slashSegments) ~ savePath() }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:160: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `path-noscheme` = rule { clearSB() ~ `segment-nz-nc` ~ slashSegments ~ savePath() }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:161: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `path-rootless` = rule { clearSB() ~ `segment-nz` ~ slashSegments ~ savePath() }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:164: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def slashSegments = rule { zeroOrMore('/' ~ appendSB('/') ~ segment) }
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:166: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def segment = rule { zeroOrMore(pchar) }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:167: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `segment-nz` = rule { oneOrMore(pchar) }
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:168: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `segment-nz-nc` = rule { oneOrMore(!':' ~ pchar) }
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:170: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def pchar = rule { `path-segment-char` ~ appendSB() | `pct-encoded` }
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:172: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def rawQueryString = rule {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:178: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]     def part = rule(
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:182: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]     def keyValuePair: Rule2[String, String] = rule {
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:187: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]     def keyValuePairsWithLimitedStackUse: Rule1[Query] = rule {
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:197: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]     def keyValuePairsWithReversalAvoidance: Rule1[Query] = rule {
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:212: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def fragment = rule(
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:216: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `pct-encoded` = rule {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:226: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `absolute-path` = rule {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:231: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   def `request-target` = rule(
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:246: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   private def appendLowered(): Rule0 = rule { run(sb.append(CharUtils.toLowerCase(lastChar))) }
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:248: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   private def savePath() = rule { run(_path = Path(sb.toString, uriParsingCharset)) }
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\UriParser.scala:252: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = UriParser.this.cursor
[warn]   private def clearSBForDecoding(): Rule0 = rule { run { sb.setLength(0); firstPercentIx = -1 } }
[warn]                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:15: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `sec-websocket-accept` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:19: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `sec-websocket-extensions` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:23: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `sec-websocket-key` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:27: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `sec-websocket-protocol` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:31: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def `sec-websocket-version` = rule {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:35: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def `base64-value-non-empty` = rule {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:38: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def `base64-data` = rule { 4.times(`base64-character`) }
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:39: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def `base64-padding` = rule {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:43: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def `base64-character` = rfc2045Alphabet
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:49: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def `extension-token`: Rule1[String] = token
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:50: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def `extension-param`: Rule1[(String, String)] =
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:60: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def NZDIGIT = DIGIT19
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:15: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   def `sec-websocket-accept` = rule {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:19: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   def `sec-websocket-extensions` = rule {
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:23: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   def `sec-websocket-key` = rule {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:27: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   def `sec-websocket-protocol` = rule {
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:31: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   def `sec-websocket-version` = rule {
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   private def `base64-value-non-empty` = rule {
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:38: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   private def `base64-data` = rule { 4.times(`base64-character`) }
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   private def `base64-padding` = rule {
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:45: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   private def extension = rule {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:51: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]     rule {
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\model\parser\WebSocketHeaders.scala:55: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val start: Int = WebSocketHeaders.this.cursor
[warn]   private def version = rule {
[warn]                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\EnhancedByteArray.scala:25: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def secure_==(other: Array[Byte]): Boolean = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\EnhancedString.scala:84: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EnhancedString.this.underlying.charAt(ix.-(offset)).asInstanceOf[Byte]
[warn]         array(ix) = underlying.charAt(ix - offset).asInstanceOf[Byte]
[warn]                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\EnhancedString.scala:101: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def secure_==(other: String): Boolean = asciiBytes secure_== other.asciiBytes
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\EnhancedString.scala:65: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EnhancedString.this.underlying.eq(null)
[warn]     if (underlying eq null) "" else underlying
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaAccessors.scala:21: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def HttpRequest(): HttpRequest = model.HttpRequest()
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaAccessors.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def HttpRequest(uri: String): HttpRequest = model.HttpRequest(uri = uri)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaAccessors.scala:27: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def HttpResponse(): HttpResponse = model.HttpResponse()
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaAccessors.scala:30: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def HttpEntity(contentType: ContentType, file: File): UniversalEntity =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaAccessors.scala:34: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def HttpEntity(contentType: ContentType, file: Path): UniversalEntity =
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:88: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   JavaMapping.this._identityMapping.asInstanceOf[akka.http.impl.util.JavaMapping[T,T]]
[warn]   def identity[T]: JavaMapping[T, T] = _identityMapping.asInstanceOf[JavaMapping[T, T]]
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:252: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   classTag.runtimeClass.cast(obj).asInstanceOf[T]
[warn]     try classTag.runtimeClass.cast(obj).asInstanceOf[T]
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:256: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Please use only the provided factories in akka.http.javadsl.model.Http").s()
[warn]           s"Please use only the provided factories in akka.http.javadsl.model.Http")
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:79: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     implicit def AddAsScala[J](javaObject: J)(implicit mapping: J2SMapping[J]): AsScala[mapping.S] = new AsScala[mapping.S] {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:82: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     implicit def AddAsJava[S](scalaObject: S)(implicit mapping: S2JMapping[S]): AsJava[mapping.J] = new AsJava[mapping.J] {
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:90: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def toJava(scalaObject: Any): Any = scalaObject
[warn]     def toJava(scalaObject: Any): Any = scalaObject
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:91: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def toScala(javaObject: Any): Any = javaObject
[warn]     def toScala(javaObject: Any): Any = javaObject
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:254: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (exp @ (_: ClassCastException)) => throw new scala.`package`.IllegalArgumentException(scala.Str
[warn]       case exp: ClassCastException ?
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:98: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val scalaObject: _S = _
[warn]       def toJava(scalaObject: immutable.Seq[_S]): jl.Iterable[_J] = scalaObject.map(mapping.toJava).asJavaCollection
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:110: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val javaObject: _J = _
[warn]       def toScala(javaObject: Optional[_J]): Option[_S] = OptionConverters.toScala(javaObject).map(mapping.toScala)
[warn]                                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:111: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val scalaObject: _S = _
[warn]       def toJava(scalaObject: Option[_S]): Optional[_J] = OptionConverters.toJava(scalaObject.map(mapping.toJava))
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:117: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val javaObject: JOut = _
[warn]         scaladsl.Flow[SIn].map(inMapping.toJava).viaMat(javaObject)(scaladsl.Keep.right).map(outMapping.toScala)
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:120: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val scalaObject: SOut = _
[warn]           scaladsl.Flow[JIn].map(inMapping.toScala).viaMat(scalaObject)(scaladsl.Keep.right).map(outMapping.toJava)
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:127: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val javaObject: JOut = _
[warn]         scaladsl.Flow[SIn].map(inMapping.toJava).viaMat(javaObject)(scaladsl.Keep.right).map(outMapping.toScala)
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:130: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val scalaObject: SOut = _
[warn]           scaladsl.Flow[JIn].map(inMapping.toScala).viaMat(scalaObject)(scaladsl.Keep.right).map(outMapping.toJava)
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:148: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val javaObject: _J = _
[warn]       def toScala(javaObject: Try[_J]): S = javaObject.map(mapping.toScala)
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\JavaMapping.scala:149: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val scalaObject: _S = _
[warn]       def toJava(scalaObject: Try[_S]): J = scalaObject.map(mapping.toJava)
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\ObjectRegistry.scala:13: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type K
[warn] private[http] trait ObjectRegistry[K, V <: AnyRef] {
[warn]                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\One2OneBidiFlow.scala:18: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class UnexpectedOutputException(element: Any) extends RuntimeException(element.toString) with NoStackTrace
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:232: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   bytes.apply(ix).asInstanceOf[Char]
[warn]       if (ix < bytes.length) { this ~~ bytes(ix).asInstanceOf[Char]; rec(ix + 1) } else this
[warn]                                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:158: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def ~~%(i: Int): this.type = this ~~% i.toLong
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:163: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def ~~%(lng: Long): this.type =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:190: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def ~~#(s: String): this.type =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:196: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def ~~#!(s: String): this.type = ~~('"').putEscaped(s) ~~ '"'
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:265: [scapegoat] Avoid Traversable.size != 0
[warn]   .size can be slow for some data structures, prefer .nonEmpty, which is O(1).
[warn]   bytes.length.>(0)
[warn]     if (bytes.length > 0) {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:307: [scapegoat] Avoid Traversable.size != 0
[warn]   .size can be slow for some data structures, prefer .nonEmpty, which is O(1).
[warn]   bytes.length.>(0)
[warn]     if (bytes.length > 0) builder ++= bytes
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:340: [scapegoat] Avoid Traversable.size != 0
[warn]   .size can be slow for some data structures, prefer .nonEmpty, which is O(1).
[warn]   bytes.length.>(0)
[warn]     if (bytes.length > 0) {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:55: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LazyValueBytesRenderable.this._valueBytes.!=(null)
[warn]     if (_valueBytes != null) _valueBytes else { _valueBytes = value.asciiBytes; _valueBytes }
[warn]                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:214: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `, ` extends SingletonValueRenderable // default separator
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:107: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   value.get
[warn]         if (value.isEmpty) sRenderer.render(r, defaultValue) else tRenderer.render(r, value.get)
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:125: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   remaining.head
[warn]             tRenderer.render(r, remaining.head)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\Rendering.scala:126: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   remaining.tail
[warn]             recL(remaining.tail)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\SettingsCompanion.scala:36: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   SettingsCompanion.this.cache.tail
[warn]         else cache.tail // drop the first (and oldest) cache entry
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\SingletonException.scala:15: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SingletonException.this.<init>(null)
[warn]   def this() = this(null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\SocketOptionSettings.scala:15: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val root: com.typesafe.config.Config = _).
[warn]   def fromSubConfig(root: Config, c: Config): immutable.Seq[SocketOption] = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\StreamUtils.scala:51: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.stream.impl.ErrorPublisher.apply(ex, "failed").asInstanceOf[org.reactivestreams.Publisher[T]]
[warn]     impl.ErrorPublisher(ex, "failed").asInstanceOf[Publisher[T]]
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\StreamUtils.scala:216: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       if (!compareAndSet(null.asInstanceOf[T], value))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\StreamUtils.scala:232: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   $anon.this._source.asInstanceOf[akka.stream.scaladsl.Source[T,akka.NotUsed]]
[warn]       def source[T]: Source[T, NotUsed] = _source.asInstanceOf[Source[T, NotUsed]] // safe, because source won't generate any elements
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\StreamUtils.scala:211: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   value.!=(null)
[warn]       require(value != null, "Value wasn't set yet")
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\StreamUtils.scala:184: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         @volatile private var subscriber: Subscriber[_ >: Out] = null
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\StreamUtils.scala:172: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[In] = _
[warn]     override protected def newInstance(shape: SinkShape[In]): SinkModule[In, Publisher[In]] =
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\StreamUtils.scala:198: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[Out] = _
[warn]     override protected def newInstance(shape: SourceShape[Out]): SourceModule[Out, Subscriber[Out]] =
[warn]                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\package.scala:39: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private[http] implicit def enhanceString_(s: String): EnhancedString = new EnhancedString(s)
[info]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\impl\util\package.scala:61: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AddFutureAwaitResult.this.future.value.get
[warn]       future.value.get match {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\ConnectHttp.scala:109: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val context: akka.http.javadsl.HttpsConnectionContext = _
[warn]   override def withCustomHttpsContext(context: HttpsConnectionContext): ConnectWithHttps =
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\Http.scala:42: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   in.asInstanceOf[java.util.concurrent.CompletionStage[U]]
[warn]   private implicit def completionStageCovariant[T, U >: T](in: CompletionStage[T]): CompletionStage[U] = in.asInstanceOf[CompletionStage[U]]
[warn]                                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\Http.scala:43: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   in.asInstanceOf[scala.concurrent.Future[S]]
[warn]   private implicit def javaModelIsScalaModel[J <: AnyRef, S <: J](in: Future[J])(implicit ev: JavaMapping.Inherited[J, S]): Future[S] = in.asInstanceOf[Future[S]]
[warn]                                                                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\Http.scala:175: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[akka.stream.javadsl.Flow[akka.http.scaladsl.model.HttpRequest, akka.http.scaladsl.model.HttpResponse, _]]
[warn]       handler.asInstanceOf[Flow[sm.HttpRequest, sm.HttpResponse, _]].asScala,
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\Http.scala:198: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[akka.stream.javadsl.Flow[akka.http.scaladsl.model.HttpRequest, akka.http.scaladsl.model.HttpResponse, _]]
[warn]       handler.asInstanceOf[Flow[sm.HttpRequest, sm.HttpResponse, _]].asScala,
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\Http.scala:342: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   to.effectiveConnectionContext(Http.this.defaultClientHttpsContext).asInstanceOf[akka.http.javadsl.HttpsConnectionContext]
[warn]         delegate.outgoingConnectionHttps(to.host, to.port, to.effectiveConnectionContext(defaultClientHttpsContext).asInstanceOf[HttpsConnectionContext].asScala, localAddress.asScala, settings.asScala, log)
[warn]                                                                                                                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\Http.scala:33: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.http.javadsl.Http = Http.super.get(system)
[info]   override def get(system: ActorSystem): Http = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\Http.scala:43: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val ev: akka.http.impl.util.JavaMapping.Inherited[J,S] = _).
[warn]   private implicit def javaModelIsScalaModel[J <: AnyRef, S <: J](in: Future[J])(implicit ev: JavaMapping.Inherited[J, S]): Future[S] = in.asInstanceOf[Future[S]]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\IncomingConnection.scala:37: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.stream.javadsl.Flow.fromGraph[akka.http.scaladsl.model.HttpResponse, akka.http.scaladsl.model.HttpRequest, akka.NotUsed](IncomingConnection.this.delegate.flow).asInstanceOf[akka.stream.javadsl.Flow[akka.http.javadsl.model.HttpResponse,akka.http.javadsl.model.HttpRequest,akka.NotUsed]]
[warn]   def flow: Flow[HttpResponse, HttpRequest, NotUsed] = Flow.fromGraph(delegate.flow).asInstanceOf[Flow[HttpResponse, HttpRequest, NotUsed]]
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\IncomingConnection.scala:44: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.asInstanceOf[akka.stream.javadsl.Flow[akka.http.scaladsl.model.HttpRequest,akka.http.scaladsl.model.HttpResponse,Mat]]
[warn]     delegate.handleWith(handler.asInstanceOf[Flow[sm.HttpRequest, sm.HttpResponse, Mat]].asScala)(materializer)
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\IncomingConnection.scala:50: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   handler.apply(x$1).asInstanceOf[akka.http.scaladsl.model.HttpResponse]
[warn]     delegate.handleWithSyncHandler(handler.apply(_).asInstanceOf[sm.HttpResponse])(materializer)
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\IncomingConnection.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.CompletionStageOps[akka.http.javadsl.model.HttpResponse](handler.apply(x$2)).toScala.asInstanceOf[scala.concurrent.Future[akka.http.scaladsl.model.HttpResponse]]
[warn]     delegate.handleWithAsyncHandler(handler.apply(_).toScala.asInstanceOf[Future[sm.HttpResponse]])(materializer)
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\IncomingConnection.scala:62: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.CompletionStageOps[akka.http.javadsl.model.HttpResponse](handler.apply(x$3)).toScala.asInstanceOf[scala.concurrent.Future[akka.http.scaladsl.model.HttpResponse]]
[warn]     delegate.handleWithAsyncHandler(handler.apply(_).toScala.asInstanceOf[Future[sm.HttpResponse]], parallelism)(materializer)
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\javadsl\settings\ServerSettings.scala:70: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[akka.http.impl.settings.ServerSettingsImpl.Timeouts]
[warn]     protected def self = this.asInstanceOf[ServerSettingsImpl.Timeouts]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:524: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("WebSocket requests must use either \'ws\' or \'wss\'").s()
[warn]           s"WebSocket requests must use either 'ws' or 'wss'")
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:266: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def _outgoingConnection(
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:278: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def _outgoingTlsConnectionLayer(host: String, port: Int, localAddress: Option[InetSocketAddress],
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:226: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val mat: akka.stream.Materializer = _).
[warn]   def serverLayer(
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:278: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val log: akka.event.LoggingAdapter = _).
[warn]   private def _outgoingTlsConnectionLayer(host: String, port: Int, localAddress: Option[InetSocketAddress],
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:480: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val fm: akka.stream.Materializer = _).
[warn]   def singleRequest(
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:628: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val system: akka.actor.ActorSystem = _).
[warn]   private def clientFlow[T](settings: ConnectionPoolSettings)(f: HttpRequest ? (HttpRequest, PoolGateway))(
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:770: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val ec: scala.concurrent.ExecutionContextExecutor = _).
[warn]     def shutdown()(implicit ec: ExecutionContextExecutor): Future[Done] = gateway.shutdown()
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\Http.scala:630: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   implicit val system: akka.actor.ActorSystem = _
[warn]     system: ActorSystem, fm: Materializer): Flow[(HttpRequest, T), (Try[HttpResponse], T), NotUsed] = {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ContentRange.scala:41: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Default.this.instanceLength.get
[warn]     require(instanceLength.isEmpty || instanceLength.get > last, "instanceLength must be empty or > last")
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ContentRange.scala:45: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Default.this.instanceLength.get
[warn]       if (instanceLength.isDefined) r ~~ instanceLength.get else r ~~ '*'
[warn]                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ContentType.scala:99: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   private[http] case object `; charset=` extends SingletonValueRenderable
[info]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ContentType.scala:21: [scapegoat] Suspicious match on class object
[warn]   Matching on an companion object of a case class is probably not what you intended.
[warn]   case HttpCharsetRange.* => r.~~[akka.http.scaladsl.model.MediaRange](ContentTypeRange.this.mediaRange)(util.this.Renderer.renderableRenderer[akka.http.impl.util.Renderable])
[warn]     case HttpCharsetRange.`*` ? r ~~ mediaRange
[warn]          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\DateTime.scala:109: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def put_##[R <: Rendering](r: R, i: Int): r.type = r ~~ (i / 10 + '0').toChar ~~ (i % 10 + '0').toChar
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:89: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("You can configure this by setting `akka.http.[server|client].parsing.max-content-length` or calling `HttpEntity.withSizeLimit` ").s()
[warn]       s"You can configure this by setting `akka.http.[server|client].parsing.max-content-length` or calling `HttpEntity.withSizeLimit` " +
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:90: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("before materializing the dataBytes stream.").s()
[warn]       s"before materializing the dataBytes stream."
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:38: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class IllegalUriException(info: ErrorInfo) extends ExceptionWithErrorInfo(info)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:43: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class IllegalHeaderException(info: ErrorInfo) extends ExceptionWithErrorInfo(info)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:48: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class InvalidContentLengthException(info: ErrorInfo) extends ExceptionWithErrorInfo(info)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:53: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class ParsingException(info: ErrorInfo) extends ExceptionWithErrorInfo(info)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:58: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class IllegalRequestException(info: ErrorInfo, status: ClientError) extends ExceptionWithErrorInfo(info)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:65: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class IllegalResponseException(info: ErrorInfo) extends ExceptionWithErrorInfo(info)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:70: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class EntityStreamException(info: ErrorInfo) extends ExceptionWithErrorInfo(info)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:93: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class RequestTimeoutException(request: HttpRequest, message: String) extends RuntimeException(message)
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\ErrorInfo.scala:36: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   abstract class ExceptionWithErrorInfo extends scala.`package`.RuntimeException {

[warn]   <paramaccessor> private[this] val info: akka.http.scaladsl.model.ErrorInfo = _;

[warn]   def <init>(info: akka.http.scaladsl.model.ErrorInfo): akka.http.scaladsl.model.ExceptionWithErrorInfo = {

[warn]     ExceptionWithErrorInfo.super.<init>(info.formatPretty);

[warn]     ()

[warn]   }

[warn] }
[warn] abstract class ExceptionWithErrorInfo(info: ErrorInfo) extends RuntimeException(info.formatPretty)
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:31: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   case class `*`(qValue: Float) extends HttpCharsetRange {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:36: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:36: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:31: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class `*`(qValue: Float) extends HttpCharsetRange {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:38: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   object `*` extends `*`(1.0f)
[info]          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:33: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final def render[R <: Rendering](r: R): r.type = if (qValue < 1.0f) r ~~ "*;q=" ~~ qValue else r ~~ '*'
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:95: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: java.nio.charset.UnsupportedCharsetException)) => ()
[warn]       case e: java.nio.charset.UnsupportedCharsetException ? // ignore
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:56: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCharset.this._nioCharset.get
[warn]   def nioCharset: Charset = _nioCharset.get
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val qValue: Float = _
[warn]     def withQValue(qValue: Float) =
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:42: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val charset: akka.http.scaladsl.model.HttpCharset = _
[warn]     def matches(charset: HttpCharset) = this.charset.value.equalsIgnoreCase(charset.value)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpCharset.scala:43: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val qValue: Float = _
[warn]     def withQValue(qValue: Float) = One(charset, qValue)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:42: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   in.asInstanceOf[java.util.concurrent.CompletionStage[U]]
[warn]   private implicit def completionStageCovariant[T, U >: T](in: CompletionStage[T]): CompletionStage[U] = in.asInstanceOf[CompletionStage[U]]
[warn]                                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:156: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   HttpEntity.this.dataBytes.asInstanceOf[akka.stream.scaladsl.Source[akka.util.ByteString,AnyRef]]
[warn]     stream.javadsl.Source.fromGraph(dataBytes.asInstanceOf[Source[ByteString, AnyRef]])
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:513: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Chunked.this.chunks.asInstanceOf[akka.stream.scaladsl.Source[akka.http.javadsl.model.HttpEntity.ChunkStreamPart,AnyRef]]
[warn]       stream.javadsl.Source.fromGraph(chunks.asInstanceOf[Source[jm.HttpEntity.ChunkStreamPart, AnyRef]])
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:646: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x.asInstanceOf[T]
[warn]       case x: HttpEntity.Strict ? x.asInstanceOf[T] → FastFuture.successful(())
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:649: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   {

[warn]   <artifact> val x$19: akka.stream.scaladsl.Source[akka.util.ByteString,Any] = newData;

[warn]   <artifact> val x$20: akka.http.scaladsl.model.ContentType = x.copy$default$1;

[warn]   <artifact> val x$21: Long = x.copy$default$2;

[warn]   x.copy(x$20, x$21, x$19)

[warn] }.asInstanceOf[T]
[warn]         x.copy(data = newData).asInstanceOf[T] → whenCompleted
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:652: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   {

[warn]   <artifact> val x$22: akka.stream.scaladsl.Source[akka.http.scaladsl.model.HttpEntity.ChunkStreamPart,Any] = newChunks;

[warn]   <artifact> val x$23: akka.http.scaladsl.model.ContentType = x.copy$default$1;

[warn]   x.copy(x$23, x$22)

[warn] }.asInstanceOf[T]
[warn]         x.copy(chunks = newChunks).asInstanceOf[T] → whenCompleted
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:655: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   {

[warn]   <artifact> val x$24: akka.stream.scaladsl.Source[akka.util.ByteString,Any] = newData;

[warn]   <artifact> val x$25: akka.http.scaladsl.model.ContentType = x.copy$default$1;

[warn]   x.copy(x$25, x$24)

[warn] }.asInstanceOf[T]
[warn]         x.copy(data = newData).asInstanceOf[T] → whenCompleted
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:658: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   {

[warn]   <artifact> val x$26: akka.stream.scaladsl.Source[akka.util.ByteString,Any] = newData;

[warn]   <artifact> val x$27: akka.http.scaladsl.model.ContentType = x.copy$default$1;

[warn]   x.copy(x$27, x$26)

[warn] }.asInstanceOf[T]
[warn]         x.copy(data = newData).asInstanceOf[T] → whenCompleted
[warn]                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:561: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class LastChunk(extension: String = "", trailer: immutable.Seq[HttpHeader] = Nil) extends HttpEntity.ChunkStreamPart {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:327: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val contentType: akka.http.scaladsl.model.ContentType = _
[warn]     override def withContentType(contentType: ContentType): HttpEntity.Strict =
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:384: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val contentType: akka.http.scaladsl.model.ContentType = _
[warn]     def withContentType(contentType: ContentType): HttpEntity.Default =
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:438: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val contentType: akka.http.scaladsl.model.ContentType = _
[warn]     override def withContentType(contentType: ContentType): HttpEntity.CloseDelimited =
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:441: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val data: akka.stream.scaladsl.Source[akka.util.ByteString,Any] = _
[warn]     override def withData(data: Source[ByteString, Any]): HttpEntity.CloseDelimited = copy(data = data)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:459: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val contentType: akka.http.scaladsl.model.ContentType = _
[warn]     override def withContentType(contentType: ContentType): HttpEntity.IndefiniteLength =
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:462: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val data: akka.stream.scaladsl.Source[akka.util.ByteString,Any] = _
[warn]     override def withData(data: Source[ByteString, Any]): HttpEntity.IndefiniteLength = copy(data = data)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpEntity.scala:502: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val contentType: akka.http.scaladsl.model.ContentType = _
[warn]     def withContentType(contentType: ContentType): HttpEntity.Chunked =
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpHeader.scala:92: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   h.asInstanceOf[T]
[warn]       case h if clazz.isInstance(h) ? return OptionVal.Some[T](h.asInstanceOf[T])
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpHeader.scala:84: [scapegoat] Use of Either.right or Either.left projection followed by a get
[warn]   Method .get on a Left and a Right projection is deprecated since 2.13, use Either.getOrElse or Either.swap.getOrElse instead.
[warn]   info.left.get
[warn]           ParsingResult.Error(info.left.get.withSummaryPrepended(s"Illegal HTTP header value"))
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpHeader.scala:84: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Illegal HTTP header value").s()
[warn]           ParsingResult.Error(info.left.get.withSummaryPrepended(s"Illegal HTTP header value"))
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpHeader.scala:86: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Illegal HTTP header name").s()
[warn]     } else ParsingResult.Error(ErrorInfo(s"Illegal HTTP header name", name))
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:106: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.reflect.`package`.classTag[T](evidence$1).runtimeClass.asInstanceOf[Class[T]]
[warn]     val clazz = classTag[T].runtimeClass.asInstanceOf[Class[T]]
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:109: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.Some.apply[akka.http.scaladsl.model.headers.Content-Type](headers.Content-Type.apply(HttpMessage.this.entity().contentType)).asInstanceOf[Option[T]]
[warn]       case _ if clazz == classOf[`Content-Type`] ? Some(`Content-Type`(entity.contentType)).asInstanceOf[Option[T]]
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:121: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   header.asInstanceOf[akka.http.scaladsl.model.HttpHeader]
[warn]   def addHeader(header: jm.HttpHeader): Self = mapHeaders(_ :+ header.asInstanceOf[HttpHeader])
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:135: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   contentType.asInstanceOf[akka.http.scaladsl.model.ContentType.NonBinary]
[warn]     withEntity(HttpEntity(contentType.asInstanceOf[ContentType.NonBinary], string))
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:136: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   contentType.asInstanceOf[akka.http.scaladsl.model.ContentType]
[warn]   def withEntity(contentType: jm.ContentType, bytes: Array[Byte]): Self = withEntity(HttpEntity(contentType.asInstanceOf[ContentType], bytes))
[warn]                                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:137: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   contentType.asInstanceOf[akka.http.scaladsl.model.ContentType]
[warn]   def withEntity(contentType: jm.ContentType, bytes: ByteString): Self = withEntity(HttpEntity(contentType.asInstanceOf[ContentType], bytes))
[warn]                                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:140: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   contentType.asInstanceOf[akka.http.scaladsl.model.ContentType]
[warn]   def withEntity(contentType: jm.ContentType, file: File): Self = withEntity(HttpEntity(contentType.asInstanceOf[ContentType], file))
[warn]                                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:141: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   contentType.asInstanceOf[akka.http.scaladsl.model.ContentType]
[warn]   def withEntity(contentType: jm.ContentType, file: Path): Self = withEntity(HttpEntity.fromPath(contentType.asInstanceOf[ContentType], file))
[warn]                                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:149: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   h.asInstanceOf[T]
[warn]       case OptionVal.Some(h) ? Optional.of(h.asInstanceOf[T])
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:158: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.collection.JavaConverters.iterableAsScalaIterableConverter[akka.http.javadsl.model.HttpHeader](headers).asScala.asInstanceOf[Iterable[akka.http.scaladsl.model.HttpHeader]]
[warn]   def addHeaders(headers: JIterable[jm.HttpHeader]): Self = mapHeaders(_ ++ headers.asScala.asInstanceOf[Iterable[HttpHeader]])
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:263: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   entity.asInstanceOf[akka.http.scaladsl.model.RequestEntity]
[warn]   override def withEntity(entity: jm.RequestEntity): HttpRequest = copy(entity = entity.asInstanceOf[RequestEntity])
[warn]                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:268: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   method.asInstanceOf[akka.http.scaladsl.model.HttpMethod]
[warn]   override def withMethod(method: akka.http.javadsl.model.HttpMethod): HttpRequest = copy(method = method.asInstanceOf[HttpMethod])
[warn]                                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:269: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   protocol.asInstanceOf[akka.http.scaladsl.model.HttpProtocol]
[warn]   override def withProtocol(protocol: akka.http.javadsl.model.HttpProtocol): HttpRequest = copy(protocol = protocol.asInstanceOf[HttpProtocol])
[warn]                                                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:406: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   protocol.asInstanceOf[akka.http.scaladsl.model.HttpProtocol]
[warn]   override def withProtocol(protocol: akka.http.javadsl.model.HttpProtocol): akka.http.javadsl.model.HttpResponse = copy(protocol = protocol.asInstanceOf[HttpProtocol])
[warn]                                                                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:408: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   statusCode.asInstanceOf[akka.http.scaladsl.model.StatusCode]
[warn]   override def withStatus(statusCode: akka.http.javadsl.model.StatusCode): akka.http.javadsl.model.HttpResponse = copy(status = statusCode.asInstanceOf[StatusCode])
[warn]                                                                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:412: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   entity.asInstanceOf[akka.http.scaladsl.model.ResponseEntity]
[warn]   override def withEntity(entity: jm.ResponseEntity): HttpResponse = copy(entity = entity.asInstanceOf[ResponseEntity])
[warn]                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:109: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   clazz.==(classOf[akka.http.scaladsl.model.headers.Content$minusType])
[warn]       case _ if clazz == classOf[`Content-Type`] ? Some(`Content-Type`(entity.contentType)).asInstanceOf[Option[T]]
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:223: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   HttpRequest.this.entity.isInstanceOf[akka.http.scaladsl.model.HttpEntity.Chunked]
[warn]     protocol != HttpProtocols.`HTTP/1.0` || !entity.isInstanceOf[HttpEntity.Chunked],
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:394: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   HttpResponse.this.entity.isInstanceOf[akka.http.scaladsl.model.HttpEntity.Chunked]
[warn]     protocol == HttpProtocols.`HTTP/1.1` || !entity.isInstanceOf[HttpEntity.Chunked],
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:467: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OptHttpRequest.this.get.==(null)
[warn]   def isEmpty: Boolean = get == null
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:471: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OptHttpResponse.this.get.==(null)
[warn]   def isEmpty: Boolean = get == null
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:164: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   connectionHeader.get
[warn]       case HttpProtocols.`HTTP/1.1` ? connectionHeader.isDefined && connectionHeader.get.hasClose
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:165: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   connectionHeader.get
[warn]       case HttpProtocols.`HTTP/1.0` ? connectionHeader.isEmpty || !connectionHeader.get.hasKeepAlive
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:100: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   x.encodings.head
[warn]     case Some(x) ? x.encodings.head
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:259: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: scala.collection.immutable.Seq[akka.http.scaladsl.model.HttpHeader] = _
[warn]   override def withHeaders(headers: immutable.Seq[HttpHeader]): HttpRequest =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:262: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: scala.collection.immutable.Seq[akka.http.scaladsl.model.HttpHeader] = _
[warn]   override def withHeadersAndEntity(headers: immutable.Seq[HttpHeader], entity: RequestEntity): HttpRequest = copy(headers = headers, entity = entity)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:262: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.scaladsl.model.RequestEntity = _
[warn]   override def withHeadersAndEntity(headers: immutable.Seq[HttpHeader], entity: RequestEntity): HttpRequest = copy(headers = headers, entity = entity)
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:263: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.javadsl.model.RequestEntity = _
[warn]   override def withEntity(entity: jm.RequestEntity): HttpRequest = copy(entity = entity.asInstanceOf[RequestEntity])
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:264: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.scaladsl.model.MessageEntity = _
[warn]   override def withEntity(entity: MessageEntity): HttpRequest = copy(entity = entity)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:268: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val method: akka.http.javadsl.model.HttpMethod = _
[warn]   override def withMethod(method: akka.http.javadsl.model.HttpMethod): HttpRequest = copy(method = method.asInstanceOf[HttpMethod])
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:269: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val protocol: akka.http.javadsl.model.HttpProtocol = _
[warn]   override def withProtocol(protocol: akka.http.javadsl.model.HttpProtocol): HttpRequest = copy(protocol = protocol.asInstanceOf[HttpProtocol])
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:271: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val uri: akka.http.scaladsl.model.Uri = _
[warn]   def withUri(uri: Uri): HttpRequest = copy(uri = uri)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:277: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val uri: akka.http.javadsl.model.Uri = _
[warn]   override def withUri(uri: jm.Uri): HttpRequest = copy(uri = uri.asScala)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:282: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val method: akka.http.scaladsl.model.HttpMethod = method
[warn]     method:   HttpMethod                = method,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:283: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val uri: akka.http.scaladsl.model.Uri = uri
[warn]     uri:      Uri                       = uri,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:284: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: scala.collection.immutable.Seq[akka.http.scaladsl.model.HttpHeader] = headers
[warn]     headers:  immutable.Seq[HttpHeader] = headers,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:285: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.scaladsl.model.RequestEntity = entity
[warn]     entity:   RequestEntity             = entity,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:286: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val protocol: akka.http.scaladsl.model.HttpProtocol = protocol
[warn]     protocol: HttpProtocol              = protocol) = new HttpRequest(method, uri, headers, entity, protocol)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:328: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: scala.collection.immutable.Seq[akka.http.scaladsl.model.HttpHeader] = _
[warn]     def findHost(headers: immutable.Seq[HttpHeader]): OptionVal[Host] = {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:403: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: scala.collection.immutable.Seq[akka.http.scaladsl.model.HttpHeader] = _
[warn]   override def withHeaders(headers: immutable.Seq[HttpHeader]) =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:406: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val protocol: akka.http.javadsl.model.HttpProtocol = _
[warn]   override def withProtocol(protocol: akka.http.javadsl.model.HttpProtocol): akka.http.javadsl.model.HttpResponse = copy(protocol = protocol.asInstanceOf[HttpProtocol])
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:410: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: scala.collection.immutable.Seq[akka.http.scaladsl.model.HttpHeader] = _
[warn]   override def withHeadersAndEntity(headers: immutable.Seq[HttpHeader], entity: MessageEntity): HttpResponse = withHeadersAndEntity(headers, entity: ResponseEntity)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:410: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.scaladsl.model.MessageEntity = _
[warn]   override def withHeadersAndEntity(headers: immutable.Seq[HttpHeader], entity: MessageEntity): HttpResponse = withHeadersAndEntity(headers, entity: ResponseEntity)
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:411: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: scala.collection.immutable.Seq[akka.http.scaladsl.model.HttpHeader] = _
[warn]   def withHeadersAndEntity(headers: immutable.Seq[HttpHeader], entity: ResponseEntity): HttpResponse = copy(headers = headers, entity = entity)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:411: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.scaladsl.model.ResponseEntity = _
[warn]   def withHeadersAndEntity(headers: immutable.Seq[HttpHeader], entity: ResponseEntity): HttpResponse = copy(headers = headers, entity = entity)
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:412: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.javadsl.model.ResponseEntity = _
[warn]   override def withEntity(entity: jm.ResponseEntity): HttpResponse = copy(entity = entity.asInstanceOf[ResponseEntity])
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:413: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.scaladsl.model.MessageEntity = _
[warn]   override def withEntity(entity: MessageEntity): HttpResponse = copy(entity = entity)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:414: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.javadsl.model.RequestEntity = _
[warn]   override def withEntity(entity: jm.RequestEntity): HttpResponse = withEntity(entity: jm.ResponseEntity)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:421: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val status: akka.http.scaladsl.model.StatusCode = status
[warn]     status:   StatusCode                = status,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:422: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: scala.collection.immutable.Seq[akka.http.scaladsl.model.HttpHeader] = headers
[warn]     headers:  immutable.Seq[HttpHeader] = headers,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:423: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.scaladsl.model.ResponseEntity = entity
[warn]     entity:   ResponseEntity            = entity,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\HttpMessage.scala:424: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val protocol: akka.http.scaladsl.model.HttpProtocol = protocol
[warn]     protocol: HttpProtocol              = protocol) = new HttpResponse(status, headers, entity, protocol)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaRange.scala:62: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]     def withQValue(qValue: Float) = if (qValue != this.qValue) custom(mainType, params, qValue) else this
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaRange.scala:113: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]     def withQValue(qValue: Float) = if (qValue != 1.0f) MediaRange.custom(mainType, params, qValue) else this
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaRange.scala:61: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val params: Map[String,String] = _
[warn]     def withParams(params: Map[String, String]) = custom(mainType, params, qValue)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaRange.scala:62: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val qValue: Float = _
[warn]     def withQValue(qValue: Float) = if (qValue != this.qValue) custom(mainType, params, qValue) else this
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaRange.scala:94: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val mediaType: akka.http.scaladsl.model.MediaType = _
[warn]     def matches(mediaType: MediaType) =
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaRange.scala:97: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val qValue: Float = _
[warn]     def withQValue(qValue: Float) = copy(qValue = qValue)
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaType.scala:410: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def `form-data`(params: Map[String, String]) = new MediaType.Multipart("form-data", params)
[info]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaType.scala:198: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val comp: akka.http.scaladsl.model.MediaType.Compressibility = _
[warn]     def withComp(comp: Compressibility): Binary with MediaType =
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\MediaType.scala:249: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val params: Map[String,String] = _
[warn]     def withParams(params: Map[String, String]): MediaType.Multipart = new MediaType.Multipart(subType, params)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:74: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Multipart.this.parts.asInstanceOf[akka.stream.scaladsl.Source[akka.http.scaladsl.model.Multipart.BodyPart,AnyRef]]
[warn]     JSource.fromGraph(parts.asInstanceOf[Source[Multipart.BodyPart, AnyRef]])
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:82: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   charset.asInstanceOf[akka.http.scaladsl.model.HttpCharset]
[warn]     toEntity(charset.asInstanceOf[HttpCharset], boundary)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:107: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Strict.super.getParts().asInstanceOf[akka.stream.javadsl.Source[_ <: akka.http.javadsl.model.Multipart.BodyPart.Strict, AnyRef]]
[warn]       super.getParts.asInstanceOf[JSource[_ <: jm.Multipart.BodyPart.Strict, AnyRef]]
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:115: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Strict.super.toEntity(charset, boundary).asInstanceOf[akka.http.javadsl.model.HttpEntity.Strict]
[warn]       super.toEntity(charset, boundary).asInstanceOf[jm.HttpEntity.Strict]
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:211: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   General.super.getParts().asInstanceOf[akka.stream.javadsl.Source[_ <: akka.http.javadsl.model.Multipart.General.BodyPart, AnyRef]]
[warn]       super.getParts.asInstanceOf[JSource[_ <: jm.Multipart.General.BodyPart, AnyRef]]
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:215: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.CompletionStageOps[_$2](General.super.toStrict(timeoutMillis, materializer)).toScala.asInstanceOf[scala.concurrent.Future[akka.http.javadsl.model.Multipart.General.Strict]]
[warn]       super.toStrict(timeoutMillis, materializer).toScala.asInstanceOf[Future[jm.Multipart.General.Strict]].toJava
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:241: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Strict.super.getParts().asInstanceOf[akka.stream.javadsl.Source[_ <: akka.http.javadsl.model.Multipart.General.BodyPart.Strict, AnyRef]]
[warn]         super.getParts.asInstanceOf[JSource[_ <: jm.Multipart.General.BodyPart.Strict, AnyRef]]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:245: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Strict.super.getStrictParts().asInstanceOf[Iterable[akka.http.javadsl.model.Multipart.General.BodyPart.Strict]]
[warn]         super.getStrictParts.asInstanceOf[java.lang.Iterable[jm.Multipart.General.BodyPart.Strict]]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:261: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.CompletionStageOps[_$6](BodyPart.super.toStrict(timeoutMillis, materializer)).toScala.asInstanceOf[scala.concurrent.Future[akka.http.javadsl.model.Multipart.General.BodyPart.Strict]]
[warn]         super.toStrict(timeoutMillis, materializer).toScala.asInstanceOf[Future[jm.Multipart.General.BodyPart.Strict]].toJava
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:322: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FormData.super.getParts().asInstanceOf[akka.stream.javadsl.Source[_ <: akka.http.javadsl.model.Multipart.FormData.BodyPart, AnyRef]]
[warn]       super.getParts.asInstanceOf[JSource[_ <: jm.Multipart.FormData.BodyPart, AnyRef]]
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:326: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.CompletionStageOps[_$2](FormData.super.toStrict(timeoutMillis, materializer)).toScala.asInstanceOf[scala.concurrent.Future[akka.http.javadsl.model.Multipart.FormData.Strict]]
[warn]       super.toStrict(timeoutMillis, materializer).toScala.asInstanceOf[Future[jm.Multipart.FormData.Strict]].toJava
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:382: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Strict.super.getParts().asInstanceOf[akka.stream.javadsl.Source[akka.http.javadsl.model.Multipart.FormData.BodyPart.Strict,AnyRef]]
[warn]         super.getParts.asInstanceOf[JSource[jm.Multipart.FormData.BodyPart.Strict, AnyRef]]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:386: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Strict.super.getStrictParts().asInstanceOf[Iterable[akka.http.javadsl.model.Multipart.FormData.BodyPart.Strict]]
[warn]         super.getStrictParts.asInstanceOf[java.lang.Iterable[jm.Multipart.FormData.BodyPart.Strict]]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:439: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.CompletionStageOps[_$6](BodyPart.super.toStrict(timeoutMillis, materializer)).toScala.asInstanceOf[scala.concurrent.Future[akka.http.javadsl.model.Multipart.FormData.BodyPart.Strict]]
[warn]         super.toStrict(timeoutMillis, materializer).toScala.asInstanceOf[Future[jm.Multipart.FormData.BodyPart.Strict]].toJava
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:517: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ByteRanges.super.getParts().asInstanceOf[akka.stream.javadsl.Source[_ <: akka.http.javadsl.model.Multipart.ByteRanges.BodyPart, AnyRef]]
[warn]       super.getParts.asInstanceOf[JSource[_ <: jm.Multipart.ByteRanges.BodyPart, AnyRef]]
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:521: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.CompletionStageOps[_$2](ByteRanges.super.toStrict(timeoutMillis, materializer)).toScala.asInstanceOf[scala.concurrent.Future[akka.http.javadsl.model.Multipart.ByteRanges.Strict]]
[warn]       super.toStrict(timeoutMillis, materializer).toScala.asInstanceOf[Future[jm.Multipart.ByteRanges.Strict]].toJava
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:543: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Strict.super.getParts().asInstanceOf[akka.stream.javadsl.Source[akka.http.javadsl.model.Multipart.ByteRanges.BodyPart.Strict,AnyRef]]
[warn]         super.getParts.asInstanceOf[JSource[jm.Multipart.ByteRanges.BodyPart.Strict, AnyRef]]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:547: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Strict.super.getStrictParts().asInstanceOf[Iterable[akka.http.javadsl.model.Multipart.ByteRanges.BodyPart.Strict]]
[warn]         super.getStrictParts.asInstanceOf[java.lang.Iterable[jm.Multipart.ByteRanges.BodyPart.Strict]]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:596: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.FutureConverters.CompletionStageOps[_$6](BodyPart.super.toStrict(timeoutMillis, materializer)).toScala.asInstanceOf[scala.concurrent.Future[akka.http.javadsl.model.Multipart.ByteRanges.BodyPart.Strict]]
[warn]         super.toStrict(timeoutMillis, materializer).toScala.asInstanceOf[Future[jm.Multipart.ByteRanges.BodyPart.Strict]].toJava
[warn]                                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:233: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Strict(mediaType: MediaType.Multipart, strictParts: immutable.Seq[Multipart.General.BodyPart.Strict])
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:293: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]       case class Strict(entity: HttpEntity.Strict, headers: immutable.Seq[HttpHeader] = Nil)
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:374: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Strict(strictParts: immutable.Seq[Multipart.FormData.BodyPart.Strict])
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:472: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]       case class Strict(name: String, entity: HttpEntity.Strict,
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:535: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Strict(strictParts: immutable.Seq[Multipart.ByteRanges.BodyPart.Strict])
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Multipart.scala:615: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]       case class Strict(contentRange: ContentRange, entity: HttpEntity.Strict, rangeUnit: RangeUnit = RangeUnits.Bytes,
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\RemoteAddress.scala:42: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   IP.this.port.get
[warn]       if (port.isDefined) r ~~ ":" ~~ port.get
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\StatusCode.scala:71: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   StatusCodes.this.getForKey(code.intValue()).get
[warn]     require(getForKey(code.intValue).isEmpty, s"Status code for ${code.intValue} already registered as '${getForKey(code.intValue).get}'.")
[warn]                                                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:405: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   java.net.InetAddress.getByAddress(bytes).asInstanceOf[java.net.Inet6Address]
[warn]     def apply(bytes: Array[Byte]): IPv6Host = Host(InetAddress.getByAddress(bytes).asInstanceOf[Inet6Address])
[warn]                                                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:524: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]     object ~ {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:788: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   value.fragment.get
[warn]     if (value.fragment.isDefined) encode(r ~~ '#', value.fragment.get, charset, `query-fragment-char`)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:535: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   q.tail
[warn]       @tailrec def g(q: Query): Option[String] = if (q.isEmpty) None else if (q.key == key) Some(q.value) else g(q.tail)
[warn]                                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:539: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   q.tail
[warn]       @tailrec def g(q: Query): String = if (q.isEmpty) default else if (q.key == key) q.value else g(q.tail)
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:544: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   q.tail
[warn]         if (q.isEmpty) result else fetch(q.tail, if (q.key == key) q.value :: result else result)
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:549: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   q.tail
[warn]         if (q.isEmpty) map else append(map.updated(q.key, q.value), q.tail)
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:554: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   q.tail
[warn]         if (q.isEmpty) map else append(map.updated(q.key, q.value :: map.getOrElse(q.key, Nil)), q.tail)
[warn]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:359: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val charset: java.nio.charset.Charset = akka.http.impl.util.`package`.UTF8).
[warn]     def apply(string: String, charset: Charset = UTF8, mode: Uri.ParsingMode = Uri.ParsingMode.Relaxed): Host =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:710: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val scheme: String = _).
[warn]   private[http] def verifyPath(path: Path, scheme: String, host: Host): Path = {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:55: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val scheme: String = scheme
[warn]   def copy(scheme: String = scheme, authority: Authority = authority, path: Path = path,
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:55: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val authority: akka.http.scaladsl.model.Uri.Authority = authority
[warn]   def copy(scheme: String = scheme, authority: Authority = authority, path: Path = path,
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:55: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val path: akka.http.scaladsl.model.Uri.Path = path
[warn]   def copy(scheme: String = scheme, authority: Authority = authority, path: Path = path,
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:56: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val rawQueryString: Option[String] = rawQueryString
[warn]            rawQueryString: Option[String] = rawQueryString, fragment: Option[String] = fragment): Uri =
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:56: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val fragment: Option[String] = fragment
[warn]            rawQueryString: Option[String] = rawQueryString, fragment: Option[String] = fragment): Uri =
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:66: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val scheme: String = _
[warn]   def withScheme(scheme: String): Uri = copy(scheme = scheme)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:71: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val authority: akka.http.scaladsl.model.Uri.Authority = _
[warn]   def withAuthority(authority: Authority): Uri = copy(authority = authority)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:101: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val path: akka.http.scaladsl.model.Uri.Path = _
[warn]   def withPath(path: Path): Uri = copy(path = path)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:121: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val fragment: String = _
[warn]   def withFragment(fragment: String): Uri = copy(fragment = fragment.toOption)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:631: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val base: akka.http.scaladsl.model.Uri = _
[warn]           def mergePaths(base: Uri, path: Path): Path =
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\Uri.scala:631: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val path: akka.http.scaladsl.model.Uri.Path = _
[warn]           def mergePaths(base: Uri, path: Path): Path =
[warn]                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:52: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class `max-age`(deltaSeconds: Long) extends RequestDirective with ResponseDirective with ValueRenderable {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:57: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class `max-stale`(deltaSeconds: Option[Long]) extends RequestDirective with ValueRenderable {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:65: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class `min-fresh`(deltaSeconds: Long) extends RequestDirective with ValueRenderable {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:89: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class `no-cache`(fieldNames: immutable.Seq[String]) extends FieldNamesDirective with ResponseDirective
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:98: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class `private`(fieldNames: immutable.Seq[String]) extends FieldNamesDirective with ResponseDirective
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:110: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class `s-maxage`(deltaSeconds: Long) extends ResponseDirective with ValueRenderable {
[info]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:39: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   FieldNamesDirective.this.fieldNames.apply(i)
[warn]             r.putEscaped(fieldNames(i))
[warn]                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:70: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `no-cache` extends SingletonValueRenderable with RequestDirective with ResponseDirective {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:76: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `no-store` extends SingletonValueRenderable with RequestDirective with ResponseDirective
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:80: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `no-transform` extends SingletonValueRenderable with RequestDirective with ResponseDirective
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:83: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `only-if-cached` extends SingletonValueRenderable with RequestDirective
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:86: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `must-revalidate` extends SingletonValueRenderable with ResponseDirective
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\CacheDirective.scala:107: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `proxy-revalidate` extends SingletonValueRenderable with ResponseDirective
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\ContentDispositionType.scala:19: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `form-data` extends Predefined
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\EntityTag.scala:35: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `*` extends EntityTagRange {
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpChallenge.scala:17: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   HttpChallenge.this.realm.!=(null)
[warn]     if (realm != null) r ~~ " realm=" ~~#! realm
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:41: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.nameChars.firstMismatch(name).get
[warn]     require(nameChars.matchesAll(name), s"'${nameChars.firstMismatch(name).get}' not allowed in cookie name ('$name')")
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:42: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.valueChars.firstMismatch(value).get
[warn]     require(valueChars.matchesAll(value), s"'${valueChars.firstMismatch(value).get}' not allowed in cookie content ('$value')")
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:46: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.nameChars.firstMismatch(name).get
[warn]     require(nameChars.matchesAll(name), s"'${nameChars.firstMismatch(name).get}' not allowed in cookie name ('$name')")
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:47: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.rawValueChars.firstMismatch(value).get
[warn]     require(rawValueChars.matchesAll(value), s"'${rawValueChars.firstMismatch(value).get}' not allowed in cookie content ('$value')")
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:71: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.domainChars.firstMismatch(HttpCookie.this.domain.get).get
[warn]   require(domain.forall(domainChars.matchesAll), s"'${domainChars.firstMismatch(domain.get).get}' not allowed in cookie domain ('${domain.get}')")
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:71: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.this.domain.get
[warn]   require(domain.forall(domainChars.matchesAll), s"'${domainChars.firstMismatch(domain.get).get}' not allowed in cookie domain ('${domain.get}')")
[warn]                                                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:72: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.pathOrExtChars.firstMismatch(HttpCookie.this.path.get).get
[warn]   require(path.forall(pathOrExtChars.matchesAll), s"'${pathOrExtChars.firstMismatch(path.get).get}' not allowed in cookie path ('${path.get}')")
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:72: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.this.path.get
[warn]   require(path.forall(pathOrExtChars.matchesAll), s"'${pathOrExtChars.firstMismatch(path.get).get}' not allowed in cookie path ('${path.get}')")
[warn]                                                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:73: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.pathOrExtChars.firstMismatch(HttpCookie.this.extension.get).get
[warn]   require(extension.forall(pathOrExtChars.matchesAll), s"'${pathOrExtChars.firstMismatch(extension.get).get}' not allowed in cookie extension ('${extension.get}')")
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:73: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.this.extension.get
[warn]   require(extension.forall(pathOrExtChars.matchesAll), s"'${pathOrExtChars.firstMismatch(extension.get).get}' not allowed in cookie extension ('${extension.get}')")
[warn]                                                                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:77: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.this.expires.get
[warn]     if (expires.isDefined) expires.get.renderRfc1123DateTimeString(r ~~ "; Expires=")
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:78: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.this.maxAge.get
[warn]     if (maxAge.isDefined) r ~~ "; Max-Age=" ~~ maxAge.get
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:79: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.this.domain.get
[warn]     if (domain.isDefined) r ~~ "; Domain=" ~~ domain.get
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:80: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.this.path.get
[warn]     if (path.isDefined) r ~~ "; Path=" ~~ path.get
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:83: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HttpCookie.this.extension.get
[warn]     if (extension.isDefined) r ~~ ';' ~~ ' ' ~~ extension.get
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:100: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val domain: String = _
[warn]   def withDomain(domain: String): headers.HttpCookie = copy(domain = Some(domain))
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:102: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val path: String = _
[warn]   def withPath(path: String): headers.HttpCookie = copy(path = Some(path))
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:104: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxAge: Long = _
[warn]   def withMaxAge(maxAge: Long): headers.HttpCookie = copy(maxAge = Some(maxAge))
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:106: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val secure: Boolean = _
[warn]   def withSecure(secure: Boolean): headers.HttpCookie = copy(secure = secure)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:108: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val httpOnly: Boolean = _
[warn]   def withHttpOnly(httpOnly: Boolean): headers.HttpCookie = copy(httpOnly = httpOnly)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpCookie.scala:110: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val extension: String = _
[warn]   def withExtension(extension: String): headers.HttpCookie = copy(extension = Some(extension))
[warn]                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:25: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   case class `*`(qValue: Float) extends HttpEncodingRange {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:30: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:30: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:25: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class `*`(qValue: Float) extends HttpEncodingRange {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:32: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   object `*` extends `*`(1.0f)
[info]          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:27: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final def render[R <: Rendering](r: R): r.type = if (qValue < 1.0f) r ~~ "*;q=" ~~ qValue else r ~~ '*'
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:29: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val qValue: Float = _
[warn]     def withQValue(qValue: Float) =
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:36: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val encoding: akka.http.scaladsl.model.headers.HttpEncoding = _
[warn]     def matches(encoding: HttpEncoding) = this.encoding.value.equalsIgnoreCase(encoding.value)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpEncoding.scala:37: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val qValue: Float = _
[warn]     def withQValue(qValue: Float) = One(encoding, qValue)
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\HttpOrigin.scala:26: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   case object `*` extends HttpOriginRange {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:34: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   case class `*`(qValue: Float) extends LanguageRange {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:40: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:40: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]       if (qValue == 1.0f) `*` else if (qValue != this.qValue) `*`(qValue.toFloat) else this
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:34: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class `*`(qValue: Float) extends LanguageRange {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:42: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info]   object `*` extends `*`(1.0f)
[info]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val qValue: Float = _
[warn]     def withQValue(qValue: Float) =
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LanguageRange.scala:52: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val qValue: Float = _
[warn]     def withQValue(qValue: Float) = One(language, qValue)
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:50: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class rel(value: String) extends LinkParam {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:58: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class anchor(uri: Uri) extends LinkParam {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:66: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class rev(value: String) extends LinkParam {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:74: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class hreflang(lang: Language) extends LinkParam {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:81: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class media(desc: String) extends LinkParam {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:91: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class title(title: String) extends LinkParam {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:98: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class `title*`(title: String) extends LinkParam {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:108: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info]   final case class `type`(mediaType: MediaType) extends LinkParam {
[info]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:59: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def value: AnyRef = anchor.this.uri
[warn]     def value: AnyRef = uri
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:75: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def value: AnyRef = hreflang.this.lang
[warn]     def value: AnyRef = lang
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:82: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def value: AnyRef = media.this.desc
[warn]     def value: AnyRef = desc
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:92: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def value: AnyRef = title.this.title
[warn]     def value: AnyRef = title
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:99: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def value: AnyRef = title*.this.title
[warn]     def value: AnyRef = title
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\LinkValue.scala:109: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def value: AnyRef = `type`.this.mediaType
[warn]     def value: AnyRef = mediaType
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:143: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Accept-Charset`(charsetRanges: immutable.Seq[HttpCharsetRange]) extends jm.headers.AcceptCharset
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:159: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Accept-Encoding`(encodings: immutable.Seq[HttpEncodingRange]) extends jm.headers.AcceptEncoding
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:174: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Accept-Language`(languages: immutable.Seq[LanguageRange]) extends jm.headers.AcceptLanguage
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:190: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Accept-Ranges`(rangeUnits: immutable.Seq[RangeUnit]) extends jm.headers.AcceptRanges
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:202: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Access-Control-Allow-Credentials`(allow: Boolean)
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:213: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Access-Control-Allow-Headers`(headers: immutable.Seq[String])
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:228: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Access-Control-Allow-Methods`(methods: immutable.Seq[HttpMethod])
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:253: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Access-Control-Allow-Origin` private (range: HttpOriginRange)
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:264: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Access-Control-Expose-Headers`(headers: immutable.Seq[String])
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:276: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Access-Control-Max-Age`(deltaSeconds: Long) extends jm.headers.AccessControlMaxAge
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:287: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Access-Control-Request-Headers`(headers: immutable.Seq[String])
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:299: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Access-Control-Request-Method`(method: HttpMethod) extends jm.headers.AccessControlRequestMethod
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:338: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Cache-Control`(directives: immutable.Seq[CacheDirective]) extends jm.headers.CacheControl
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:380: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Content-Length` private[http] (length: Long) extends jm.headers.ContentLength
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:388: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Content-Disposition`(dispositionType: ContentDispositionType, params: Map[String, String] = Map.empty)
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:406: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Content-Encoding`(encodings: immutable.Seq[HttpEncoding]) extends jm.headers.ContentEncoding
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:421: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Content-Range`(rangeUnit: RangeUnit, contentRange: ContentRange) extends jm.headers.ContentRange
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:433: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Content-Type` private[http] (contentType: ContentType) extends jm.headers.ContentType
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:524: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `If-Match`(m: EntityTagRange) extends jm.headers.IfMatch with RequestHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:531: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `If-Modified-Since`(date: DateTime) extends jm.headers.IfModifiedSince with RequestHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:542: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `If-None-Match`(m: EntityTagRange) extends jm.headers.IfNoneMatch with RequestHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:552: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `If-Range`(entityTagOrDateTime: Either[EntityTag, DateTime]) extends RequestHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:563: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `If-Unmodified-Since`(date: DateTime) extends jm.headers.IfUnmodifiedSince with RequestHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:570: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Last-Modified`(date: DateTime) extends jm.headers.LastModified with ResponseHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:617: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Proxy-Authenticate`(challenges: immutable.Seq[HttpChallenge]) extends jm.headers.ProxyAuthenticate
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:630: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Proxy-Authorization`(credentials: HttpCredentials) extends jm.headers.ProxyAuthorization
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:665: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Raw-Request-URI`(uri: String) extends jm.headers.RawRequestURI with SyntheticHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:671: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Remote-Address`(address: RemoteAddress) extends jm.headers.RemoteAddress with SyntheticHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:709: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] private[http] final case class `Sec-WebSocket-Accept`(key: String) extends ResponseHeader {
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:725: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] private[http] final case class `Sec-WebSocket-Extensions`(extensions: immutable.Seq[WebSocketExtension])
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:746: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] private[http] final case class `Sec-WebSocket-Key`(key: String) extends RequestHeader {
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:768: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] private[http] final case class `Sec-WebSocket-Protocol`(protocols: immutable.Seq[String])
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:789: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] private[http] final case class `Sec-WebSocket-Version`(versions: immutable.Seq[Int])
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:819: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Strict-Transport-Security`(maxAge: Long, includeSubDomains: Boolean = false) extends jm.headers.StrictTransportSecurity with ResponseHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:830: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Set-Cookie`(cookie: HttpCookie) extends jm.headers.SetCookie with ResponseHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:836: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Timeout-Access`(timeoutAccess: akka.http.scaladsl.TimeoutAccess)
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:853: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Tls-Session-Info`(session: SSLSession) extends jm.headers.TlsSessionInfo with SyntheticHeader
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:867: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `Transfer-Encoding`(encodings: immutable.Seq[TransferEncoding]) extends jm.headers.TransferEncoding
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:907: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `User-Agent`(products: immutable.Seq[ProductVersion]) extends jm.headers.UserAgent with RequestHeader {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:922: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `WWW-Authenticate`(challenges: immutable.Seq[HttpChallenge]) extends jm.headers.WWWAuthenticate
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:938: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `X-Forwarded-For`(addresses: immutable.Seq[RemoteAddress]) extends jm.headers.XForwardedFor
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:950: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] final case class `X-Real-Ip`(address: RemoteAddress) extends jm.headers.XRealIp
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:365: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   Connection.this.tokens.apply(ix)
[warn]       if (tokens(ix) equalsIgnoreCase item) true
[warn]                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:489: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] sealed abstract case class Expect private () extends RequestHeader {
[info]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:139: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Accept-Charset` extends ModeledCompanion[`Accept-Charset`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:155: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Accept-Encoding` extends ModeledCompanion[`Accept-Encoding`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:170: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Accept-Language` extends ModeledCompanion[`Accept-Language`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:186: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Accept-Ranges` extends ModeledCompanion[`Accept-Ranges`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:201: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Access-Control-Allow-Credentials` extends ModeledCompanion[`Access-Control-Allow-Credentials`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:209: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Access-Control-Allow-Headers` extends ModeledCompanion[`Access-Control-Allow-Headers`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:224: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Access-Control-Allow-Methods` extends ModeledCompanion[`Access-Control-Allow-Methods`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:239: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Access-Control-Allow-Origin` extends ModeledCompanion[`Access-Control-Allow-Origin`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:260: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Access-Control-Expose-Headers` extends ModeledCompanion[`Access-Control-Expose-Headers`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:275: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Access-Control-Max-Age` extends ModeledCompanion[`Access-Control-Max-Age`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:283: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Access-Control-Request-Headers` extends ModeledCompanion[`Access-Control-Request-Headers`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:298: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Access-Control-Request-Method` extends ModeledCompanion[`Access-Control-Request-Method`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:334: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Cache-Control` extends ModeledCompanion[`Cache-Control`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:375: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Content-Length` extends ModeledCompanion[`Content-Length`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:387: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Content-Disposition` extends ModeledCompanion[`Content-Disposition`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:402: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Content-Encoding` extends ModeledCompanion[`Content-Encoding`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:418: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Content-Range` extends ModeledCompanion[`Content-Range`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:428: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Content-Type` extends ModeledCompanion[`Content-Type`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:519: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `If-Match` extends ModeledCompanion[`If-Match`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:530: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `If-Modified-Since` extends ModeledCompanion[`If-Modified-Since`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:537: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `If-None-Match` extends ModeledCompanion[`If-None-Match`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:548: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `If-Range` extends ModeledCompanion[`If-Range`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:562: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `If-Unmodified-Since` extends ModeledCompanion[`If-Unmodified-Since`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:569: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Last-Modified` extends ModeledCompanion[`Last-Modified`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:613: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Proxy-Authenticate` extends ModeledCompanion[`Proxy-Authenticate`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:629: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Proxy-Authorization` extends ModeledCompanion[`Proxy-Authorization`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:664: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Raw-Request-URI` extends ModeledCompanion[`Raw-Request-URI`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:670: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Remote-Address` extends ModeledCompanion[`Remote-Address`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:693: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] private[http] object `Sec-WebSocket-Accept` extends ModeledCompanion[`Sec-WebSocket-Accept`] {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:719: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] private[http] object `Sec-WebSocket-Extensions` extends ModeledCompanion[`Sec-WebSocket-Extensions`] {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:737: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] private[http] object `Sec-WebSocket-Key` extends ModeledCompanion[`Sec-WebSocket-Key`] {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:762: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] private[http] object `Sec-WebSocket-Protocol` extends ModeledCompanion[`Sec-WebSocket-Protocol`] {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:783: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] private[http] object `Sec-WebSocket-Version` extends ModeledCompanion[`Sec-WebSocket-Version`] {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:816: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Strict-Transport-Security` extends ModeledCompanion[`Strict-Transport-Security`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:829: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Set-Cookie` extends ModeledCompanion[`Set-Cookie`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:835: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Timeout-Access` extends ModeledCompanion[`Timeout-Access`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:852: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Tls-Session-Info` extends ModeledCompanion[`Tls-Session-Info`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:863: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `Transfer-Encoding` extends ModeledCompanion[`Transfer-Encoding`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:902: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `User-Agent` extends ModeledCompanion[`User-Agent`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:918: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `WWW-Authenticate` extends ModeledCompanion[`WWW-Authenticate`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:934: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `X-Forwarded-For` extends ModeledCompanion[`X-Forwarded-For`] {
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:949: [scapegoat] Object name not recommended
[info]   Object names should only contain alphanumeric characters.
[info] object `X-Real-Ip` extends ModeledCompanion[`X-Real-Ip`]
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:490: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def renderValue[R <: Rendering](r: R): r.type = r ~~ "100-continue"
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:875: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   Transfer-Encoding.this.encodings.init
[warn]       encodings.init match {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:362: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val tokens: scala.collection.immutable.Seq[String] = _
[warn]   def append(tokens: immutable.Seq[String]) = Connection(this.tokens ++ tokens)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\model\headers\headers.scala:880: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val encodings: scala.collection.immutable.Seq[akka.http.scaladsl.model.TransferEncoding] = _
[warn]   def append(encodings: immutable.Seq[TransferEncoding]) = `Transfer-Encoding`(this.encodings ++ encodings)
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\util\FastFuture.scala:74: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FastFuture.this._successful.asInstanceOf[T => scala.concurrent.Future[T]]
[warn]   def successful[T]: T ? Future[T] = _successful.asInstanceOf[T ? Future[T]]
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\util\FastFuture.scala:106: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   fa.asInstanceOf[scala.concurrent.Future[T]]
[warn]       (fr, fa) ? for (r ← fr.fast; a ← fa.asInstanceOf[Future[T]].fast) yield r += a
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\util\FastFuture.scala:119: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   a.asInstanceOf[A]
[warn]       val fb = fn(a.asInstanceOf[A])
[warn]                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\util\FastFuture.scala:77: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class FulfilledFuture[+A](a: A) extends Future[A] {
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\util\FastFuture.scala:88: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class ErrorFuture(error: Throwable) extends Future[Nothing] {
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\util\FastFuture.scala:83: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val executor: scala.concurrent.ExecutionContext = _).
[warn]     def transform[S](f: scala.util.Try[A] ? scala.util.Try[S])(implicit executor: scala.concurrent.ExecutionContext): scala.concurrent.Future[S] =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\util\FastFuture.scala:94: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val executor: scala.concurrent.ExecutionContext = _).
[warn]     def transform[S](f: scala.util.Try[Nothing] ? scala.util.Try[S])(implicit executor: scala.concurrent.ExecutionContext): scala.concurrent.Future[S] =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\scala\akka\http\scaladsl\util\FastFuture.scala:40: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val f: T => scala.concurrent.Future[B] = _
[warn]     def strictTransform[T](x: T, f: T ? Future[B]) =
[warn]                                  ^
[info] [warn] [scapegoat] Analysis complete: 156 files - 0 errors 787 warns 383 infos
[warn] there were 6 deprecation warnings; re-run with -deprecation for details
[warn] 582 warnings found
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-core\src\main\java\akka\http\javadsl\model\HttpEntities.java:92:  [unchecked] 未经检查的转换
[warn]         return (akka.stream.scaladsl.Source<ByteString,Object>)javaSource.asScala();
[warn]                                                                                  ^
[info] Compiling 83 Scala sources and 7 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\AddressUidExtension.scala:32: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   AddressUidExtension.this.system.provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]   private def arteryEnabled = system.provider.asInstanceOf[RemoteActorRefProvider].remoteSettings.Artery.Enabled
[warn]                                                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\AddressUidExtension.scala:22: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.remote.AddressUidExtension = AddressUidExtension.super.get(system)
[info]   override def get(system: ActorSystem): AddressUidExtension = super.get(system)
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\BoundAddressesExtension.scala:18: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.remote.BoundAddressesExtension = BoundAddressesExtension.super.get(system)
[info]   override def get(system: ActorSystem): BoundAddressesExtension = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\DeadlineFailureDetector.scala:39: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (ev).
[warn]   def this(config: Config, ev: EventStream) =
[warn]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\DefaultFailureDetectorRegistry.scala:21: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.collection.immutable.Map.apply[A, Nothing]()
[info]   private val resourceToFailureDetector = new AtomicReference[Map[A, FailureDetector]](Map())
[info]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:535: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EndpointWriter.this.context.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val extendedSystem: ExtendedActorSystem = context.system.asInstanceOf[ExtendedActorSystem]
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:891: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.asInstanceOf[AnyRef]
[warn]         (MessageSerializer.serialize(extendedSystem, msg.asInstanceOf[AnyRef]))
[warn]                                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:31: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.util.OptionVal
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:301: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Error encountered while processing system message ").s()
[warn]               new IllegalStateException(s"Error encountered while processing system message " +
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:990: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Discarding oversized payload received: ").s()
[warn]         new OversizedPayloadException(s"Discarding oversized payload received: " +
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:133: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   @SerialVersionUID(value = 1L) final case private[remote] class ShutDownAssociation extends EndpointException with akka.remote.AssociationProblem with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val localAddress: akka.actor.Address = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def localAddress: akka.actor.Address = ShutDownAssociation.this.localAddress;

[warn]   <caseaccessor> <paramaccessor> private[this] val remoteAddress: akka.actor.Address = _;

[warn]   <stabl
[warn] private[remote] final case class ShutDownAssociation(localAddress: Address, remoteAddress: Address, cause: Throwable)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:140: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   @SerialVersionUID(value = 2L) final case private[remote] class InvalidAssociation extends EndpointException with akka.remote.AssociationProblem with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val localAddress: akka.actor.Address = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def localAddress: akka.actor.Address = InvalidAssociation.this.localAddress;

[warn]   <caseaccessor> <paramaccessor> private[this] val remoteAddress: akka.actor.Address = _;

[warn]   <stable>
[warn] private[remote] final case class InvalidAssociation(
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:151: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   @SerialVersionUID(value = 1L) final case private[remote] class HopelessAssociation extends EndpointException with akka.remote.AssociationProblem with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val localAddress: akka.actor.Address = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def localAddress: akka.actor.Address = HopelessAssociation.this.localAddress;

[warn]   <caseaccessor> <paramaccessor> private[this] val remoteAddress: akka.actor.Address = _;

[warn]   <stabl
[warn] private[remote] final case class HopelessAssociation(localAddress: Address, remoteAddress: Address, uid: Option[Int], cause: Throwable)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:83: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sel.msg.isInstanceOf[akka.actor.PossiblyHarmful]
[warn]               sel.msg.isInstanceOf[PossiblyHarmful] || l != provider.rootGuardian))
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:407: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   send.message.isInstanceOf[akka.dispatch.sysmsg.SystemMessage]
[warn]     if (send.message.isInstanceOf[SystemMessage]) {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:63: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   payload.eq(null)
[warn]     def payloadClass: Class[_] = if (payload eq null) null else payload.getClass
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:121: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EndpointException.this.<init>(msg, null)
[warn]   def this(msg: String) = this(msg, null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:220: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   e.getCause().==(null)
[warn]       val causedBy = if (e.getCause == null) "" else s"Caused by: [${e.getCause.getMessage}]"
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:959: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   expectedState.eq(null)
[warn]       if (expectedState eq null) {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:960: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EndpointReader.this.receiveBuffers.putIfAbsent(key, akka.remote.EndpointManager.ResendState.apply(EndpointReader.this.uid, EndpointReader.this.ackedReceiveBuffer)).ne(null)
[warn]         if (receiveBuffers.putIfAbsent(key, ResendState(uid, ackedReceiveBuffer)) ne null)
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:821: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   EndpointWriter.this.handle.get
[warn]       reader = startReadEndpoint(handle.get)
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:878: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val handle: akka.remote.transport.AkkaProtocolHandle = _
[warn]   private def startReadEndpoint(handle: AkkaProtocolHandle): Some[ActorRef] = {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Endpoint.scala:596: [scapegoat] Var in closure
[warn]   Closing over a var can lead to subtle bugs.
[warn]   x$9.disassociate(EndpointWriter.this.stopReason)
[warn]     handle foreach { _.disassociate(stopReason) }
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\FailureDetectorRegistry.scala:68: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     system.asInstanceOf[ExtendedActorSystem].dynamicAccess.createInstanceFor[FailureDetector](
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\FailureDetectorRegistry.scala:74: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem].dynamicAccess.createInstanceFor[akka.remote.FailureDetector](fqcn, immutable.this.List.apply[(Class[_ >: akka.event.EventStream with com.typesafe.config.Config <: Object], Object)](scala.this.Predef.ArrowAssoc[Class[com.typesafe.config.Config]](classOf[com.typesafe.config.Config]).→[com.typesafe.config.Config](config), scala.this.Predef.ArrowAssoc[Class[akka.event.EventStream]](classOf[akka.event.EventStream]).→[akka.event.EventStream](system.e
[warn]     }).get
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\MessageSerializer.scala:29: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserialize(system: akka.actor.ExtendedActorSystem, messageProtocol: akka.remote.WireFormats.SerializedMessage): AnyRef = akka.serialization.SerializationExtension.apply(system).deserialize(messageProtocol.getMessage().toByteArray(), messageProtocol.getSerializerId(), if (messageProtocol.hasMess
[warn]   def deserialize(system: ExtendedActorSystem, messageProtocol: SerializedMessage): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\MessageSerializer.scala:88: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserializeForArtery(system: akka.actor.ExtendedActorSystem, originUid: Long, serialization: akka.serialization.Serialization, serializer: Int, classManifest: String, envelope: akka.remote.artery.EnvelopeBuffer): AnyRef = serialization.deserializeByteBuffer(envelope.byteBuffer, serializer, class
[warn]   def deserializeForArtery(system: ExtendedActorSystem, originUid: Long, serialization: Serialization,
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\MessageSerializer.scala:33: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.serialization.SerializationExtension.apply(system).deserialize(messageProtocol.getMessage().toByteArray(), messageProtocol.getSerializerId(), if (messageProtocol.hasMessageManifest())

[warn]   messageProtocol.getMessageManifest().toStringUtf8()

[warn] else

[warn]   "").get
[warn]       if (messageProtocol.hasMessageManifest) messageProtocol.getMessageManifest.toStringUtf8 else "").get
[warn]                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\PhiAccrualFailureDetector.scala:149: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   oldTimestamp.get
[warn]       val timeDiff = timestamp - oldTimestamp.get
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\PhiAccrualFailureDetector.scala:228: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def :+(interval: Long): HeartbeatHistory = {
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\PhiAccrualFailureDetector.scala:242: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   HeartbeatHistory.this.intervals.head
[warn]     intervalSum = intervalSum - intervals.head,
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\PhiAccrualFailureDetector.scala:243: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   HeartbeatHistory.this.intervals.head
[warn]     squaredIntervalSum = squaredIntervalSum - pow2(intervals.head))
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\PhiAccrualFailureDetector.scala:71: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (ev).
[warn]   def this(config: Config, ev: EventStream) =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteActorRefProvider.scala:549: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   message match {

[warn]     case (watchee: akka.actor.InternalActorRef, watcher: akka.actor.InternalActorRef)akka.dispatch.sysmsg.Watch((watchee @ _), (watcher @ _)) if RemoteActorRef.this.isWatchIntercepted(watchee, watcher) => {

[warn]       <artifact> val qual$4: akka.actor.ScalaActorRef = akka.actor
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteActorRefProvider.scala:563: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   RemoteActorRef.this.remote.send(message, akka.util.OptionVal.apply[akka.actor.ActorRef](sender), this)

[warn] } catch {

[warn]   case (x$3 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr2: util.control.Exception.Catcher[Unit] = RemoteActorRef.this.handleException(message, sender);

[warn]     if (catchEx
[warn]     try remote.send(message, OptionVal(sender), this) catch handleException(message, sender)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteActorRefProvider.scala:508: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   @volatile private[remote] var cachedAssociation: artery.Association = null
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteActorRefProvider.scala:562: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   message.==(null)
[warn]     if (message == null) throw new InvalidMessageException("Message is null")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteActorRefProvider.scala:569: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRef.this.props.get
[warn]     if (props.isDefined && deploy.isDefined) remote.provider.useActorOnNode(this, props.get, deploy.get, getParent)
[warn]                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteActorRefProvider.scala:569: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRef.this.deploy.get
[warn]     if (props.isDefined && deploy.isDefined) remote.provider.useActorOnNode(this, props.get, deploy.get, getParent)
[warn]                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteActorRefProvider.scala:287: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   elems.head
[warn]           elems.head match {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteActorRefProvider.scala:297: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   l.reduce
[warn]           case l   ? List(l reduce ((a, b) ? b withFallback a))
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteDaemon.scala:167: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   supervisor.asInstanceOf[akka.actor.InternalActorRef]
[warn]                   val parent = supervisor.asInstanceOf[InternalActorRef]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteDaemon.scala:67: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   RemoteSystemDaemon.this.parent2children.putIfAbsent(parent, scala.this.Predef.Set.apply[akka.actor.ActorRef](child)).==(null)
[warn]         if (parent2children.putIfAbsent(parent, Set(child)) == null) true
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteDaemon.scala:149: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   RemoteSystemDaemon.this.dedupDaemonMsgCreateMessages.putIfAbsent(path, akka.NotUsed).==(null)
[warn]           if (dedupDaemonMsgCreateMessages.putIfAbsent(path, NotUsed) == null) {
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteDaemon.scala:194: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   acc.tail
[warn]               case SelectParent                ? rec(acc.tail)
[warn]                                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteMetricsExtension.scala:23: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.remote.RemoteMetrics = RemoteMetricsExtension.super.get(system)
[info]   override def get(system: ActorSystem): RemoteMetrics = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteMetricsExtension.scala:76: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   max.eq(null)
[warn]         if (max eq null) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteMetricsExtension.scala:77: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   RemoteMetricsOn.this.maxPayloadBytes.putIfAbsent(clazz, scala.this.Predef.int2Integer(newMax)).eq(null)
[warn]           if (maxPayloadBytes.putIfAbsent(clazz, newMax) eq null)
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteTransport.scala:27: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   @SerialVersionUID(value = 1L) class RemoteTransportExceptionNoStackTrace extends RemoteTransportException with scala.util.control.NoStackTrace {

[warn]   <paramaccessor> private[this] val message: String = _;

[warn]   <paramaccessor> private[this] val cause: Throwable = _;

[warn]   def <init>(message: String, cause: Throwable): akka.remote.RemoteTransportExceptionNoStackTrace = {

[warn]     RemoteTransportExceptionNoStackTrace.super.<init>(message, cause);

[warn]     ()

[warn]   }

[warn] }
[warn] class RemoteTransportExceptionNoStackTrace(message: String, cause: Throwable)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteWatcher.scala:286: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcher.this.self.asInstanceOf[akka.actor.InternalActorRef]
[warn]       val watcher = self.asInstanceOf[InternalActorRef]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteWatcher.scala:136: [scapegoat] Suspicious match on class object
[warn]   Matching on an companion object of a case class is probably not what you intended.
[warn]   case RemoteWatcher.Stats => {

[warn]   val watchSet: scala.collection.immutable.Set[(akka.actor.ActorRef, akka.actor.ActorRef)] = RemoteWatcher.this.watching.iterator.flatMap[(akka.actor.InternalActorRef, akka.actor.InternalActorRef)](((x0$1: (akka.actor.InternalActorRef, scala.collection.mutable.Set[akka.actor.InternalActorRef])) => x0$1 match {

[warn]   case (_1: akka.actor.InternalActorRef, _2: scala.collection.mutable.Set[akka.actor.InternalActorRef])(akka.actor.InternalActorRef, scala.collection.mutabl
[warn]     case Stats ?
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemoteWatcher.scala:86: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val x$1: Set[akka.actor.Address] = _
[warn] private[akka] class RemoteWatcher(
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:49: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]   override def createExtension(system: ExtendedActorSystem) = RARP(system.provider.asInstanceOf[RemoteActorRefProvider])
[warn]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:448: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EndpointManager.this.context.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val extendedSystem = context.system.asInstanceOf[ExtendedActorSystem]
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:644: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   assoc.association.asInstanceOf[akka.remote.transport.AkkaProtocolHandle]
[warn]             val handle = assoc.association.asInstanceOf[AkkaProtocolHandle]
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:837: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EndpointManager.this.context.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]             provider.create(t, context.system.asInstanceOf[ExtendedActorSystem])
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:152: [scapegoat] Finalizer without super
[warn]   Finalizers should call `super.finalize()` to ensure superclasses are able to run their finalization logic.
[warn]         def finalize(): Unit = {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:82: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new RemoteTransportException(scala.StringContext.apply("No transport is responsible for address: [", "] although protocol [", "] is available.").s(remote, remote.protocol).+(" Make sure at least one transport is configured to be responsible for the address."), null)
[warn]             throw new RemoteTransportException(
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:91: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new RemoteTransportException(scala.StringContext.apply("Multiple transports are available for [", "]: [", "]. ").s(remote, responsibleTransports.mkString(",")).+("Remoting cannot decide which transport to use to reach the remote system. Change your configuration ").+("so that only one transport is r
[warn]             throw new RemoteTransportException(
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:97: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new RemoteTransportException(scala.StringContext.apply("No transport is loaded for protocol: [", "], available protocols: [", "]").s(remote.protocol, transportMapping.keys.mkString(", ")), null)
[warn]       case None ? throw new RemoteTransportException(
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:192: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new RemoteTransportException("No transport drivers were loaded.", null)
[warn]           if (transports.isEmpty) throw new RemoteTransportException("No transport drivers were loaded.", null)
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:222: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new RemoteTransportExceptionNoStackTrace("Attempted to send remote message but Remoting is not running.", null)
[warn]     case None          ? throw new RemoteTransportExceptionNoStackTrace("Attempted to send remote message but Remoting is not running.", null)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:230: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new RemoteTransportExceptionNoStackTrace("Attempted to send management command but Remoting is not running.", null)
[warn]     case None ? throw new RemoteTransportExceptionNoStackTrace("Attempted to send management command but Remoting is not running.", null)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:236: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new RemoteTransportExceptionNoStackTrace(scala.StringContext.apply("Attempted to quarantine address [", "] with UID [", "] but Remoting is not running").s(remoteAddress, uid), null)
[warn]     case _ ? throw new RemoteTransportExceptionNoStackTrace(
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:267: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Send.this.seqOpt.get
[warn]     def seq = seqOpt.get
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:457: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.actor.Address, Nothing]()
[info]   var transportMapping: Map[Address, AkkaProtocolTransport] = Map()
[info]                                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:464: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.actor.ActorRef, akka.remote.transport.AkkaProtocolHandle]()
[info]   var pendingReadHandoffs = Map[ActorRef, AkkaProtocolHandle]()
[info]                                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:465: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.actor.ActorRef, Vector[akka.remote.transport.Transport.InboundAssociation]]()
[info]   var stashedInbound = Map[ActorRef, Vector[InboundAssociation]]()
[info]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:828: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   EndpointManager.this.extendedSystem.dynamicAccess.createInstanceFor[akka.remote.transport.Transport](fqn, args)((ClassTag.apply[akka.remote.transport.Transport](classOf[akka.remote.transport.Transport]): scala.reflect.ClassTag[akka.remote.transport.Transport])).recover[akka.remote.transport.Transport](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => Noth
[warn]         }).get
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:545: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       listens map { ListensResult(addressesPromise, _) } recover {
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\Remoting.scala:745: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   ia match {

[warn]   case (ia @ (association: akka.remote.transport.AssociationHandle)akka.remote.transport.Transport.InboundAssociation((handle @ (_: akka.remote.transport.AkkaProtocolHandle)))) => Endpoint
[warn]   def handleInboundAssociation(ia: InboundAssociation, writerIsIdle: Boolean): Unit = ia match {
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\RemotingLifecycleEvent.scala:109: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val address: akka.actor.Address = address
[warn]   def copy(address: Address = address, uid: Int = uid) = new QuarantinedEvent(address, uid)
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSink.scala:102: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       private var envelopeInFlight: EnvelopeBuffer = null
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSink.scala:191: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         offerTask.buffer = null
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSink.scala:192: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         envelopeInFlight = null
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSink.scala:111: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new AeronSink.OfferTask($anon.this.pub, null, $anon.this.lastMsgSize, $anon.this.getAsyncCallback[Unit](((x$1: Unit) => $anon.this.taskOnOfferSuccess())), AeronSink.this.giveUpAfter, $anon.this.getAsyncCallback[Unit](((x$2: Unit) => $anon.this.onGiveUp())), $anon.this.getAsyncCallback[Unit](((x$3: U
[warn]       private val offerTask = new OfferTask(pub, null, lastMsgSize, getAsyncCallback(_ ? taskOnOfferSuccess()),
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSource.scala:48: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     def reset(): Unit = messageReceived = null
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSource.scala:50: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     private[remote] var messageReceived: EnvelopeBuffer = null // private to avoid scalac warning about exposing EnvelopeBuffer
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSource.scala:39: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   msg.ne(null)
[warn]         if (msg ne null) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSource.scala:135: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   msg.ne(null)
[warn]           if (msg ne null)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\AeronSource.scala:187: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]           case NonFatal(_) ? // just in case it's called before stage is initialized, ignore
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArterySettings.scala:30: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val config: com.typesafe.config.Config = ArterySettings.this.config.getConfig("canonical")
[warn]     val config = getConfig("canonical")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArterySettings.scala:39: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val config: com.typesafe.config.Config = ArterySettings.this.config.getConfig("bind")
[warn]     val config = getConfig("bind")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArterySettings.scala:65: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val config: com.typesafe.config.Config = ArterySettings.this.config.getConfig("advanced")
[warn]     val config = getConfig("advanced")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArterySettings.scala:157: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val config: com.typesafe.config.Config = Compression.this.config.getConfig("actor-refs")
[warn]       val config = getConfig("actor-refs")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArterySettings.scala:164: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val config: com.typesafe.config.Config = Compression.this.config.getConfig("manifests")
[warn]       val config = getConfig("manifests")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:763: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("{} failed after shutdown. {}").s()
[warn]         log.error(cause, s"{} failed after shutdown. {}", streamName, cause.getMessage)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:1092: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   class AeronTerminated extends scala.`package`.RuntimeException {

[warn]   <paramaccessor> private[this] val e: Throwable = _;

[warn]   def <init>(e: Throwable): akka.remote.artery.ArteryTransport.AeronTerminated = {

[warn]     AeronTerminated.super.<init>(e);

[warn]     ()

[warn]   }

[warn] }
[warn]   class AeronTerminated(e: Throwable) extends RuntimeException(e)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:132: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var uniqueRemoteAddressValueCache: Option[UniqueAddress] = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:141: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   AssociationState.this.uniqueRemoteAddressValueCache.ne(null)
[warn]     if (uniqueRemoteAddressValueCache ne null)
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:882: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   cached.ne(null)
[warn]         if (cached ne null) cached
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:344: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ArteryTransport.this._bindAddress.address.host.get
[warn]   private def inboundChannel = s"aeron:udp?endpoint=${_bindAddress.address.host.get}:${_bindAddress.address.port.get}"
[warn]                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:344: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ArteryTransport.this._bindAddress.address.port.get
[warn]   private def inboundChannel = s"aeron:udp?endpoint=${_bindAddress.address.host.get}:${_bindAddress.address.port.get}"
[warn]                                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:345: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   a.host.get
[warn]   private def outboundChannel(a: Address) = s"aeron:udp?endpoint=${a.host.get}:${a.port.get}"
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:345: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   a.port.get
[warn]   private def outboundChannel(a: Address) = s"aeron:udp?endpoint=${a.host.get}:${a.port.get}"
[warn]                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:676: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case akka.remote.artery.ArteryTransport.ShuttingDown => ()
[warn]           case ShuttingDown ? // silence it
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:874: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case akka.remote.artery.ArteryTransport.ShuttingDown => ()
[warn]       case ShuttingDown ? // silence it
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:891: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case akka.remote.artery.ArteryTransport.ShuttingDown => ()
[warn]       case ShuttingDown ? // silence it
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:917: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case akka.remote.artery.ArteryTransport.ShuttingDown => ()
[warn]       case ShuttingDown ? // silence it
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:239: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (inboundContext).
[warn]                                       inboundContext: InboundContext, associations: Set[Association]) extends Actor {
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:805: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: akka.Done = _
[warn]       _ ← taskRunner.stop()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:851: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: Iterator[akka.Done] = _
[warn]       _ ← Future.sequence(streamMatValues.get().valuesIterator.map {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ArteryTransport.scala:1058: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val afrFile: java.nio.file.Path = FlightRecorder.createFlightRecorderFile(ArteryTransport.this.settings.Advanced.FlightRecorderDestination, FlightRecorder.createFlightRecorderFile$default$2)
[warn]       val afrFile = FlightRecorder.createFlightRecorderFile(settings.Advanced.FlightRecorderDestination)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:247: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObjectVolatile(this, AbstractAssociation.sharedStateOffset).asInstanceOf[akka.remote.artery.AssociationState]
[warn]     Unsafe.instance.getObjectVolatile(this, AbstractAssociation.sharedStateOffset).asInstanceOf[AssociationState]
[warn]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:309: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   message.asInstanceOf[AnyRef]
[warn]       outboundEnvelopePool.acquire().init(recipient, message.asInstanceOf[AnyRef], sender)
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:682: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("{} to [{}] failed after shutdown. {}").s()
[warn]         log.error(cause, s"{} to [{}] failed after shutdown. {}", streamName, remoteAddress, cause.getMessage)
[warn]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:383: [scapegoat] find().isDefined() instead of exists()
[info]   `find().isDefined` can be replaced with `exists()`, which is more concise.
[info]   Association.this.priorityMessageDestinations.find(elements).isDefined
[info]               if (priorityMessageDestinations.find(elements).isDefined) {
[info]                                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:386: [scapegoat] find().isDefined() instead of exists()
[info]   `find().isDefined` can be replaced with `exists()`, which is more concise.
[info]   Association.this.largeMessageDestinations.find(elements).isDefined
[info]               } else if (transport.largeMessageChannelEnabled && largeMessageDestinations.find(elements).isDefined) {
[info]                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:325: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   message.isInstanceOf[akka.actor.ActorSelectionMessage]
[warn]     if (message.isInstanceOf[ActorSelectionMessage] || !quarantined || message == ClearSystemMessageDelivery) {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:496: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Association.this.controlQueue.isInstanceOf[akka.remote.artery.Association.QueueWrapper]
[warn]     if (!controlQueue.isInstanceOf[QueueWrapper])
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:302: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case akka.remote.artery.ArteryTransport.ShuttingDown => ()
[warn]       case ShuttingDown ? // silence it
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:366: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case akka.remote.artery.ArteryTransport.ShuttingDown => ()
[warn]         case ShuttingDown ? // silence it
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Association.scala:417: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case akka.remote.artery.ArteryTransport.ShuttingDown => ()
[warn]           case ShuttingDown ? // can be thrown if `offer` triggers new materialization
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:385: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   h.asInstanceOf[akka.remote.artery.HeaderBuilderImpl]
[warn]     val header = h.asInstanceOf[HeaderBuilderImpl]
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:426: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   h.asInstanceOf[akka.remote.artery.HeaderBuilderImpl]
[warn]     val header = h.asInstanceOf[HeaderBuilderImpl]
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:500: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   bytes.apply(i).asInstanceOf[Char]
[warn]         chars(i) = bytes(i).asInstanceOf[Char]
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:520: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObject(literal, EnvelopeBuffer.StringValueFieldOffset).asInstanceOf[Array[Char]]
[warn]       val chars = Unsafe.instance.getObject(literal, StringValueFieldOffset).asInstanceOf[Array[Char]]
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:524: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   chars.apply(i).asInstanceOf[Byte]
[warn]         bytes(i) = chars(i).asInstanceOf[Byte]
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:224: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var _senderActorRef: String = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:226: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var _recipientActorRef: String = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:230: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var _manifest: String = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:233: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var _metadataContainer: ByteString = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:237: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _senderActorRef = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:239: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _recipientActorRef = null
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:243: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _manifest = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:285: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _senderActorRef = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:301: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _recipientActorRef = null
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:355: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _metadataContainer = null
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:458: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       header._senderActorRef = null
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:468: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       header._recipientActorRef = null
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:478: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       header._manifest = null
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:36: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   buf.ne(null)
[warn]     if (buf ne null) {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:337: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   HeaderBuilderImpl.this._manifest.ne(null)
[warn]     if (_manifest ne null) OptionVal.Some(_manifest)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\BufferPool.scala:508: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   literal.eq(null)
[warn]     val length = if (literal eq null) 0 else literal.length
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:290: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Decoder.this.system.provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]         new ActorRefResolveCacheWithAddress(system.provider.asInstanceOf[RemoteActorRefProvider], uniqueLocalAddress)
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:320: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.asInstanceOf[akka.actor.InternalActorRef]
[warn]             OptionVal(ref.asInstanceOf[InternalActorRef])
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:334: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.asInstanceOf[akka.actor.InternalActorRef]
[warn]             OptionVal(ref.asInstanceOf[InternalActorRef])
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:38: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   private[remote] class ChangeOutboundCompressionFailed extends scala.`package`.RuntimeException {

[warn]   def <init>(): akka.remote.artery.Encoder.ChangeOutboundCompressionFailed = {

[warn]     ChangeOutboundCompressionFailed.super.<init>("Change of outbound compression table failed (will be retried), because materialization did not complete yet");

[warn]     ()

[warn]   }

[warn] }
[warn]   private[remote] class ChangeOutboundCompressionFailed extends RuntimeException(
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:106: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   outboundEnvelope.message.isInstanceOf[akka.remote.artery.ArteryMessage]
[warn]         headerBuilder.useOutboundCompression(!outboundEnvelope.message.isInstanceOf[ArteryMessage])
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:147: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.isInstanceOf[java.nio.BufferOverflowException]
[warn]               case _ if e.isInstanceOf[java.nio.BufferOverflowException] ?
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:266: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   v.isInstanceOf[akka.actor.EmptyLocalActorRef]
[warn]   override protected def isCacheable(v: InternalActorRef): Boolean = !v.isInstanceOf[EmptyLocalActorRef]
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:419: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.isInstanceOf[akka.actor.EmptyLocalActorRef]
[warn]                   if (ref.isInstanceOf[EmptyLocalActorRef]) log.warning(
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:186: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   metadata.ne(null)
[warn]             if (metadata ne null) serializedMetadatas.set(instrumentId, metadata)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:277: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (bufferPool).
[warn]   bufferPool:         EnvelopeBufferPool,
[warn]   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Codecs.scala:506: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (inboundContext).
[warn]   inboundContext: InboundContext,
[warn]   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Control.scala:46: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[remote] case class ActorSystemTerminating(from: UniqueAddress) extends ControlMessage
[info]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Control.scala:51: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[remote] case class ActorSystemTerminatingAck(from: UniqueAddress) extends ArteryMessage
[info]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Control.scala:121: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   env.message.isInstanceOf[akka.remote.artery.ControlMessage]
[warn]           case env: InboundEnvelope if env.message.isInstanceOf[ControlMessage] ?
[warn]                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:34: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class SectionParameters(
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:112: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Structure(startTime: Instant, alertLog: RollingLog, loFreqLog: RollingLog, hiFreqLog: RollingLog) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:127: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class RollingLog(sectionParameters: SectionParameters, logs: immutable.Seq[Log]) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:136: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Log(sectionParameters: SectionParameters, offset: Long, id: Int, state: LogState, head: Long) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:213: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class RichEntry(timeStamp: Instant, dirty: Boolean, code: Long, metadata: Array[Byte]) extends Entry {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:221: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class CompactEntry(timeStamp: Instant, dirty: Boolean, code: Long, param: Long) extends Entry {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:78: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var raFile: RandomAccessFile = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:79: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var channel: FileChannel = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:80: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var reader: FlightRecorderReader = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:97: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   reader.ne(null)
[warn]       if (reader ne null) reader.close()
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:98: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   channel.ne(null)
[warn]       if (channel ne null) channel.close()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\FlightRecorderReader.scala:99: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   raFile.ne(null)
[warn]       if (raFile ne null) raFile.close()
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Handshake.scala:243: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Dropping message [{}] from unknown system with UID [{}]. ").s()
[warn]               s"Dropping message [{}] from unknown system with UID [{}]. " +
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Handshake.scala:70: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       private var pendingMessage: OutboundEnvelope = null
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Handshake.scala:96: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]               pendingMessage = null
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Handshake.scala:92: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.pendingMessage.eq(null)
[warn]             if (pendingMessage eq null)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\Handshake.scala:54: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   system:               ActorSystem,
[warn]   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\InboundEnvelope.scala:61: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   inEnvelope.asInstanceOf[akka.remote.artery.ReusableInboundEnvelope]
[warn]     create = () ? new ReusableInboundEnvelope, clear = inEnvelope ? inEnvelope.asInstanceOf[ReusableInboundEnvelope].clear())
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\InboundEnvelope.scala:73: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var _classManifest: String = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\InboundEnvelope.scala:75: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var _message: AnyRef = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\InboundEnvelope.scala:76: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var _envelopeBuffer: EnvelopeBuffer = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\InboundEnvelope.scala:96: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _envelopeBuffer = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\InboundEnvelope.scala:107: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _message = null
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\InboundQuarantineCheck.scala:47: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   env.message.isInstanceOf[akka.remote.artery.Quarantined]
[warn]               if (!env.message.isInstanceOf[Quarantined] && !isHeartbeat(env.message))
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:18: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getObject(s, EnvelopeBuffer.StringValueFieldOffset).asInstanceOf[Array[Char]]
[warn]     val chars = Unsafe.instance.getObject(s, EnvelopeBuffer.StringValueFieldOffset).asInstanceOf[Array[Char]]
[warn]                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:149: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[V]
[warn]       values(position) = null.asInstanceOf[V]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:218: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("LruBoundedCache(").s()
[warn]     s"LruBoundedCache(" +
[warn]     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:45: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[akka] case class CacheStatistics(entries: Int, maxProbeDistance: Int, averageProbeDistance: Double)
[info]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:78: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LruBoundedCache.this.values.apply(position).eq(null)
[warn]       if (values(position) eq null) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:98: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LruBoundedCache.this.values.apply(i).ne(null)
[warn]       if (values(i) ne null) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:114: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LruBoundedCache.this.values.apply(position).eq(null)
[warn]       if (values(position) eq null) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:169: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LruBoundedCache.this.values.apply(position).eq(null)
[warn]     if (values(position) eq null) {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:58: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type K
[warn] private[akka] abstract class LruBoundedCache[K: ClassTag, V <: AnyRef: ClassTag](capacity: Int, evictAgeThreshold: Int) {
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\LruBoundedCache.scala:185: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val otherEpoch: Int = LruBoundedCache.this.epochs.apply(position)
[warn]         val otherEpoch = epochs(position)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\MessageDispatcher.scala:66: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sel.msg.isInstanceOf[akka.actor.PossiblyHarmful]
[warn]               sel.msg.isInstanceOf[PossiblyHarmful] || l != provider.rootGuardian)) {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\MetadataEnvelopeSerializer.scala:50: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserialize(system: akka.actor.ExtendedActorSystem, originUid: Long, serialization: akka.serialization.Serialization, serializer: Int, classManifest: String, envelope: akka.remote.artery.EnvelopeBuffer): AnyRef = serialization.deserializeByteBuffer(envelope.byteBuffer, serializer, classManifest)
[warn]   def deserialize(system: ExtendedActorSystem, originUid: Long, serialization: Serialization,
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\ObjectPool.scala:16: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   obj.eq(null)
[warn]     if (obj eq null) create()
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\OutboundEnvelope.scala:51: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var _message: AnyRef = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\OutboundEnvelope.scala:68: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _message = null
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:141: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.Array.ofDim[Object](MetadataMap.this.capacity)((ClassTag.Object: scala.reflect.ClassTag[Object])).asInstanceOf[Array[T]]
[warn]     if (backing == null) backing = Array.ofDim[Object](capacity).asInstanceOf[Array[T]]
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:152: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]         backing(i) = null.asInstanceOf[T]
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:176: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]         backing(i) = null.asInstanceOf[T]
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:149: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (MetadataMap.this.backing.==(null))

[warn]   ()

[warn] else

[warn]   {

[warn]     if (MetadataMap.this.backing.apply(i).!=(null))

[warn]       MetadataMap.this._usedSlots_=(MetadataMap.this._usedSlots.-(1))

[warn]     else

[warn]       ();

[warn]     MetadataMap.this.backing.update(i, null.asInstanceOf[T])

[warn]   }
[warn]       if (backing == null) ()
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:172: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (MetadataMap.this.isEmpty)

[warn]   ()

[warn] else

[warn]   {

[warn]     var i: Int = 0;

[warn]     while$3(){

[warn]       if (i.<(MetadataMap.this.capacity))

[warn]         {

[warn]           {

[warn]             MetadataMap.this.backing.update(i, null.asInstanceOf[T]);

[warn]             i = i.+(1)

[warn]           };

[warn]           while$3()

[warn]         }

[warn]       else

[warn]         ()

[warn]     };

[warn]     MetadataMap.this._usedSlots_=(0)

[warn]   }
[warn]     if (isEmpty) ()
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:183: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("MetadataMap(<empty>)").s()
[warn]     if (backing == null) s"MetadataMap(<empty>)"
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:92: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   protected var backing: Array[T] = null // TODO re-think if a plain LinkedList wouldn't be fine here?
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:99: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MetadataMap.this.backing.==(null)
[warn]     if (backing == null) OptionVal.None
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:115: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   it.!=(null)
[warn]       if (it != null) {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:132: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.!=(null)
[warn]       if (t != null) {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:141: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MetadataMap.this.backing.==(null)
[warn]     if (backing == null) backing = Array.ofDim[Object](capacity).asInstanceOf[Array[T]]
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:148: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.==(null)
[warn]     if (t == null) {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:149: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MetadataMap.this.backing.==(null)
[warn]       if (backing == null) ()
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:151: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MetadataMap.this.backing.apply(i).!=(null)
[warn]         if (backing(i) != null) _usedSlots -= 1 // we're clearing a spot
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:157: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MetadataMap.this.backing.apply(i).==(null)
[warn]       if (backing(i) == null) {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:183: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MetadataMap.this.backing.==(null)
[warn]     if (backing == null) s"MetadataMap(<empty>)"
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\RemoteInstrument.scala:68: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.dynamicAccess.createInstanceFor[akka.remote.artery.RemoteInstrument](fqcn, immutable.this.Nil)((ClassTag.apply[akka.remote.artery.RemoteInstrument](classOf[akka.remote.artery.RemoteInstrument]): scala.reflect.ClassTag[akka.remote.artery.RemoteInstrument])).orElse[akka.remote.artery.RemoteInstrument](system.dynamicAccess.createInstanceFor[akka.remote.artery.RemoteInstrument](fqcn, immutable.this.List.apply[(Class[akka.actor.ExtendedActorSystem], akka.actor.ExtendedActorSystem)](scala.this.
[warn]         .get
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\SendQueue.scala:59: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       private var consumerQueue: Queue[T] = null
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\SendQueue.scala:114: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       @volatile private var producerQueue: Queue[T] = null
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\SendQueue.scala:80: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.consumerQueue.ne(null)
[warn]         if (consumerQueue ne null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\SendQueue.scala:105: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   $anon.this.consumerQueue.ne(null)
[warn]         if (consumerQueue ne null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\SendQueue.scala:123: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   q.eq(null)
[warn]         if (q eq null) throw new IllegalStateException("offer not allowed before injecting the queue")
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\StageLogging.scala:23: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   StageLogging.this._log.eq(null)
[warn]     if (_log eq null) {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\SystemMessageDelivery.scala:157: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   $anon.this.unacknowledged.peek().message.asInstanceOf[akka.remote.artery.SystemMessageDelivery.SystemMessageEnvelope]
[warn]           unacknowledged.peek().message.asInstanceOf[SystemMessageEnvelope].seqNo <= ackedSeqNo) {
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\TaskRunner.scala:59: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]           elements(i) = null.asInstanceOf[T]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\TaskRunner.scala:69: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]         elements(i) = null.asInstanceOf[T]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\TaskRunner.scala:56: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (i.==(size))

[warn]   ()

[warn] else

[warn]   if (ArrayBag.this.elements.apply(i).==(e))

[warn]     ArrayBag.this.elements.update(i, null.asInstanceOf[T])

[warn]   else

[warn]     tryRemove(i.+(1))
[warn]         if (i == size)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\TaskRunner.scala:192: [scapegoat] Empty while block
[warn]   An empty while block is considered as dead code.
[warn]   while$4(){

[warn]   if (TaskRunner.this.cmdQueue.poll().!=(null))

[warn]     {

[warn]       ();

[warn]       while$4()

[warn]     }

[warn]   else

[warn]     ()

[warn] }
[warn]         while (cmdQueue.poll() != null) () // gc friendly
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\TaskRunner.scala:45: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ArrayBag.this.elements.apply(i).eq(null)
[warn]         } else if (elements(i) eq null)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\TaskRunner.scala:170: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   task.ne(null)
[warn]       if (task ne null) try {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\TaskRunner.scala:192: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TaskRunner.this.cmdQueue.poll().!=(null)
[warn]         while (cmdQueue.poll() != null) () // gc friendly
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\CompressionTable.scala:34: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.Array.ofDim[(Object, Int)](CompressionTable.this.dictionary.size)((ClassTag.apply[(Object, Int)](classOf[scala.Tuple2]): scala.reflect.ClassTag[(Object, Int)])).asInstanceOf[Array[(T, Int)]]
[warn]       val tups = Array.ofDim[(Object, Int)](dictionary.size).asInstanceOf[Array[(T, Int)]]
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\CompressionTable.scala:35: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.Array.ofDim[Object](CompressionTable.this.dictionary.size)((ClassTag.Object: scala.reflect.ClassTag[Object])).asInstanceOf[Array[T]]
[warn]       val ts = Array.ofDim[Object](dictionary.size).asInstanceOf[Array[T]]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\CompressionTable.scala:62: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CompressionTable.this.CompareBy2ndValue.asInstanceOf[java.util.Comparator[(T, Int)]]
[warn]   def compareBy2ndValue[T]: Comparator[Tuple2[T, Int]] = CompareBy2ndValue.asInstanceOf[Comparator[(T, Int)]]
[warn]                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\CompressionTable.scala:65: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CompressionTable.this._empty.asInstanceOf[akka.remote.artery.compress.CompressionTable[T]]
[warn]   def empty[T] = _empty.asInstanceOf[CompressionTable[T]]
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\CompressionTable.scala:31: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   CompressionTable.this.dictionary.values.sum[Int](math.this.Numeric.IntIsIntegral).+(CompressionTable.this.dictionary.size).==(expectedGaplessSum)
[warn]       require(dictionary.values.sum + dictionary.size == expectedGaplessSum, "Given compression map does not seem to be gap-less and starting from zero, " +
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\CompressionTable.scala:30: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   CompressionTable.this.dictionary.values.min
[warn]       require(dictionary.values.min == 0, "Compression table should start allocating from 0, yet lowest allocated id was " + dictionary.values.min)
[warn]                                                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\DecompressionTable.scala:38: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DecompressionTable.this._empty.asInstanceOf[akka.remote.artery.compress.DecompressionTable[T]]
[warn]   def empty[T] = _empty.asInstanceOf[DecompressionTable[T]]
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:93: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("[compress] hitActorRef(", ", ", ", ", ", ", ")").s(originUid, address, ref, n))

[warn] else

[warn]   ()
[warn]     if (ArterySettings.Compression.Debug) println(s"[compress] hitActorRef($originUid, $address, $ref, $n)")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:117: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("[compress] hitClassManifest(", ", ", ", ", ", ", ")").s(originUid, address, manifest, n))

[warn] else

[warn]   ()
[warn]     if (ArterySettings.Compression.Debug) println(s"[compress] hitClassManifest($originUid, $address, $manifest, $n)")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:198: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Advertise {} compression [{}] to [{}#{}]").s()
[warn]     log.debug(s"Advertise {} compression [{}] to [{}#{}]", Logging.simpleName(getClass), table, outboundContext.remoteAddress,
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:219: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Advertise {} compression [{}] to [{}#{}]").s()
[warn]     log.debug(s"Advertise {} compression [{}] to [{}#{}]", Logging.simpleName(getClass), table, outboundContext.remoteAddress,
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:475: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("This could happen if this node has started a new ActorSystem bound to the same address as previously, ").s()
[warn]       s"This could happen if this node has started a new ActorSystem bound to the same address as previously, " +
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:476: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("and previous messages from a remote system were still in flight (using an old compression table). ").s()
[warn]       s"and previous messages from a remote system were still in flight (using an old compression table). " +
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:477: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("The remote system is expected to drop the compression table and this system will advertise a new one.").s()
[warn]       s"The remote system is expected to drop the compression table and this system will advertise a new one.")
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:136: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   InboundCompressionsImpl.this._actorRefsIns.putIfAbsent(scala.this.Predef.long2Long(originUid), scala.None).!=(null)
[warn]         if (_actorRefsIns.putIfAbsent(originUid, None) != null)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:145: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   InboundCompressionsImpl.this._classManifestsIns.putIfAbsent(scala.this.Predef.long2Long(originUid), scala.None).!=(null)
[warn]         if (_classManifestsIns.putIfAbsent(originUid, None) != null)
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:324: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   value.!=(null)
[warn]       if (value != null) OptionVal.Some[T](value)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:329: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   value.!=(null)
[warn]       if (value != null) OptionVal.Some[T](value)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\InboundCompressions.scala:331: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   current.advertisementInProgress.get
[warn]     } else if (current.advertisementInProgress.isDefined && incomingTableVersion == current.advertisementInProgress.get.version) {
[warn]                                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\TopHeavyHitters.scala:40: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.Array.ofDim[T](TopHeavyHitters.this.max)(TopHeavyHitters.this.classTag).asInstanceOf[Array[T]]
[warn]     val snap = Array.ofDim(max).asInstanceOf[Array[T]]
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\TopHeavyHitters.scala:217: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TopHeavyHitters.this.items.update(index, null)
[warn]       items(index) = null
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\TopHeavyHitters.scala:242: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TopHeavyHitters.this.items.apply(index).!=(null)
[warn]     while (items(index) != null) {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\TopHeavyHitters.scala:97: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val o: T = _
[warn]     @tailrec def loop(index: Int, start: Int, hashCodeVal: HashCodeVal, o: T): Int = {
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\artery\compress\TopHeavyHitters.scala:272: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val hashes: Array[Int] = _
[warn]   private def findEqIndex(hashes: Array[Int], searchFromIndex: Int, hashCode: Int): Int = {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\routing\RemoteRouterConfig.scala:57: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   context.asInstanceOf[akka.actor.ActorCell]
[warn]     val ref = context.asInstanceOf[ActorCell].attachChild(
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\routing\RemoteRouterConfig.scala:74: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.local.withFallback(local).asInstanceOf[akka.routing.Pool]
[warn]       copy(local = this.local.withFallback(local).asInstanceOf[Pool])
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\routing\RemoteRouterConfig.scala:75: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.local.withFallback(other).asInstanceOf[akka.routing.Pool]
[warn]     case _ ? copy(local = this.local.withFallback(other).asInstanceOf[Pool])
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ActorRefResolveCache.scala:63: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   v.isInstanceOf[akka.actor.EmptyLocalActorRef]
[warn]   override protected def isCacheable(v: ActorRef): Boolean = !v.isInstanceOf[EmptyLocalActorRef]
[warn]                                                                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ActorRefResolveCache.scala:23: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.remote.serialization.ActorRefResolveThreadLocalCache = ActorRefResolveThreadLocalCache.super.get(system)
[info]   override def get(system: ActorSystem): ActorRefResolveThreadLocalCache = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ActorRefResolveCache.scala:47: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val provider: akka.remote.RemoteActorRefProvider = _).
[warn]   def threadLocalCache(provider: RemoteActorRefProvider): ActorRefResolveCache =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ActorRefResolveCache.scala:47: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val provider: akka.remote.RemoteActorRefProvider = _
[warn]   def threadLocalCache(provider: RemoteActorRefProvider): ActorRefResolveCache =
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ArteryMessageSerializer.scala:144: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.collection.JavaConverters.asScalaBufferConverter[Integer](protoAdv.getValuesList()).asScala.asInstanceOf[Iterable[Int]]
[warn]         protoAdv.getValuesList.asScala.asInstanceOf[Iterable[Int]] /* to avoid having to call toInt explicitly */ )
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ArteryMessageSerializer.scala:156: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserializeCompressionTableAdvertisementAck(bytes: Array[Byte], create: (akka.remote.UniqueAddress, Byte) => AnyRef): AnyRef = {

[warn]   val msg: akka.remote.ArteryControlFormats.CompressionTableAdvertisementAck = akka.remote.ArteryControlFormats.CompressionTableAdvertisementAck.parseFrom(bytes);

[warn]   
[warn]   def deserializeCompressionTableAdvertisementAck(bytes: Array[Byte], create: (UniqueAddress, Byte) ? AnyRef): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ArteryMessageSerializer.scala:193: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserializeSystemMessageDeliveryAck(bytes: Array[Byte], create: (Long, akka.remote.UniqueAddress) => AnyRef): AnyRef = {

[warn]   val protoAck: akka.remote.ArteryControlFormats.SystemMessageDeliveryAck = akka.remote.ArteryControlFormats.SystemMessageDeliveryAck.parseFrom(bytes);

[warn]   create.apply(protoA
[warn]   def deserializeSystemMessageDeliveryAck(bytes: Array[Byte], create: (Long, UniqueAddress) ? AnyRef): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ArteryMessageSerializer.scala:202: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserializeWithFromAddress(bytes: Array[Byte], create: akka.remote.UniqueAddress => AnyRef): AnyRef = create.apply(ArteryMessageSerializer.this.deserializeUniqueAddress(akka.remote.ArteryControlFormats.MessageWithAddress.parseFrom(bytes).getAddress()))
[warn]   def deserializeWithFromAddress(bytes: Array[Byte], create: UniqueAddress ? AnyRef): AnyRef =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ArteryMessageSerializer.scala:182: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ArteryMessageSerializer.this.serialization.deserialize(protoEnv.getMessage().toByteArray(), protoEnv.getSerializerId(), if (protoEnv.hasMessageManifest())

[warn]   protoEnv.getMessageManifest().toStringUtf8()

[warn] else

[warn]   "").get
[warn]       if (protoEnv.hasMessageManifest) protoEnv.getMessageManifest.toStringUtf8 else "").get,
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\DaemonMsgCreateSerializer.scala:114: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   any.asInstanceOf[AnyRef]
[warn]   protected def serialize(any: Any): ByteString = ByteString.copyFrom(serialization.serialize(any.asInstanceOf[AnyRef]).get)
[warn]                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\DaemonMsgCreateSerializer.scala:80: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = {

[warn]   val proto: akka.remote.WireFormats.DaemonMsgCreateData = akka.remote.WireFormats.DaemonMsgCreateData.parseFrom(bytes);

[warn]   def deploy(protoDeploy: akka.remote.WireFormats.DeployData): akka.actor.Deploy = {

[warn]     val config: com
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\DaemonMsgCreateSerializer.scala:32: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   DaemonMsgCreateSerializer.this.<init>(null)
[warn]   def this() = this(null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\DaemonMsgCreateSerializer.scala:36: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   DaemonMsgCreateSerializer.this.system.eq(null)
[warn]     if (system eq null) 3
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\DaemonMsgCreateSerializer.scala:101: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DaemonMsgCreateSerializer.this.system.dynamicAccess.getClassFor[AnyRef](proto.getProps().getClazz())((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])).get
[warn]       val clazz = system.dynamicAccess.getClassFor[AnyRef](proto.getProps.getClazz).get
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\DaemonMsgCreateSerializer.scala:114: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DaemonMsgCreateSerializer.this.serialization.serialize(any.asInstanceOf[AnyRef]).get
[warn]   protected def serialize(any: Any): ByteString = ByteString.copyFrom(serialization.serialize(any.asInstanceOf[AnyRef]).get)
[warn]                                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\DaemonMsgCreateSerializer.scala:118: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DaemonMsgCreateSerializer.this.system.dynamicAccess.getClassFor[AnyRef](p._2)((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])).get
[warn]     else deserialize(p._1, system.dynamicAccess.getClassFor[AnyRef](p._2).get)
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\DaemonMsgCreateSerializer.scala:101: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val clazz: Class[_ <: AnyRef] = DaemonMsgCreateSerializer.this.system.dynamicAccess.getClassFor[AnyRef](proto.getProps().getClazz())((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])).get
[warn]       val clazz = system.dynamicAccess.getClassFor[AnyRef](proto.getProps.getClazz).get
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MessageContainerSerializer.scala:42: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sel.msg.asInstanceOf[AnyRef]
[warn]     val message = sel.msg.asInstanceOf[AnyRef]
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MessageContainerSerializer.scala:77: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = {

[warn]   val selectionEnvelope: akka.remote.ContainerFormats.SelectionEnvelope = akka.remote.ContainerFormats.SelectionEnvelope.parseFrom(bytes);

[warn]   val manifest: String = if (selectionEnvelope.hasMessageManifest())

[warn]     selectionE
[warn]   def fromBinary(bytes: Array[Byte], manifest: Option[Class[_]]): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MessageContainerSerializer.scala:22: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MessageContainerSerializer.this.<init>(null)
[warn]   def this() = this(null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MessageContainerSerializer.scala:28: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MessageContainerSerializer.this.system.eq(null)
[warn]     if (system eq null) 6
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MessageContainerSerializer.scala:83: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MessageContainerSerializer.this.serialization.deserialize(selectionEnvelope.getEnclosedMessage().toByteArray(), selectionEnvelope.getSerializerId(), manifest).get
[warn]       manifest).get
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MessageContainerSerializer.scala:79: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val manifest: String = if (selectionEnvelope.hasMessageManifest())

[warn]   selectionEnvelope.getMessageManifest().toStringUtf8()

[warn] else

[warn]   ""
[warn]     val manifest = if (selectionEnvelope.hasMessageManifest) selectionEnvelope.getMessageManifest.toStringUtf8 else ""
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MiscMessageSerializer.scala:181: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MiscMessageSerializer.this.payloadSupport.deserializePayload(akka.remote.ContainerFormats.Payload.parseFrom(bytes)).asInstanceOf[Throwable]
[warn]     Status.Failure(payloadSupport.deserializePayload(ContainerFormats.Payload.parseFrom(bytes)).asInstanceOf[Throwable])
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MiscMessageSerializer.scala:200: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MiscMessageSerializer.this.payloadSupport.deserializePayload(serializedEx.getCause()).asInstanceOf[Throwable]
[warn]       payloadSupport.deserializePayload(serializedEx.getCause).asInstanceOf[Throwable]
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MiscMessageSerializer.scala:104: [scapegoat] Duplicated map key
[warn]   A map key is overwritten by a later entry.
[warn]   scala.this.Predef.Map.apply[String, Array[Byte] => AnyRef](scala.this.Predef.ArrowAssoc[String](Misc
[warn]   private val fromBinaryMap = Map[String, Array[Byte] ? AnyRef](
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\MiscMessageSerializer.scala:82: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ex.getActor.ne(null)
[warn]     if (ex.getActor ne null)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\PrimitiveSerializers.scala:87: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[String]
[warn]   override def toBinary(o: AnyRef): Array[Byte] = o.asInstanceOf[String].getBytes("UTF-8")
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\PrimitiveSerializers.scala:97: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[akka.util.ByteString]
[warn]     val bs = o.asInstanceOf[ByteString]
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\PrimitiveSerializers.scala:108: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   o.asInstanceOf[akka.util.ByteString]
[warn]     val bs = o.asInstanceOf[ByteString]
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:100: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   toByteArrayMethod(toByteArrayMethod$default$1).invoke(obj).asInstanceOf[Array[Byte]]
[warn]     toByteArrayMethod().invoke(obj).asInstanceOf[Array[Byte]]
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:63: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         def parsingMethod(method: Method = null): Method = {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:86: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     def toByteArrayMethod(method: Method = null): Method = {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:44: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ProtobufSerializer.this.<init>(null)
[warn]   def this() = this(null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:48: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ProtobufSerializer.this.system.eq(null)
[warn]     if (system eq null) 2
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:69: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   method.eq(null)
[warn]                 if (method eq null) clazz.getDeclaredMethod("parseFrom", ProtobufSerializer.ARRAY_OF_BYTE_ARRAY: _*)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:77: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   parsingMethod(parsingMethod$default$1).invoke(null, bytes)
[warn]         parsingMethod().invoke(null, bytes)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ProtobufSerializer.scala:92: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   method.eq(null)
[warn]             if (method eq null) clazz.getMethod("toByteArray")
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\SystemMessageSerializer.scala:98: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSerializer.this.getCauseThrowable(sysmsg).asInstanceOf[akka.actor.ActorInitializationException]
[warn]             Some(getCauseThrowable(sysmsg).asInstanceOf[ActorInitializationException])
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\SystemMessageSerializer.scala:123: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSerializer.this.deserializeActorRef(sysmsg.getWatchData().getWatchee()).asInstanceOf[akka.actor.InternalActorRef]
[warn]           deserializeActorRef(sysmsg.getWatchData.getWatchee).asInstanceOf[InternalActorRef],
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\SystemMessageSerializer.scala:124: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSerializer.this.deserializeActorRef(sysmsg.getWatchData().getWatcher()).asInstanceOf[akka.actor.InternalActorRef]
[warn]           deserializeActorRef(sysmsg.getWatchData.getWatcher).asInstanceOf[InternalActorRef])
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\SystemMessageSerializer.scala:128: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSerializer.this.deserializeActorRef(sysmsg.getWatchData().getWatchee()).asInstanceOf[akka.actor.InternalActorRef]
[warn]           deserializeActorRef(sysmsg.getWatchData.getWatchee).asInstanceOf[InternalActorRef],
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\SystemMessageSerializer.scala:129: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSerializer.this.deserializeActorRef(sysmsg.getWatchData().getWatcher()).asInstanceOf[akka.actor.InternalActorRef]
[warn]           deserializeActorRef(sysmsg.getWatchData.getWatcher).asInstanceOf[InternalActorRef])
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\SystemMessageSerializer.scala:149: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSerializer.this.payloadSupport.deserializePayload(msg.getCauseData()).asInstanceOf[Throwable]
[warn]     payloadSupport.deserializePayload(msg.getCauseData).asInstanceOf[Throwable]
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ThrowableSupport.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ThrowableSupport.this.payloadSupport.deserializePayload(protoT.getCause()).asInstanceOf[Throwable]
[warn]         val cause = payloadSupport.deserializePayload(protoT.getCause).asInstanceOf[Throwable]
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ThrowableSupport.scala:25: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.getMessage().!=(null)
[warn]     if (t.getMessage != null)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ThrowableSupport.scala:27: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   t.getCause().!=(null)
[warn]     if (t.getCause != null)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ThrowableSupport.scala:30: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   stackTrace.!=(null)
[warn]     if (stackTrace != null) {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ThrowableSupport.scala:59: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ThrowableSupport.this.system.dynamicAccess.createInstanceFor[Throwable](protoT.getClassName(), immutable.this.List.apply[(Class[_ >: Throwable with String <: java.io.Serializable], java.io.Serializable)](scala.this.Predef.ArrowAssoc[Class[String]](classOf[java.lang.String]).→[String](protoT.getMessage()), scala.this.Predef.ArrowAssoc[Class[Throwable]](classOf[java.lang.Throwable]).→[Throwable](cause)))((ClassTag.apply[Throwable](classOf[java.lang.Throwable]): scala.reflect.ClassTag[Throwable])).
[warn]           List(classOf[String] → protoT.getMessage, classOf[Throwable] → cause)).get
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ThrowableSupport.scala:63: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ThrowableSupport.this.system.dynamicAccess.getClassFor[Throwable](protoT.getClassName())((ClassTag.apply[Throwable](classOf[java.lang.Throwable]): scala.reflect.ClassTag[Throwable])).get
[warn]         val clazz = system.dynamicAccess.getClassFor[Throwable](protoT.getClassName).get
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\ThrowableSupport.scala:68: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ThrowableSupport.this.system.dynamicAccess.createInstanceFor[Throwable](clazz, immutable.this.List.apply[(Class[String], String)](scala.this.Predef.ArrowAssoc[Class[String]](classOf[java.lang.String]).→[String](protoT.getMessage())))((ClassTag.apply[Throwable](classOf[java.lang.Throwable]): scala.reflect.ClassTag[Throwable])).get
[warn]           List(classOf[String] → protoT.getMessage)).get
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\WrappedPayloadSupport.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   input.asInstanceOf[AnyRef]
[warn]     val payload = input.asInstanceOf[AnyRef]
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\WrappedPayloadSupport.scala:41: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserializePayload(payload: akka.remote.ContainerFormats.Payload): Any = {

[warn]   val manifest: String = if (payload.hasMessageManifest())

[warn]     payload.getMessageManifest().toStringUtf8()

[warn]   else

[warn]     "";

[warn]   WrappedPayloadSupport.this.serialization.deserialize(payload.getEnclosedMessage().toByteArra
[warn]   def deserializePayload(payload: ContainerFormats.Payload): Any = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\serialization\WrappedPayloadSupport.scala:46: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   WrappedPayloadSupport.this.serialization.deserialize(payload.getEnclosedMessage().toByteArray(), payload.getSerializerId(), manifest).get
[warn]       manifest).get
[warn]                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AbstractTransportAdapter.scala:42: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.remote.transport.TransportAdapters = TransportAdaptersExtension.super.get(system)
[info]   override def get(system: ActorSystem): TransportAdapters = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AbstractTransportAdapter.scala:32: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   TransportAdapters.this.system.dynamicAccess.createInstanceFor[akka.remote.transport.TransportAdapterProvider](fqn, scala.collection.immutable.Seq.empty[Nothing])((ClassTag.apply[akka.remote.transport.TransportAdapterProvider](classOf[akka.remote.transport.TransportAdapterProvider]): scala.reflect.ClassTag[akka.remote.transport.TransportAdapterProvider])).recover[akka.remote.transport.TransportAdapterProvider](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runti
[warn]     }).get
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AbstractTransportAdapter.scala:175: [scapegoat] Var in closure
[warn]   Closing over a var can lead to subtle bugs.
[warn]   akka.remote.transport.Transport.ActorAssociationEventListener.apply(ActorTransportAdapter.this.manager)
[warn]       ActorAssociationEventListener(manager)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaPduCodec.scala:177: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new PduCodecException("Error decoding Akka PDU: Neither message nor control message were contained", null)
[warn]       else throw new PduCodecException("Error decoding Akka PDU: Neither message nor control message were contained", null)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaPduCodec.scala:226: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new PduCodecException(scala.StringContext.apply("Decoding of control PDU failed, invalid format, unexpected: [", "]").s(x), null)
[warn]         throw new PduCodecException(s"Decoding of control PDU failed, invalid format, unexpected: [${x}]", null)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaPduCodec.scala:47: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Message.this.seqOption.get
[warn]     override def seq: SeqNo = seqOption.get
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaProtocolTransport.scala:421: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Association attempt with mismatching cookie from [{}]. Expected [{}] but received [{}].").s()
[warn]                 s"Association attempt with mismatching cookie from [{}]. Expected [{}] but received [{}].",
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaProtocolTransport.scala:424: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Association attempt with mismatching cookie from [{}].").s()
[warn]               log.warning(s"Association attempt with mismatching cookie from [{}].", info.origin)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaProtocolTransport.scala:510: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("No response from remote. ").s()
[warn]       stop(FSM.Failure(TimeoutReason(s"No response from remote. " +
[warn]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaProtocolTransport.scala:257: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TimeoutReason(errorMessage: String)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\AkkaProtocolTransport.scala:29: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   AkkaProtocolException.this.<init>(msg, null)
[warn]   def this(msg: String) = this(msg, null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\FailureInjectorTransportAdapter.scala:151: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   @volatile private var upstreamListener: HandleEventListener = null
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\FailureInjectorTransportAdapter.scala:137: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   mode.eq(null)
[warn]     if (mode eq null) PassThru else mode
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\TestTransport.scala:32: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   def this(system: ExtendedActorSystem, conf: Config) = {
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\ThrottlerTransportAdapter.scala:300: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   target.asInstanceOf[akka.actor.InternalActorRef]
[warn]       val internalTarget = target.asInstanceOf[InternalActorRef]
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\ThrottlerTransportAdapter.scala:493: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (ThrottledAssociation.this.inboundThrottleMode.==(akka.remote.transport.ThrottlerTransportAdapter.Blackhole))

[warn]   ()

[warn] else

[warn]   if (ThrottledAssociation.this.throttledMessages.isEmpty)

[warn]     {

[warn]       val tokens: Int = payload.length;

[warn]       <synthetic> <artifact> private[this] val x$5: (akka.remote.transport.ThrottlerTransportAdapter.ThrottleMode, Boolean) = (ThrottledAssociation.this.inboundThrottleMode.tryConsumeTokens(java.this.lang.System.nanoTime(), tokens): (akka.remote.transport.ThrottlerT
[warn]     if (inboundThrottleMode == Blackhole) {
[warn]     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\ThrottlerTransportAdapter.scala:213: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.actor.Address, (akka.remote.transport.ThrottlerTransportAdapter.ThrottleMode, akka.remote.transport.ThrottlerTransportAdapter.Direction)]()
[info]   private var throttlingModes = Map[Address, (ThrottleMode, Direction)]()
[info]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\Transport.scala:23: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   final case class InvalidAssociationException(msg: String, cause: Throwable = null) extends AkkaException(msg, cause) with NoStackTrace
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyHelpers.scala:27: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ev.getCause().ne(null)
[warn]     val cause = if (ev.getCause ne null) ev.getCause else new AkkaException("Unknown cause")
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettySSLSupport.scala:96: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val settings: akka.remote.transport.netty.SSLSettings = _
[warn]     def constructClientContext(settings: SSLSettings, log: LoggingAdapter, trustStorePath: String, trustStorePassword: String, protocol: String): Option[SSLContext] =
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettySSLSupport.scala:96: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val log: akka.event.LoggingAdapter = _
[warn]     def constructClientContext(settings: SSLSettings, log: LoggingAdapter, trustStorePath: String, trustStorePassword: String, protocol: String): Option[SSLContext] =
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettySSLSupport.scala:146: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val settings: akka.remote.transport.netty.SSLSettings = _
[warn]     def constructServerContext(settings: SSLSettings, log: LoggingAdapter, keyStorePath: String, keyStorePassword: String, keyPassword: String, protocol: String): Option[SSLContext] =
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettySSLSupport.scala:146: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val log: akka.event.LoggingAdapter = _
[warn]     def constructServerContext(settings: SSLSettings, log: LoggingAdapter, keyStorePath: String, keyStorePassword: String, keyPassword: String, protocol: String): Option[SSLContext] =
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:184: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   remoteSocketAddress.asInstanceOf[java.net.InetSocketAddress]
[warn]             registerListener(channel, listener, msg, remoteSocketAddress.asInstanceOf[InetSocketAddress])
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:114: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Setting \'maximum-frame-size\' must be at least 32000 bytes").s()
[warn]     s"Setting 'maximum-frame-size' must be at least 32000 bytes")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:73: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   @SerialVersionUID(value = 1L) class NettyTransportExceptionNoStack extends NettyTransportException with scala.util.control.NoStackTrace {

[warn]   <paramaccessor> private[this] val msg: String = _;

[warn]   <paramaccessor> private[this] val cause: Throwable = _;

[warn]   def <init>(msg: String, cause: Throwable): akka.remote.transport.netty.NettyTransportExceptionNoStack = {

[warn]     NettyTransportExceptionNoStack.super.<init>(msg, cause);

[warn]     ()

[warn]   };

[warn]   def <init>(msg: String): akka.remote.transport.netty.NettyTra
[warn] class NettyTransportExceptionNoStack(msg: String, cause: Throwable) extends NettyTransportException(msg, cause) with NoStackTrace {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:69: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   NettyTransportException.this.<init>(msg, null)
[warn]   def this(msg: String) = this(msg, null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:74: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   NettyTransportExceptionNoStack.this.<init>(msg, null)
[warn]   def this(msg: String) = this(msg, null)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:344: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   NettyTransport.this.settings.SslSettings.get
[warn]     val handler = NettySSLSupport(settings.SslSettings.get, log, isClient)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:378: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   NettyTransport.this.settings.ReceiveBufferSize.get
[warn]     if (isDatagram) bootstrap.setOption("receiveBufferSizePredictorFactory", new FixedReceiveBufferSizePredictorFactory(ReceiveBufferSize.get))
[warn]                                                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:152: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val config: com.typesafe.config.Config = _
[warn]   private def computeWPS(config: Config): Int =
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\NettyTransport.scala:241: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: org.jboss.netty.channel.Channel = _
[warn]       _ ← always { channel.disconnect() }
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\TcpSupport.scala:44: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.getMessage().asInstanceOf[org.jboss.netty.buffer.ChannelBuffer]
[warn]     val bytes: Array[Byte] = e.getMessage.asInstanceOf[ChannelBuffer].array()
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\TcpSupport.scala:61: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TcpServerHandler.this.initInbound(e.getChannel(), e.getChannel().getRemoteAddress(), null)
[warn]     initInbound(e.getChannel, e.getChannel.getRemoteAddress, null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\TcpSupport.scala:72: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TcpClientHandler.this.initOutbound(e.getChannel(), e.getChannel().getRemoteAddress(), null)
[warn]     initOutbound(e.getChannel, e.getChannel.getRemoteAddress, null)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\UdpSupport.scala:41: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.getMessage().asInstanceOf[org.jboss.netty.buffer.ChannelBuffer]
[warn]         initUdp(e.getChannel, e.getRemoteAddress, e.getMessage.asInstanceOf[ChannelBuffer])
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\UdpSupport.scala:44: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.getMessage().asInstanceOf[org.jboss.netty.buffer.ChannelBuffer]
[warn]         val bytes: Array[Byte] = e.getMessage.asInstanceOf[ChannelBuffer].array()
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\UdpSupport.scala:86: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   UdpAssociationHandle.this.remoteAddress.host.get
[warn]       channel.connect(new InetSocketAddress(InetAddress.getByName(remoteAddress.host.get), remoteAddress.port.get))
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\main\scala\akka\remote\transport\netty\UdpSupport.scala:86: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   UdpAssociationHandle.this.remoteAddress.port.get
[warn]       channel.connect(new InetSocketAddress(InetAddress.getByName(remoteAddress.host.get), remoteAddress.port.get))
[warn]                                                                                                               ^
[info] [warn] [scapegoat] Analysis complete: 83 files - 0 errors 336 warns 24 infos
[warn] there were 19 deprecation warnings; re-run with -deprecation for details
[warn] 315 warnings found
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-supervision-java-lambda\target\classes...
[info] Compiling 6 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:47: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.stream.impl.ErrorPublisher.apply(cause, "error").asInstanceOf[org.reactivestreams.Publisher[T]]
[warn]   def error[T](cause: Throwable): Publisher[T] = ErrorPublisher(cause, "error").asInstanceOf[Publisher[T]]
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:78: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[ManualProbe.this.Self]
[warn]     private val self = this.asInstanceOf[Self]
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:93: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ManualProbe.this.probe.expectMsgType[akka.stream.testkit.TestPublisher.Subscribe]((ClassTag.apply[akka.stream.testkit.TestPublisher.Subscribe](classOf[akka.stream.testkit.TestPublisher$$Subscribe]): scala.reflect.ClassTag[akka.stream.testkit.TestPublisher.Subscribe])).subscription.asInstanceOf[akka.stream.testkit.StreamTestKit.PublisherProbeSubscription[I]]
[warn]       probe.expectMsgType[Subscribe].subscription.asInstanceOf[PublisherProbeSubscription[I]]
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:123: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[PartialFunction[AnyRef,T]]
[warn]       probe.receiveWhile(max, idle, messages)(f.asInstanceOf[PartialFunction[AnyRef, T]])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:126: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[PartialFunction[Any,T]]
[warn]       probe.expectMsgPF[T]()(f.asInstanceOf[PartialFunction[Any, T]])
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:223: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[ManualProbe.this.Self]
[warn]     private val self = this.asInstanceOf[Self]
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:269: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[I]
[warn]         case OnNext(elem) ? elem.asInstanceOf[I]
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:540: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[PartialFunction[Any,T]]
[warn]       probe.expectMsgPF[T]()(f.asInstanceOf[PartialFunction[Any, T]])
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:546: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[PartialFunction[AnyRef,T]]
[warn]       probe.receiveWhile(max, idle, messages)(f.asInstanceOf[PartialFunction[AnyRef, T]])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:553: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   i.asInstanceOf[I]
[warn]         case OnNext(i) ? Some(i.asInstanceOf[I])
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:462: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("OnNext(_) or error").s()
[warn]       probe.fishForMessage(hint = s"OnNext(_) or error") {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:489: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("OnNext(_) or OnComplete").s()
[warn]       probe.fishForMessage(hint = s"OnNext(_) or OnComplete") {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:578: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ManualProbe.this._subscription.==(null)
[warn]       if (_subscription == null) self.expectSubscription()
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:339: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val all: scala.collection.immutable.Seq[I] = _
[warn]       @annotation.tailrec def expectOneOf(all: immutable.Seq[I]): Unit = all match {
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:686: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SourceShape[T] = _
[warn]     override protected def newInstance(shape: SourceShape[T]): SourceModule[T, TestPublisher.Probe[T]] = new ProbeSource[T](attributes, shape)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\StreamTestKit.scala:695: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[T] = _
[warn]     override protected def newInstance(shape: SinkShape[T]): SinkModule[T, TestSubscriber.Probe[T]] = new ProbeSink[T](attributes, shape)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\TestGraphStage.scala:36: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   logic.handlers.apply(TestSinkStage.this.in.id).asInstanceOf[akka.stream.stage.InHandler]
[warn]     val inHandler = logic.handlers(in.id).asInstanceOf[InHandler]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\TestGraphStage.scala:73: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   logic.handlers.apply(TestSourceStage.this.out.id).asInstanceOf[akka.stream.stage.OutHandler]
[warn]     val outHandler = logic.handlers(out.id).asInstanceOf[OutHandler]
[warn]                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\main\scala\akka\stream\testkit\TestGraphStage.scala:12: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Failure(ex: Throwable) extends NoSerializationVerificationNeeded
[info]              ^
[info] [warn] [scapegoat] Analysis complete: 6 files - 0 errors 18 warns 1 infos
[warn] 18 warnings found
[info] Compiling 31 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorContext.scala:196: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   StubbedActorContext.this._children.apply(child.path.name).asInstanceOf[akka.typed.Inbox[U]]
[warn]     val inbox = _children(child.path.name).asInstanceOf[Inbox[U]]
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorContext.scala:149: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   override def child(name: String): Option[ActorRef[Nothing]] = _children get name map (_.ref)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorContext.scala:155: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   override def spawn[U](behavior: Behavior[U], name: String, deployment: DeploymentConfig = EmptyDeploymentConfig): ActorRef[U] =
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorContext.scala:196: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val inbox: akka.typed.Inbox[U] = StubbedActorContext.this._children.apply(child.path.name).asInstanceOf[akka.typed.Inbox[U]]
[warn]     val inbox = _children(child.path.name).asInstanceOf[Inbox[U]]
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorRef.scala:38: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[akka.typed.ActorRef[U]]
[warn]   def upcast[U >: T @uncheckedVariance]: ActorRef[U] = this.asInstanceOf[ActorRef[U]]
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorSystem.scala:182: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   untyped.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]   def wrap(untyped: a.ActorSystem): ActorSystem[Nothing] = new ActorSystemAdapter(untyped.asInstanceOf[a.ActorSystemImpl])
[warn]                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorSystem.scala:193: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val config: com.typesafe.config.Config = _config.withFallback(com.typesafe.config.ConfigFactory.defaultReference(_cl))
[warn]     val config = _config.withFallback(ConfigFactory.defaultReference(_cl))
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorSystem.scala:201: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   private def found(name: String, value: String): Unit = foundSettings ::= s"$name = $value"
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorSystem.scala:202: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   private def getS(name: String, path: String): String = {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorSystem.scala:207: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   private def getSL(name: String, path: String): List[String] = {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ActorSystem.scala:212: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   private def getI(name: String, path: String): Int = {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Ask.scala:50: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   scala.Tuple3.apply[akka.typed.ActorRef[U], scala.concurrent.Future[U], Null](adapter.ActorRefAdapter.apply[U](PromiseRef.this.untyped.provider.deadLetters), scala.concurrent.Future.failed[U](new akka.pattern.AskTimeoutException(scala.StringContext.apply("Recipient[", "] had already been terminated."
[warn]         (
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Ask.scala:54: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   scala.Tuple3.apply[akka.typed.ActorRef[U], scala.concurrent.Future[U], Null](adapter.ActorRefAdapter.apply[U](PromiseRef.this.untyped.provider.deadLetters), scala.concurrent.Future.failed[U](new java.lang.IllegalArgumentException(scala.StringContext.apply("Timeout length must be positive, question n
[warn]         (
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Ask.scala:67: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   p.promiseRef.ne(null)
[warn]     if (p.promiseRef ne null) p.promiseRef.messageClassName = m.getClass.getName
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Behavior.scala:55: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.asInstanceOf[akka.typed.Behavior[U]]
[warn]   def narrow[U <: T]: Behavior[U] = this.asInstanceOf[Behavior[U]]
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Behavior.scala:129: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   current.asInstanceOf[akka.typed.Behavior[T]]
[warn]       case `sameBehavior`      ? current
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Behavior.scala:130: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   current.asInstanceOf[akka.typed.Behavior[T]]
[warn]       case `unhandledBehavior` ? current
[warn]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Deployment.scala:148: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] sealed case class DispatcherDefault(next: DeploymentConfig) extends DispatcherSelector {
[info]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Deployment.scala:148: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed case class DispatcherDefault(next: DeploymentConfig) extends DispatcherSelector {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Deployment.scala:124: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val next: akka.typed.DeploymentConfig = _
[warn]   override def withNext(next: DeploymentConfig): DeploymentConfig = copy(next = next)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Deployment.scala:149: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val next: akka.typed.DeploymentConfig = _
[warn]   override def withNext(next: DeploymentConfig): DeploymentConfig = copy(next = next)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Deployment.scala:166: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val next: akka.typed.DeploymentConfig = _
[warn]   override def withNext(next: DeploymentConfig): DeploymentConfig = copy(next = next)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Deployment.scala:175: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val next: akka.typed.DeploymentConfig = _
[warn]   override def withNext(next: DeploymentConfig): DeploymentConfig = copy(next = next)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Deployment.scala:184: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val next: akka.typed.DeploymentConfig = _
[warn]   override def withNext(next: DeploymentConfig): DeploymentConfig = copy(next = next)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Effects.scala:50: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EffectfulActorContext.this.effectQueue.peek().!=(null)
[warn]   def hasEffects: Boolean = effectQueue.peek() != null
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\EventStream.scala:79: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   f.apply(event)

[warn] } catch {

[warn]   case (e @ (_: Exception)) => false

[warn] }
[warn]             def filter(event: LogEvent): Boolean = filters exists (f ? try { f(event) } catch { case e: Exception ? false })
[warn]                                                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\EventStream.scala:64: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Initialize(eventStream: EventStream, replyTo: ActorRef[ActorRef[LogEvent]]) extends Command
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\EventStream.scala:107: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn] class DefaultLoggingFilter(settings: Settings, eventStream: EventStream) extends e.DefaultLoggingFilter(() ? eventStream.logLevel)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\Inbox.scala:38: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   Inbox.this.q.peek().!=(null)
[warn]   def hasMessages: Boolean = q.peek() != null
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\MessageAndSignals.scala:69: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Terminated.this.failed.ne(null)
[warn]   def wasFailed: Boolean = failed ne null
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:52: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ctx.asInstanceOf[akka.typed.ActorContext[T]]
[warn]       postProcess(ctx, behavior.management(ctx.asInstanceOf[ActorContext[T]], msg))
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ctx.asInstanceOf[akka.typed.ActorContext[T]]
[warn]         postProcess(ctx, behavior.message(ctx.asInstanceOf[ActorContext[T]], matcher(msg)))
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:84: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Behavior.sameBehavior.asInstanceOf[akka.typed.Behavior[T]]
[warn]   def Same[T]: Behavior[T] = sameBehavior.asInstanceOf[Behavior[T]]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:92: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Behavior.unhandledBehavior.asInstanceOf[akka.typed.Behavior[T]]
[warn]   def Unhandled[T]: Behavior[T] = unhandledBehavior.asInstanceOf[Behavior[T]]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:107: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Behavior.stoppedBehavior.asInstanceOf[akka.typed.Behavior[T]]
[warn]   def Stopped[T]: Behavior[T] = stoppedBehavior.asInstanceOf[Behavior[T]]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:112: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Behavior.emptyBehavior.asInstanceOf[akka.typed.Behavior[T]]
[warn]   def Empty[T]: Behavior[T] = emptyBehavior.asInstanceOf[Behavior[T]]
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:117: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Behavior.ignoreBehavior.asInstanceOf[akka.typed.Behavior[T]]
[warn]   def Ignore[T]: Behavior[T] = ignoreBehavior.asInstanceOf[Behavior[T]]
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:454: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ScalaDSL.this._unhandledFunction.asInstanceOf[T => akka.typed.Behavior[U]]
[warn]   private[akka] def unhandledFunction[T, U] = _unhandledFunction.asInstanceOf[(T ? Behavior[U])]
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:463: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ScalaDSL.this._unhandledFunction.asInstanceOf[T => akka.typed.Behavior[U]]
[warn]   private[akka] def unitFunction[T, U] = _unhandledFunction.asInstanceOf[(T ? Behavior[U])]
[warn]                                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:84: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Same[T]: Behavior[T] = sameBehavior.asInstanceOf[Behavior[T]]
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:92: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Unhandled[T]: Behavior[T] = unhandledBehavior.asInstanceOf[Behavior[T]]
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:107: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Stopped[T]: Behavior[T] = stoppedBehavior.asInstanceOf[Behavior[T]]
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:112: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Empty[T]: Behavior[T] = emptyBehavior.asInstanceOf[Behavior[T]]
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:117: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Ignore[T]: Behavior[T] = ignoreBehavior.asInstanceOf[Behavior[T]]
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:421: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def SelfAware[T](behavior: ActorRef[T] ? Behavior[T]): Behavior[T] =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:441: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def ContextAware[T](behavior: ActorContext[T] ? Behavior[T]): Behavior[T] =
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:44: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val ctx: akka.typed.ActorContext[U] = _).
[warn]     private def postProcess(ctx: ActorContext[U], behv: Behavior[T]): Behavior[U] =
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\ScalaDSL.scala:276: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val ctx: akka.typed.ActorContext[T] = _).
[warn]       private def setBehavior(ctx: ActorContext[T], b: Behavior[T]): Unit =
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorAdapter.scala:49: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorAdapter.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]       if (context.asInstanceOf[a.ActorCell].isWatching(ref)) failures = failures.updated(ref, ex)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorAdapter.scala:27: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Terminated.apply(ActorRefAdapter.apply[Any](ref))(null)
[warn]         } else Terminated(ActorRefAdapter(ref))(null)
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorContextAdapter.scala:28: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorContextAdapter.this.ctx.asInstanceOf[akka.actor.ActorCell]
[warn]         val cell = ctx.asInstanceOf[akka.actor.ActorCell]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorContextAdapter.scala:41: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]   var receiveTimeoutMsg: T = null.asInstanceOf[T]
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorContextAdapter.scala:47: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]     receiveTimeoutMsg = null.asInstanceOf[T]
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorContextAdapter.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorContextAdapter.this.ctx.asInstanceOf[akka.actor.ActorCell]
[warn]     val cell = ctx.asInstanceOf[akka.actor.ActorCell]
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorContextAdapter.scala:57: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.asInstanceOf[U]
[warn]     val ref = cell.addFunctionRef((_, msg) ? ctx.self ! f(msg.asInstanceOf[U]))
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorRefAdapter.scala:18: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   untyped.asInstanceOf[akka.actor.InternalActorRef]
[warn]   def apply[T](untyped: a.ActorRef): ActorRef[T] = new ActorRefAdapter(untyped.asInstanceOf[a.InternalActorRef])
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\ActorSystemAdapter.scala:70: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   untyped.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]   def apply(untyped: a.ActorSystem): ActorSystem[Nothing] = new ActorSystemAdapter(untyped.asInstanceOf[a.ActorSystemImpl])
[warn]                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\EventStreamAdapter.scala:12: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   event.asInstanceOf[AnyRef]
[warn]   def publish[T](event: T): Unit = untyped.publish(event.asInstanceOf[AnyRef])
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\PropsAdapter.scala:19: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   initial.asInstanceOf[akka.typed.Behavior[T]]
[warn]         initial.asInstanceOf[Behavior[T]]
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\adapter\PropsAdapter.scala:12: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val deploy: akka.typed.DeploymentConfig = _).
[warn]   def apply(b: Behavior[_], deploy: DeploymentConfig): a.Props = new a.Props(a.Deploy(), classOf[ActorAdapter[_]], (b: AnyRef) :: Nil)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:275: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   ActorCell.this.unscheduleReceiveTimeout();

[warn]   if (ActorCell.isTerminated(status).unary_!)

[warn]     while$1(){

[warn]       if (ActorCell.this.processAllSystemMessages().&&(ActorCell.this.queue.isEmpty().unary_!).&&(processed.<(msgs)))

[warn]         {

[warn]           {

[warn]             val msg: T = ActorCell.this.q
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:381: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   ActorCell.this.processSignal(msg)

[warn] } catch {

[warn]   case (ie @ (_: InterruptedException)) => {

[warn]     ActorCell.this.fail(ie);

[warn]     if (false)

[warn]       scala.this.Predef.println(scala.StringContext.apply("[", "] ", " interrupting due to catching InterruptedException during system message processing
[warn]         try processSignal(msg)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:412: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   typed.this.`package`.ToImpl[Any](dlm).sorry.sendSystem(msg)

[warn] } catch {

[warn]   case (e @ (_: InterruptedException)) => interruption = e

[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((e @ _)) => ActorCell.this.system.eventStream.publish[akka.event.Logging.Error](akka.
[warn]       try dlm.sorry.sendSystem(msg)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:194: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   val old: Int = akka.util.Unsafe.instance.getAndAddInt(this, ActorCell.statusOffset, 1);

[warn]   val oldActivations: Int = ActorCell.activations(old);

[warn]   if (oldActivations.>(ActorCell.this.maxQueue))

[warn]     {

[warn]       if (false)

[warn]         scala.this.Predef.println(scala.StringContext.apply("[", "] ",
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:233: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   if (needToActivate())

[warn]     {

[warn]       val old: Int = akka.util.Unsafe.instance.getAndAddInt(this, ActorCell.statusOffset, 1);

[warn]       if (ActorCell.isTerminated(old))

[warn]         {

[warn]           if (false)

[warn]             scala.this.Predef.println(scala.StringContext.apply("[", "] ", " NOT enqueueing "
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:160: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", " setting receive timeout of ", ", msg ", "").s(ActorCell.this.self, d, msg))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$self setting receive timeout of $d, msg $msg")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:164: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("", " canceling receive timeout").s(ActorCell.this.self))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"$self canceling receive timeout")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:271: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("[", "] ", " entering run(): interrupted=", "").s(ActorCell.this.thread, ActorCell.this.self, java.this.lang.Thread.currentThread().isInterrupted()))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"[$thread] $self entering run(): interrupted=${Thread.currentThread.isInterrupted}")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:289: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("[", "] ", " interrupting due to catching InterruptedException").s(ActorCell.this.thread, ActorCell.this.self))

[warn] else

[warn]   ()
[warn]         if (Debug) println(s"[$thread] $self interrupting due to catching InterruptedException")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:317: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("[", "] ", " exiting run(): interrupted=", "").s(ActorCell.this.thread, ActorCell.this.self, java.this.lang.Thread.currentThread().isInterrupted()))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"[$thread] $self exiting run(): interrupted=${Thread.currentThread.isInterrupted}")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:351: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("[", "] ", " processing message ", "").s(ActorCell.this.thread, ActorCell.this.self, msg))

[warn] else

[warn]   ()
[warn]     if (Debug) println(s"[$thread] $self processing message $msg")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:296: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (ActorCell.isTerminated(now))

[warn]   ()

[warn] else

[warn]   if (ActorCell.activations(now).>(0))

[warn]     {

[warn]       akka.util.Unsafe.instance.getAndAddInt(this, ActorCell.statusOffset, 1);

[warn]       ActorCell.this.executionContext.execute(this)

[warn]     }

[warn]   else

[warn]     if (ActorCell.this._systemQueue.head.!=(null))

[warn]       {

[warn]         val again: Int = akka.util.Unsafe.instance.getAndAddInt(this, ActorCell.statusOffset, 1);

[warn]         if (ActorCell.activations(again).==(0))

[warn]           ActorCell.this.executionContext.execute(
[warn]       if (isTerminated(now)) {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:158: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var receiveTimeout: (FiniteDuration, T) = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:165: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     receiveTimeout = null
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:333: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var receiveTimeoutScheduled: Cancellable = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:337: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       receiveTimeoutScheduled = null
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:373: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var interruption: Throwable = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:303: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorCell.this._systemQueue.head.!=(null)
[warn]       } else if (_systemQueue.head != null) {
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:335: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ActorCell.this.receiveTimeoutScheduled.ne(null)
[warn]     if (receiveTimeoutScheduled ne null) {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:421: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   interruption.ne(null)
[warn]     if (interruption ne null) {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:432: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   o.eq(null)
[warn]   protected final def clazz(o: AnyRef): Class[_] = if (o eq null) this.getClass else o.getClass
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorCell.scala:430: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]   protected final def publish(e: Logging.LogEvent): Unit = try system.eventStream.publish(e) catch { case NonFatal(_) ? }
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:100: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.util.Unsafe.instance.getAndSetObject(this, WatchableRef.watchedByOffset, null).asInstanceOf[WatchableRef.this.S]
[warn]     val watchedBy = unsafe.getAndSetObject(this, watchedByOffset, null).asInstanceOf[S]
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:193: [scapegoat] Looks like interpolated String
[warn]   Did you forget to prefix this string with an s, f or raw to interpolate it?
[warn]   val targetOffset = unsafe.objectFieldOffset(classOf[FutureRef[_]].getDeclaredField("akka$typed$internal$FutureRef$$_target"))
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:97: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   WatchableRef.this._watchedBy.!=(null)
[warn]   protected def isAlive: Boolean = _watchedBy != null
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:100: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   akka.util.Unsafe.instance.getAndSetObject(this, WatchableRef.watchedByOffset, null)
[warn]     val watchedBy = unsafe.getAndSetObject(this, watchedByOffset, null).asInstanceOf[S]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:101: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   watchedBy.!=(null)
[warn]     if (watchedBy != null) {
[warn]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:47: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def isLocal: Boolean = true
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:64: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((ex @ _)) => ()
[warn]         case NonFatal(ex) ? // nothing we can do here
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorRefImpl.scala:102: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> ((ex @ _)) => ()
[warn]       try terminate() catch { case NonFatal(ex) ? }
[warn]                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorSystemImpl.scala:29: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class CreateSystemActor[T](behavior: Behavior[T], name: String, deployment: DeploymentConfig)(val replyTo: ActorRef[ActorRef[T]]) extends SystemCommand
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorSystemImpl.scala:160: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   eventStreamStub.super.<init>(null, false)
[warn]   private object eventStreamStub extends e.EventStream(null, false) {
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorSystemImpl.scala:131: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ActorSystemImpl.this.dynamicAccess.createInstanceFor[akka.event.LoggingFilter](ActorSystemImpl.this.settings.LoggingFilter, arguments)((ClassTag.apply[akka.event.LoggingFilter](classOf[akka.event.LoggingFilter]): scala.reflect.ClassTag[akka.event.LoggingFilter])).get
[warn]     dynamicAccess.createInstanceFor[e.LoggingFilter](settings.LoggingFilter, arguments).get
[warn]                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorSystemImpl.scala:149: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ActorSystemImpl.this.dynamicAccess.createInstanceFor[akka.actor.Scheduler](ActorSystemImpl.this.settings.untyped.SchedulerClass, scala.collection.immutable.Seq.apply[(Class[_ >: java.util.concurrent.ThreadFactory with akka.event.LoggingAdapter with com.typesafe.config.Config <: Object], Object)](scala.this.Predef.ArrowAssoc[Class[com.typesafe.config.Config]](classOf[com.typesafe.config.Config]).→[com.typesafe.config.Config](ActorSystemImpl.this.settings.config), scala.this.Predef.ArrowAssoc[Clas
[warn]       classOf[ThreadFactory] → threadFactory.withName(threadFactory.name + "-scheduler"))).get
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorSystemImpl.scala:210: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   private def createTopLevel[U](behavior: Behavior[U], name: String, deployment: DeploymentConfig): ActorRefImpl[U] = {
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\ActorSystemImpl.scala:251: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val name: String = _
[warn]   def systemActorOf[U](behavior: Behavior[U], name: String, deployment: DeploymentConfig)(implicit timeout: Timeout): Future[ActorRef[U]] = {
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\DeathWatch.scala:49: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   a.!=(DeathWatch.this.self)
[warn]     if (a != self && !watching.contains(a)) {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\DeathWatch.scala:60: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   a.!=(DeathWatch.this.self)
[warn]     if (a != self && watching.contains(a)) {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\DeathWatch.scala:179: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private def maintainAddressTerminatedSubscription[U](change: ARImpl = null)(block: ? U): U = {
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\DispatchersImpl.scala:140: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DispatchersImpl.this.prerequisites.dynamicAccess.createInstanceFor[akka.typed.internal.DispatcherConfigurator](fqn, args)((ClassTag.apply[akka.typed.internal.DispatcherConfigurator](classOf[akka.typed.internal.DispatcherConfigurator]): scala.reflect.ClassTag[akka.typed.internal.DispatcherConfigurator])).recover[akka.typed.internal.DispatcherConfigurator](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Seria
[warn]         }).get
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\DispatchersImpl.scala:172: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MessageDispatcherConfigurator.this.prerequisites.dynamicAccess.createInstanceFor[akka.dispatch.ExecutorServiceConfigurator](fqcn, args)((ClassTag.apply[akka.dispatch.ExecutorServiceConfigurator](classOf[akka.dispatch.ExecutorServiceConfigurator]): scala.reflect.ClassTag[akka.dispatch.ExecutorServiceConfigurator])).recover[akka.dispatch.ExecutorServiceConfigurator](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] 
[warn]         }).get
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\DispatchersImpl.scala:18: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (log).
[warn] class DispatchersImpl(settings: Settings, log: LoggingAdapter, prerequisites: d.DispatcherPrerequisites) extends Dispatchers {
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:276: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   event.asInstanceOf[AnyRef]
[warn]     val c = event.asInstanceOf[AnyRef].getClass
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:161: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   val defaultLoggers: List[String] = system.settings.Loggers match {

[warn]     case immutable.this.Nil => {

[warn]       <synthetic> <artifact> val x$4: String = classOf[akka.event.Logging$$DefaultLogger].getName();

[warn]       immutable.this.Nil.::[String](x$4)

[warn]     }

[warn]     case (loggers @ _) => loggers

[warn]   }
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:123: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   message.==(null)
[warn]       if (message == null) throw new a.InvalidMessageException("Message must not be null")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:242: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:253: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:267: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   subscriber.eq(null)
[warn]     if (subscriber eq null) throw new IllegalArgumentException("subscriber is null")
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:192: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: Exception)) => {

[warn]   java.this.lang.System.err.println("error while starting up loggers
[warn]       case e: Exception ?
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:176: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.dynamicAccess.getClassFor[akka.typed.Logger](loggerName)((ClassTag.apply[akka.typed.Logger](classOf[akka.typed.Logger]): scala.reflect.ClassTag[akka.typed.Logger])).map[(akka.typed.ActorRef[akka.typed.Logger.Command], akka.typed.ActorRef[akka.event.Logging.LogEvent])](((x$5: Class[_ <: akka.typed.Logger]) => EventStreamImpl.this.addLogger(system, x$5, level, logName))).recover[(akka.typed.ActorRef[akka.typed.Logger.Command], akka.typed.ActorRef[akka.event.Logging.LogEvent])](({

[warn]   @Serial
[warn]             }).get
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\EventStreamImpl.scala:201: [scapegoat] Unsafe contains
[warn]   `contains()` accepts arguments af any type, which means you might be checking if your collection contains an element of an unrelated type.
[warn]   EventStreamImpl.this.loggers.contains[Object](EventStreamImpl.this.StandardOutLogger)
[warn]     if (!(loggers contains StandardOutLogger)) {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SupervisionMechanics.scala:48: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("[", "] ", " processing system message ", "").s(java.this.lang.Thread.currentThread().getName(), SupervisionMechanics.this.self, message))

[warn] else

[warn]   ()
[warn]     if (ActorCell.Debug) println(s"[${Thread.currentThread.getName}] $self processing system message $message")
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SupervisionMechanics.scala:59: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var _failed: Throwable = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SupervisionMechanics.scala:97: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       behavior = null
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SupervisionMechanics.scala:98: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       _failed = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SupervisionMechanics.scala:63: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SupervisionMechanics.this._failed.eq(null)
[warn]     if (_failed eq null) _failed = thr
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SupervisionMechanics.scala:92: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   a.ne(null)
[warn]     try if (a ne null) a.management(ctx, PostStop)
[warn]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:200: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] private[typed] final case class Create() extends SystemMessage
[info]                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:206: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] private[typed] final case class Terminate() extends SystemMessage
[info]                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:159: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   final def reverse_:::(other: LatestFirstSystemMessageList): EarliestFirstSystemMessageList = {
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:191: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def unlink(): Unit = next = null
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:16: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new LatestFirstSystemMessageList(null)
[warn]   final val LNil: LatestFirstSystemMessageList = new LatestFirstSystemMessageList(null)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:17: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new EarliestFirstSystemMessageList(null)
[warn]   final val ENil: EarliestFirstSystemMessageList = new EarliestFirstSystemMessageList(null)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:20: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   head.eq(null)
[warn]   private[internal] def sizeInner(head: SystemMessage, acc: Int): Int = if (head eq null) acc else sizeInner(head.next, acc + 1)
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:24: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   head.eq(null)
[warn]     if (head eq null) acc else {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:53: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LatestFirstSystemMessageList.this.head.eq(null)
[warn]   final def isEmpty: Boolean = head eq null
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:58: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LatestFirstSystemMessageList.this.head.ne(null)
[warn]   final def nonEmpty: Boolean = head ne null
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:114: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EarliestFirstSystemMessageList.this.head.eq(null)
[warn]   final def isEmpty: Boolean = head eq null
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:119: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   EarliestFirstSystemMessageList.this.head.ne(null)
[warn]   final def nonEmpty: Boolean = head ne null
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:193: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SystemMessage.this.next.eq(null)
[warn]   def unlinked: Boolean = next eq null
[warn]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:53: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def isEmpty: Boolean = head eq null
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:58: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def nonEmpty: Boolean = head ne null
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:63: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def size: Int = sizeInner(head, 0)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:72: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tail: LatestFirstSystemMessageList = new LatestFirstSystemMessageList(head.next)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:80: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def reverse: EarliestFirstSystemMessageList = new EarliestFirstSystemMessageList(reverseInner(head, null))
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:85: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def ::(msg: SystemMessage): LatestFirstSystemMessageList = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:114: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def isEmpty: Boolean = head eq null
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:119: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def nonEmpty: Boolean = head ne null
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:124: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def size: Int = sizeInner(head, 0)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:133: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def tail: EarliestFirstSystemMessageList = new EarliestFirstSystemMessageList(head.next)
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:141: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def reverse: LatestFirstSystemMessageList = new LatestFirstSystemMessageList(reverseInner(head, null))
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:146: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def ::(msg: SystemMessage): EarliestFirstSystemMessageList = {
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\internal\SystemMessage.scala:159: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final def reverse_:::(other: LatestFirstSystemMessageList): EarliestFirstSystemMessageList = {
[info]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\package.scala:10: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ToImpl.this.ref.asInstanceOf[akka.typed.internal.ActorRefImpl[U]]
[warn]     def sorry: ActorRefImpl[U] = ref.asInstanceOf[ActorRefImpl[U]]
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\package.scala:14: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ToImplNothing.this.ref.asInstanceOf[akka.typed.internal.ActorRefImpl[Nothing]]
[warn]     def sorryForNothing: ActorRefImpl[Nothing] = ref.asInstanceOf[ActorRefImpl[Nothing]]
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\patterns\Receiver.scala:50: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   c.asInstanceOf[akka.typed.patterns.Receiver.InternalCommand[T]]
[warn]           empty(ctx).widen { case c: InternalCommand[t] ? c.asInstanceOf[InternalCommand[T]] },
[warn]                                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\patterns\Receiver.scala:21: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ReceiveTimeout[T]() extends InternalCommand[T]
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\patterns\Receiver.scala:89: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class Asked[T](replyTo: ActorRef[GetOneResult[T]], deadline: Deadline)
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-typed\src\main\scala\akka\typed\patterns\Restarter.scala:23: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]     try current.management(ctx, PreRestart) catch { case NonFatal(_) ? }
[warn]                                                          ^
[info] [warn] [scapegoat] Analysis complete: 31 files - 0 errors 123 warns 29 infos
[warn] 120 warnings found
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-fsm-java-lambda\target\classes...
[info] Compiling 19 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\Camel.scala:141: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.camel.Camel = CamelExtension.super.get(system)
[info]   override def get(system: ActorSystem): Camel = super.get(system)
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\Camel.scala:96: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[String, Class[_ <: AnyRef]]()
[info]     val conversions = (Map[String, Class[_ <: AnyRef]]() /: specifiedConversions) {
[info]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\Camel.scala:100: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CamelSettings.this.dynamicAccess.getClassFor[AnyRef](fqcn)((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])).recover[Class[_ <: AnyRef]](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => Nothing> = {

[warn]       $anonfun.super.<init>();

[warn]       ()

[warn]     };

[warn]     final override def applyOrElse[A1 <: Throwable, B1](x1: A1, default: A1 => B1): B1 = ((x1.asInstanceO
[warn]         }.get)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\Camel.scala:112: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CamelSettings.this.dynamicAccess.createInstanceFor[akka.camel.ContextProvider](fqcn, scala.collection.immutable.Seq.empty[Nothing])((ClassTag.apply[akka.camel.ContextProvider](classOf[akka.camel.ContextProvider]): scala.reflect.ClassTag[akka.camel.ContextProvider])).recover[akka.camel.ContextProvider](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => Noth
[warn]     }.get
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:63: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   t.runtimeClass.asInstanceOf[Class[T]]
[warn]     Try(headers.get(name).map(camelContext.getTypeConverter.mandatoryConvertTo[T](t.runtimeClass.asInstanceOf[Class[T]], _)).getOrElse(throw new NoSuchElementException(name)))
[warn]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:78: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CamelMessage.this.body.asInstanceOf[A]
[warn]   def mapBody[A, B](transformer: A ? B): CamelMessage = copy(body = transformer(body.asInstanceOf[A]))
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:84: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CamelMessage.this.body.asInstanceOf[A]
[warn]   def mapBody[A, B](transformer: Mapper[A, B]): CamelMessage = copy(body = transformer(body.asInstanceOf[A]))
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:92: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   t.runtimeClass.asInstanceOf[Class[T]]
[warn]   def bodyAs[T](implicit t: ClassTag[T], camelContext: CamelContext): T = getBodyAs(t.runtimeClass.asInstanceOf[Class[T]], camelContext)
[warn]                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:127: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   t.runtimeClass.asInstanceOf[Class[T]]
[warn]   def withBodyAs[T](implicit t: ClassTag[T], camelContext: CamelContext): CamelMessage = withBodyAs(t.runtimeClass.asInstanceOf[Class[T]])
[warn]                                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:271: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value.asInstanceOf[AnyRef]
[warn]     for ((name, value) ← from.headers) to.getHeaders.put(name, value.asInstanceOf[AnyRef])
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:14: [scapegoat] Java conversions
[warn]   Use of Java conversions can lead to unusual behaviour. It is recommended to use JavaConverters.
[warn] import scala.collection.JavaConversions._
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:72: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CamelMessage.this.headerAs[T](name)(scala.reflect.ClassTag.apply[T](clazz), camelContext).get
[warn]   def getHeaderAs[T](name: String, clazz: Class[T], camelContext: CamelContext): T = headerAs[T](name)(ClassTag(clazz), camelContext).get
[warn]                                                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:25: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val body: Any = this.body
[warn]   def copy(body: Any = this.body, headers: Map[String, Any] = this.headers): CamelMessage = CamelMessage(body, headers, this.attachments)
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:25: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: Map[String,Any] = this.headers
[warn]   def copy(body: Any = this.body, headers: Map[String, Any] = this.headers): CamelMessage = CamelMessage(body, headers, this.attachments)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:51: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val headers: java.util.Map[String,A] = _
[warn]   def withHeaders[A](headers: JMap[String, A]): CamelMessage = copy(this.body, headers.toMap)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:121: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val body: T = _
[warn]   def withBody[T](body: T): CamelMessage = copy(body = body)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:159: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val attachments: java.util.Map[String,javax.activation.DataHandler] = _
[warn]   def withAttachments(attachments: JMap[String, DataHandler]): CamelMessage = CamelMessage(this.body, this.headers, attachments.toMap)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:164: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val attachments: Map[String,javax.activation.DataHandler] = _
[warn]   def withAttachments(attachments: Map[String, DataHandler]): CamelMessage = CamelMessage(this.body, this.headers, attachments)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\CamelMessage.scala:170: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   that match {

[warn]   case (that @ (_: akka.camel.CamelMessage)) if CamelMessage.this.canEqual(that) => this.body.==(that.body).&&(this.headers.==(that.headers)).&&(this.attachments.==(that.attachments))

[warn]  
[warn]     that match {
[warn]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\Producer.scala:128: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val endpoint: org.apache.camel.Endpoint = _
[warn]     protected def produce(endpoint: Endpoint, processor: SendProcessor, msg: Any, pattern: ExchangePattern): Unit = {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\Producer.scala:128: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val processor: org.apache.camel.processor.SendProcessor = _
[warn]     protected def produce(endpoint: Endpoint, processor: SendProcessor, msg: Any, pattern: ExchangePattern): Unit = {
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\CamelExchangeAdapter.scala:81: [scapegoat] Java conversions
[warn]   Use of Java conversions can lead to unusual behaviour. It is recommended to use JavaConverters.
[warn]     import scala.collection.JavaConversions._
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\CamelExchangeAdapter.scala:97: [scapegoat] Java conversions
[warn]   Use of Java conversions can lead to unusual behaviour. It is recommended to use JavaConverters.
[warn]     import scala.collection.JavaConversions._
[warn]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\CamelSupervisor.scala:158: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.actor.ActorRef, (org.apache.camel.Endpoint, org.apache.camel.processor.SendProcessor)]()
[info]   private var camelObjects = Map[ActorRef, (Endpoint, SendProcessor)]()
[info]                                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\CamelSupervisor.scala:96: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.actor.ActorRef]()
[info]   private var producers = Set[ActorRef]()
[info]                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\CamelSupervisor.scala:97: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.actor.ActorRef]()
[info]   private var consumers = Set[ActorRef]()
[info]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\CamelSupervisor.scala:106: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case scala.util.control.NonFatal.unapply(<unapply-selector>) <unapply> (_) => ()
[warn]           } catch { case NonFatal(_) ? }
[warn]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\component\ActorComponent.scala:201: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[camel] case class ActorEndpointPath private (actorPath: String) {
[info]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\internal\component\ActorComponent.scala:33: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn] private[camel] class ActorComponent(camel: Camel, system: ActorSystem) extends DefaultComponent {
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\javaapi\UntypedProducerActor.scala:38: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.asInstanceOf[AnyRef]
[warn]   final override def transformOutgoingMessage(msg: Any): AnyRef = onTransformOutgoingMessage(msg.asInstanceOf[AnyRef])
[warn]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\javaapi\UntypedProducerActor.scala:39: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.asInstanceOf[AnyRef]
[warn]   final override def transformResponse(msg: Any): AnyRef = onTransformResponse(msg.asInstanceOf[AnyRef])
[warn]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\javaapi\UntypedProducerActor.scala:40: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.asInstanceOf[AnyRef]
[warn]   final override def routeResponse(msg: Any): Unit = onRouteResponse(msg.asInstanceOf[AnyRef])
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\javaapi\UntypedProducerActor.scala:21: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def onTransformOutgoingMessage(message: AnyRef): AnyRef = message
[warn]   def onTransformOutgoingMessage(message: AnyRef): AnyRef = message
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-camel\src\main\scala\akka\camel\javaapi\UntypedProducerActor.scala:28: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def onTransformResponse(message: AnyRef): AnyRef = message
[warn]   def onTransformResponse(message: AnyRef): AnyRef = message
[warn]       ^
[info] [warn] [scapegoat] Analysis complete: 19 files - 0 errors 28 warns 6 infos
[warn] there were two deprecation warnings; re-run with -deprecation for details
[warn] 29 warnings found
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[warn] Multiple resolvers having different access mechanism configured with same name 'public'. To avoid conflict, Remove duplicate project resolvers (`resolvers`) or rename publishing resolver (`publishTo`).
[info] Compiling 10 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\CapabilityFlags.scala:14: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   clazz.getDeclaredMethod(el.getMethodName()).getReturnType().==(classOf[akka.persistence.CapabilityFlag])
[warn]       clazz.getDeclaredMethod(el.getMethodName).getReturnType == classOf[CapabilityFlag]
[warn]                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalPerfSpec.scala:61: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Cmd(mode: String, payload: Int)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalPerfSpec.scala:87: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   cmnds.last
[warn]     testProbe.expectMsg(awaitDuration, cmnds.last)
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalPerfSpec.scala:146: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   JournalPerfSpec.this.commands.last
[warn]         testProbe.expectMsg(max = awaitDuration, commands.last)
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalSpec.scala:221: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("b-6").s()
[warn]           case WriteMessageSuccess(PersistentImpl(payload, 6L, Pid, _, _, Actor.noSender, WriterUuid), _) ? payload should be(s"b-6")
[warn]                                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalSpec.scala:228: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("b-8").s()
[warn]           case WriteMessageSuccess(PersistentImpl(payload, 8L, Pid, _, _, Actor.noSender, WriterUuid), _) ? payload should be(s"b-8")
[warn]                                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\journal\JournalSpec.scala:67: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JournalSpec.this.extension.journalFor(null)
[warn]     extension.journalFor(null)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\scalatest\MayVerb.scala:22: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   body

[warn] } catch {

[warn]   case (cause @ (_: Throwable)) => {

[warn]     val shortTrace: Array[StackTraceElement] = scala.this.Predef.refArrayOps[StackTraceElement](cause.getStackTrace()).take(MayVerb.this.mayVerbStacktraceContextFrames);

[warn]     throw new MayVerb.TestCanceledByFailure(whenSkippedMessage, s
[warn]     try body catch {
[warn]     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\scalatest\MayVerb.scala:60: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TestCanceledByFailure(msg: String, specialStackTrace: Array[StackTraceElement]) extends TestCanceledException(Some(msg), None, 2) {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\scalatest\MayVerb.scala:60: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   case class TestCanceledByFailure extends org.scalatest.exceptions.TestCanceledException with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val msg: String = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def msg: String = TestCanceledByFailure.this.msg;

[warn]   <caseaccessor> <paramaccessor> private[this] val specialStackTrace: Array[StackTraceElement] = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def specialStackTrace: Array[StackTraceElement] = T
[warn]   case class TestCanceledByFailure(msg: String, specialStackTrace: Array[StackTraceElement]) extends TestCanceledException(Some(msg), None, 2) {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\scalatest\MayVerb.scala:23: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (cause @ (_: Throwable)) => {

[warn]   val shortTrace: Array[StackTraceElement] = scala.this.Predef.r
[warn]       case cause: Throwable ?
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\scalatest\OptionalTests.scala:19: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   test

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => throw new java.this.lang.AssertionError("Imlpementation did not pass this spec. If your journal will be (by definition) unable to abide the here tested rule, you can disable this test,".+(scala.StringContext.apply("by overriding [", "] with C
[warn]       try test catch {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\scalatest\OptionalTests.scala:20: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (ex @ (_: Exception)) => throw new java.this.lang.AssertionError("Imlpementation did not pass t
[warn]         case ex: Exception ?
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:72: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-5").s()
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(4), s"s-5")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:76: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-3").s()
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(2), s"s-3")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:78: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-3").s()
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(2), s"s-3")), 13))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:82: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-3").s()
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(2), s"s-3")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:84: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-3").s()
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(2), s"s-3")), 13))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:97: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-2").s()
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(1), s"s-2")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:113: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-4").s()
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(3), s"s-4")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:127: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-4").s()
[warn]       senderProbe.expectMsg(LoadSnapshotResult(Some(SelectedSnapshot(metadata(3), s"s-4")), Long.MaxValue))
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:131: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("s-5-modified").s()
[warn]       snapshotStore.tell(SaveSnapshot(md, s"s-5-modified"), senderProbe.ref)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:45: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SnapshotStoreSpec.this.extension.snapshotStoreFor(null)
[warn]     extension.snapshotStoreFor(null)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:136: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   result.snapshot.get
[warn]       result.snapshot.get.snapshot should be("s-5-modified")
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:137: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   result.snapshot.get
[warn]       result.snapshot.get.metadata.sequenceNr should be(md.sequenceNr)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-tck\src\main\scala\akka\persistence\snapshot\SnapshotStoreSpec.scala:49: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val metadata: akka.persistence.SnapshotMetadata = akka.persistence.SnapshotMetadata.apply(SnapshotStoreSpec.this.pid, i.+(10).toLong, akka.persistence.SnapshotMetadata.apply$default$3)
[warn]       val metadata = SnapshotMetadata(pid, i + 10)
[warn]           ^
[info] [warn] [scapegoat] Analysis complete: 10 files - 0 errors 24 warns 2 infos
[warn] 24 warnings found
[info] Compiling 4 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-scala\target\classes...
[warn] there was one deprecation warning; re-run with -deprecation for details
[warn] one warning found
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java\target\classes...
[info] 注: D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java\src\main\java\sample\persistence\PersistentViewExample.java使用或覆盖了已过时的 API。
[info] 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。
[info] Compiling 4 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java-lambda\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-persistence-java-lambda\src\main\java\sample\persistence\ViewExample.java:46:  [deprecation] akka.persistence中的AbstractPersistentView已过时
[warn]   public static class ExampleView extends AbstractPersistentView {
[warn]                                           ^
[info] Formatting 11 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-testkit(test) ...
[info] Formatting 6 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote-tests(test) ...
[info] Formatting 111 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-actor-tests(test) ...
[info] Formatting 31 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster(test) ...
[info] Formatting 145 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-stream-tests(test) ...
[info] Formatting 87 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote(test) ...
[info] Formatting 17 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-distributed-data-experimental(test) ...
[info] Formatting 28 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-persistence(test) ...
[info] Formatting 23 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-testkit(test) ...
[info] Compiling 123 Scala sources and 5 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\marshalling\Marshaller.scala:34: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m.asInstanceOf[akka.http.javadsl.marshalling.Marshaller[A,B1]]
[warn]   def downcast[A, B1, B2 <: B1](m: Marshaller[A, B2]): Marshaller[A, B1] = m.asInstanceOf[Marshaller[A, B1]]
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\marshalling\Marshaller.scala:42: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m.asInstanceOf[akka.http.javadsl.marshalling.Marshaller[A,B1]]
[warn]   def downcast[A, B1, B2 <: B1](m: Marshaller[A, B2], target: Class[B1]): Marshaller[A, B1] = m.asInstanceOf[Marshaller[A, B1]]
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\marshalling\Marshaller.scala:149: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Marshaller.this.asScala.asInstanceOf[akka.http.scaladsl.marshalling.Marshaller[A,C]]
[warn]   private[akka] def asScalaCastOutput[C]: marshalling.Marshaller[A, C] = asScala.asInstanceOf[marshalling.Marshaller[A, C]]
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\marshalling\Marshaller.scala:42: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val target: Class[B1] = _).
[warn]   def downcast[A, B1, B2 <: B1](m: Marshaller[A, B2], target: Class[B1]): Marshaller[A, B1] = m.asInstanceOf[Marshaller[A, B1]]
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\Rejections.scala:299: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   abstract trait RejectionError extends scala.`package`.RuntimeException {

[warn]   def rejection: akka.http.javadsl.server.Rejection

[warn] }
[warn] trait RejectionError extends RuntimeException {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\RoutingJavaMapping.scala:32: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     implicit def AddAsScala[J](javaObject: J)(implicit mapping: J2SMapping[J]): AsScala[mapping.S] = new AsScala[mapping.S] {
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\RoutingJavaMapping.scala:35: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     implicit def AddAsJava[S](scalaObject: S)(implicit mapping: S2JMapping[S]): AsJava[mapping.J] = new AsJava[mapping.J] {
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\BasicDirectives.scala:119: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val t: T = _
[warn]     D.provide(t) { t ? inner.apply(t).delegate }
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\CodingDirectives.scala:59: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   tail.toSeq
[warn]         D.encodeResponseWith(head._underlyingScalaCoder, tail.toSeq.map(_._underlyingScalaCoder): _*) {
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\CookieDirectives.scala:72: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   tail.map[akka.http.scaladsl.model.headers.HttpCookie, List[akka.http.scaladsl.model.headers.HttpCookie]](((x$2: akka.http.javadsl.model.headers.HttpCookie) => akka.http.impl.util.JavaMapping.Implicits
[warn]         D.deleteCookie(head.asScala, tail.map(_.asScala).toSeq: _*) {
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\FramedEntityStreamingDirectives.scala:50: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   model.this.HttpEntity.HttpEntityScalaDSLSugar(x$1).httpEntity.asInstanceOf[akka.http.scaladsl.model.RequestEntity]
[warn]     val mm = m.asScalaCastOutput[akka.http.scaladsl.model.RequestEntity].map(_.httpEntity.asInstanceOf[akka.http.scaladsl.model.RequestEntity])
[warn]                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\FutureDirectives.scala:96: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   x.getCause().ne(null)
[warn]     case x: CompletionException if x.getCause ne null ?
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\HeaderDirectives.scala:42: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   allowed.asInstanceOf[akka.http.scaladsl.model.headers.HttpOriginRange.Default]
[warn]         val default = allowed.asInstanceOf[akka.http.scaladsl.model.headers.HttpOriginRange.Default]
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\HeaderDirectives.scala:93: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   companion.apply(h.toString()).asInstanceOf[T]
[warn]               case h if h.is(companion.lowercaseName) ? companion.apply(h.toString).asInstanceOf[T]
[warn]                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\HeaderDirectives.scala:149: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.http.scaladsl.server.directives.HeaderMagnet.fromClassNormalJavaHeader[T](t).asInstanceOf[HeaderDirectives.this.ScalaHeaderMagnet]
[warn]     D.optionalHeaderValueByType(HeaderMagnet.fromClassNormalJavaHeader(t).asInstanceOf[ScalaHeaderMagnet]) { value ?
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\HeaderDirectives.scala:150: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value.asInstanceOf[Option[T]]
[warn]       val valueT = value.asInstanceOf[Option[T]] // we know this is safe because T <: HttpHeader
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\MiscDirectives.scala:97: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   tail.map[akka.http.scaladsl.model.headers.Language, List[akka.http.scaladsl.model.headers.Language]](((x$1: akka.http.javadsl.model.headers.Language) => akka.http.impl.util.JavaMapping.Implicits.AddAs
[warn]         D.selectPreferredLanguage(head.asScala, tail.map(_.asScala).toSeq: _*) { lang ? inner.apply(lang).delegate }
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\RouteDirectives.scala:69: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   uri.asInstanceOf[akka.http.impl.model.JavaUri]
[warn]       case r: Redirection ? D.redirect(uri.asInstanceOf[JavaUri].uri, r)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\RouteDirectives.scala:45: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   alternatives.map[akka.http.scaladsl.server.Route, Seq[akka.http.scaladsl.server.Route]](((x$1: akka.http.javadsl.server.Route) => x$1.delegate))(collection.this.Seq.canBuildFrom[akka.http.scaladsl.server.Route]).reduce
[warn]     alternatives.map(_.delegate).reduce(_ ~ _)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\SecurityDirectives.scala:83: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[T]
[warn]       case c ? Option(authenticator.applyOrElse(toJava(c), (_: Any) ? null.asInstanceOf[T]))
[warn]                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\SecurityDirectives.scala:257: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.compat.java8.OptionConverters.RichOptionForJava8[akka.http.javadsl.model.headers.HttpCredentials](cred.filter({

[warn]   ((x$1: Any) => c.isInstance(x$1))

[warn] }).map[akka.http.javadsl.model.headers.HttpCredentials](((x$11: akka.http.scaladsl.model.headers.HttpCredentials) => akka.http.impl.util.JavaMapping.Implicits.AddAsJava[akka.http.scaladsl.model.headers.HttpCredentials](x$11)(util.this.S2JMapping.fromScalaMapping[akka.http.scaladsl.model.headers.HttpCredentials](util.this.JavaMapping.HttpCrede
[warn]         authenticator.apply(cred.filter(c.isInstance).map(_.asJava).asJava.asInstanceOf[Optional[C]]).toScala.map(_.left.map(_.asScala)) // TODO make sure cast is safe
[warn]                                                                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\server\directives\SecurityDirectives.scala:25: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ProvidedCredentials(private val asScala: scaladsl.server.directives.Credentials.Provided) {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\unmarshalling\Unmarshaller.scala:91: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   um.asInstanceOf[akka.http.scaladsl.unmarshalling.Unmarshaller[JI,O]]
[warn]     um.asInstanceOf[unmarshalling.Unmarshaller[JI, O]] // since guarantee provided by existence of `mi`
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\unmarshalling\Unmarshaller.scala:105: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Unmarshaller.this.asScala.asInstanceOf[akka.http.scaladsl.unmarshalling.Unmarshaller[I,B]]
[warn]   private[akka] def asScalaCastInput[I]: unmarshalling.Unmarshaller[I, B] = asScala.asInstanceOf[unmarshalling.Unmarshaller[I, B]]
[warn]                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\javadsl\unmarshalling\Unmarshaller.scala:90: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val mi: akka.http.impl.util.JavaMapping[JI,SI] = _).
[warn]   private implicit def adaptInputToJava[JI, SI, O](um: unmarshalling.Unmarshaller[SI, O])(implicit mi: JavaMapping[JI, SI]): unmarshalling.Unmarshaller[JI, O] =
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\coding\Encoder.scala:53: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$2.isInstanceOf[akka.http.scaladsl.model.headers.Content-Encoding]
[warn]   private[coding] val isContentEncodingHeader: HttpHeader ? Boolean = _.isInstanceOf[`Content-Encoding`]
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\CsvEntityStreamingSupport.scala:44: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val parallelism: Int = _
[warn]   override def withParallelMarshalling(parallelism: Int, unordered: Boolean): CsvEntityStreamingSupport =
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\CsvEntityStreamingSupport.scala:44: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val unordered: Boolean = _
[warn]   override def withParallelMarshalling(parallelism: Int, unordered: Boolean): CsvEntityStreamingSupport =
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\JsonEntityStreamingSupport.scala:44: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val parallelism: Int = _
[warn]   override def withParallelMarshalling(parallelism: Int, unordered: Boolean): JsonEntityStreamingSupport =
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\JsonEntityStreamingSupport.scala:44: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val unordered: Boolean = _
[warn]   override def withParallelMarshalling(parallelism: Int, unordered: Boolean): JsonEntityStreamingSupport =
[warn]                                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\NameReceptacle.scala:10: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _symbol2NR(symbol: Symbol): NameReceptacle[String] = new NameReceptacle[String](symbol.name)
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\NameReceptacle.scala:11: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _string2NR(string: String): NameReceptacle[String] = new NameReceptacle[String](string)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\StrictForm.scala:60: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value.entity.contentType.asInstanceOf[akka.http.scaladsl.model.ContentType.NonBinary]
[warn]           val charsetName = value.entity.contentType.asInstanceOf[ContentType.NonBinary].charset.nioCharset.name
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\StrictForm.scala:83: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value.entity.contentType.asInstanceOf[akka.http.scaladsl.model.ContentType.NonBinary]
[warn]             val charsetName = value.entity.contentType.asInstanceOf[ContentType.NonBinary].charset.nioCharset.name
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\StrictForm.scala:122: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]             tryUnmarshalToMultipartForm.fast.recoverWith {
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\marshalling\ContentTypeOverrider.scala:18: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value.withContentType(newContentType).asInstanceOf[T]
[warn]       value.withContentType(newContentType).asInstanceOf[T] // can't be expressed in types
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\marshalling\ContentTypeOverrider.scala:24: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value._2.withContentType(newContentType).asInstanceOf[T]
[warn]         value._1 → value._2.withContentType(newContentType).asInstanceOf[T]
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\marshalling\Marshal.scala:28: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   x$1.head
[warn]       _.head match {
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\marshalling\PredefinedToResponseMarshallers.scala:80: [scapegoat] List append is slow
[info]   List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).
[info]               case firstMarshalling :: _ ? mappedMarshallings :+ firstMarshalling.toOpaque(HttpCharsets.`UTF-8`)
[info]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\marshalling\PredefinedToResponseMarshallers.scala:125: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   LowPriorityToResponseMarshallerImplicits.this.fromEntityStreamingSupportAndEntityMarshaller[T, M](s, m, null)
[warn]     fromEntityStreamingSupportAndEntityMarshaller(s, m, null)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\ExceptionHandler.scala:59: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   handler.ne(null)
[warn]     if (handler ne null) handler.seal(settings) else ExceptionHandler.default(settings)
[warn]                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:112: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Matched[L: Tuple](pathRest: Path, extractions: L) extends Matching[L] {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:170: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def OutIsTuple: Tuple[Out]
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:198: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]         def OutIsTuple = implicitly[Tuple[Out]]
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:206: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]         def OutIsTuple = implicitly[Tuple[Out]]
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:218: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]         def OutIsTuple = implicitly[Tuple[Out]]
[info]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:239: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _stringExtractionPair2PathMatcher[T](tuple: (String, T)): PathMatcher1[T] =
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:248: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _segmentStringToPathMatcher(segment: String): PathMatcher0 =
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:254: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _stringNameOptionReceptacle2PathMatcher(nr: NameOptionReceptacle[String]): PathMatcher0 =
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:266: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _regex2PathMatcher(regex: Regex): PathMatcher1[String] = regex.groupCount match {
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:295: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _valueMap2PathMatcher[T](valueMap: Map[String, T]): PathMatcher1[T] =
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:514: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Segments(count: Int): PathMatcher1[List[String]] = Segment.repeat(count, separator = Slash)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:523: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def Segments(min: Int, max: Int): PathMatcher1[List[String]] = Segment.repeat(min, max, separator = Slash)
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:314: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     @tailrec def split(ix: Int = 0, matcher: PathMatcher0 = null): PathMatcher0 = {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:316: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   matcher.eq(null)
[warn]       def append(m: PathMatcher0) = if (matcher eq null) m else matcher / m
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\PathMatcher.scala:297: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   valueMap.map[akka.http.scaladsl.server.PathMatcher1[T], scala.collection.immutable.Iterable[akka.http.scaladsl.server.PathMatcher1[T]]](((x0$3: (String, T)) => x0$3 match {

[warn]   case (_1: String, _2: T)(String, T)((prefix @ _), (value @ _)) => ImplicitPathMatcherConstruction.this._stringExtractionPair2PathMatcher[T](scala.Tuple2.apply[String, T](prefix, value))

[warn] }))(immutable.this.Iterable.canBuildFrom[akka.http.scaladsl.server.PathMatcher1[T]]).reduceLeft
[warn]     else valueMap.map { case (prefix, value) ? _stringExtractionPair2PathMatcher((prefix, value)) }.reduceLeft(_ | _)
[warn]                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Rejection.scala:284: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class RejectionError extends scala.`package`.RuntimeException with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val rejection: akka.http.scaladsl.server.Rejection = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def rejection: akka.http.scaladsl.server.Rejection = RejectionError.this.rejection;

[warn]   def <init>(rejection: akka.http.scaladsl.server.Rejection): akka.http.scaladsl.server.RejectionError = {

[warn]     RejectionError.super.<init>();

[warn]     ()

[warn] final case class RejectionError(rejection: Rejection) extends RuntimeException
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RejectionHandler.scala:98: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   rejection.asInstanceOf[T]
[warn]     def apply(rejection: Rejection) = rejection.asInstanceOf[T]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RejectionHandler.scala:245: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   transformations.asInstanceOf[Seq[akka.http.scaladsl.server.TransformationRejection]]
[warn]     (rest.distinct /: transformations.asInstanceOf[Seq[TransformationRejection]]) {
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val executionContext: scala.concurrent.ExecutionContextExecutor = _
[warn]   def reconfigure(executionContext: ExecutionContextExecutor, materializer: Materializer, log: LoggingAdapter, settings: RoutingSettings): RequestContext =
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.Materializer = _
[warn]   def reconfigure(executionContext: ExecutionContextExecutor, materializer: Materializer, log: LoggingAdapter, settings: RoutingSettings): RequestContext =
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val log: akka.event.LoggingAdapter = _
[warn]   def reconfigure(executionContext: ExecutionContextExecutor, materializer: Materializer, log: LoggingAdapter, settings: RoutingSettings): RequestContext =
[warn]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val settings: akka.http.scaladsl.settings.RoutingSettings = _
[warn]   def reconfigure(executionContext: ExecutionContextExecutor, materializer: Materializer, log: LoggingAdapter, settings: RoutingSettings): RequestContext =
[warn]                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:66: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val request: akka.http.scaladsl.model.HttpRequest = _
[warn]   override def withRequest(request: HttpRequest): RequestContext =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:69: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val executionContext: scala.concurrent.ExecutionContextExecutor = _
[warn]   override def withExecutionContext(executionContext: ExecutionContextExecutor): RequestContext =
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:72: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.Materializer = _
[warn]   override def withMaterializer(materializer: Materializer): RequestContext =
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:75: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val log: akka.event.LoggingAdapter = _
[warn]   override def withLog(log: LoggingAdapter): RequestContext =
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:81: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val parserSettings: akka.http.scaladsl.settings.ParserSettings = _
[warn]   override def withParserSettings(parserSettings: ParserSettings): RequestContext =
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:107: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val request: akka.http.scaladsl.model.HttpRequest = request
[warn]     request:          HttpRequest              = request,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:108: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val unmatchedPath: akka.http.scaladsl.model.Uri.Path = unmatchedPath
[warn]     unmatchedPath:    Uri.Path                 = unmatchedPath,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:109: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val executionContext: scala.concurrent.ExecutionContextExecutor = executionContext
[warn]     executionContext: ExecutionContextExecutor = executionContext,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:110: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.Materializer = materializer
[warn]     materializer:     Materializer             = materializer,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:111: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val log: akka.event.LoggingAdapter = log
[warn]     log:              LoggingAdapter           = log,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RequestContextImpl.scala:113: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val parserSettings: akka.http.scaladsl.settings.ParserSettings = parserSettings
[warn]     parserSettings:   ParserSettings           = parserSettings) =
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:28: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                          parserSettings:   ParserSettings   = null,
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:30: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                          exceptionHandler: ExceptionHandler = null): Route = {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:49: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                 executionContext: ExecutionContextExecutor = null,
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:51: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                 exceptionHandler: ExceptionHandler         = null): Flow[HttpRequest, HttpResponse, NotUsed] =
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:62: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                  executionContext: ExecutionContextExecutor = null,
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:64: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                  exceptionHandler: ExceptionHandler         = null): HttpRequest ? Future[HttpResponse] = {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:65: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   executionContext.ne(null)
[warn]     val effectiveEC = if (executionContext ne null) executionContext else materializer.executionContext
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:69: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   parserSettings.ne(null)
[warn]       val effectiveParserSettings = if (parserSettings ne null) parserSettings else ParserSettings(ActorMaterializerHelper.downcast(materializer).system)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:26: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val parserSettings: akka.http.scaladsl.settings.ParserSettings = null).
[warn]   def seal(route: Route)(implicit
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\Route.scala:68: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   implicit val executionContext: scala.concurrent.ExecutionContextExecutor = effectiveEC
[warn]       implicit val executionContext = effectiveEC // overrides parameter
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RouteConcatenation.scala:20: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _enhanceRouteWithConcatenation(route: Route): RouteConcatenation.RouteWithConcatenation =
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RouteResult.scala:38: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                                executionContext: ExecutionContext = null,
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RouteResult.scala:40: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                                exceptionHandler: ExceptionHandler = null): Flow[HttpRequest, HttpResponse, NotUsed] =
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\RouteResult.scala:33: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val executionContext: scala.concurrent.ExecutionContext = null).
[warn]   implicit def route2HandlerFlow(route: Route)(implicit
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\CacheConditionDirectives.scala:93: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$7.isInstanceOf[akka.http.scaladsl.model.headers.Range]
[warn]           (mapRequest(_.mapHeaders(_.filterNot(_.isInstanceOf[Range]))) &
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\CacheConditionDirectives.scala:98: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   lastModified.get
[warn]           lastModified.get <= ifModifiedSince && ifModifiedSince.clicks < System.currentTimeMillis()
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\CacheConditionDirectives.scala:103: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   eTag.get
[warn]               if (matchesRange(eTag.get, im, weakComparison = false)) step3() else complete412()
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\CacheConditionDirectives.scala:114: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   eTag.get
[warn]               if (!matchesRange(eTag.get, inm, weakComparison = true)) step5()
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\CacheConditionDirectives.scala:128: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   eTag.get
[warn]               case Some(`If-Range`(Left(tag))) if eTag.isDefined && !matches(eTag.get, tag, weakComparison = false) ?
[warn]                                                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\CodingDirectives.scala:158: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def _encodeResponse(encoders: immutable.Seq[Encoder]): Directive0 =
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\CodingDirectives.scala:123: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   CodingDirectives.theseOrDefault[akka.http.scaladsl.coding.Decoder](decoders).map[akka.http.scaladsl.server.Directive0, Seq[akka.http.scaladsl.server.Directive0]]({

[warn]   ((decoder: akka.http.scaladsl.coding.Decoder) => CodingDirectives.this.decodeRequestWith(decoder))

[warn] })(collection.this.Seq.canBuildFrom[akka.http.scaladsl.server.Directive0]).reduce
[warn]     theseOrDefault(decoders).map(decodeRequestWith).reduce(_ | _)
[warn]                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\DebuggingDirectives.scala:61: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class LoggingMagnet[T](f: LoggingAdapter ? T) // # logging-magnet
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\DebuggingDirectives.scala:96: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class LogEntry(obj: Any, level: LogLevel = DebugLevel) extends javadsl.server.directives.LogEntry {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FileAndResourceDirectives.scala:399: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   filesAndNames.apply(ix.-(1))
[warn]           if (ix == 0 || filesAndNames(ix - 1)._2 != name) Some(fan) else None
[warn]                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FileAndResourceDirectives.scala:302: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ResourceFile(url: URL, length: Long, lastModified: Long)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FileAndResourceDirectives.scala:210: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   protected[http] def _defaultClassLoader: ClassLoader = classOf[ActorSystem].getClassLoader
[info]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FileAndResourceDirectives.scala:402: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   seq.map[Int, Seq[Int]](((x$9: (java.io.File, String)) => x$9._2.length()))(collection.this.Seq.canBuildFrom[Int]).max
[warn]       def maxNameLength(seq: Seq[(File, String)]) = if (seq.isEmpty) 0 else seq.map(_._2.length).max
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FileAndResourceDirectives.scala:234: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   FileAndResourceDirectives.this.safeJoinPaths(basePath, path, log, separator) match {

[warn]   case "" => ""

[warn]   case (path @ _) => FileAndResourceDirectives.this.checkIsSafeDescendant(basePath, path, log)

[warn] }
[warn]     safeJoinPaths(basePath, path, log, separator) match {
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FileUploadDirectives.scala:76: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   part.filename.get
[warn]           .map(part ? (FileInfo(part.name, part.filename.get, part.entity.contentType), part.entity.dataBytes))
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FormFieldDirectives.scala:97: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   fields.head
[warn]         val (key, value) = fields.head
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\FormFieldDirectives.scala:98: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   fields.tail
[warn]         append(map.updated(key, value :: map.getOrElse(key, Nil)), fields.tail)
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\HeaderDirectives.scala:184: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   tag.runtimeClass.asInstanceOf[Class[T]]
[warn]       override def runtimeClass = tag.runtimeClass.asInstanceOf[Class[T]]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\HeaderDirectives.scala:202: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x.asInstanceOf[T]
[warn]       override def extractPF: PartialFunction[HttpHeader, T] = { case x if runtimeClass.isAssignableFrom(x.getClass) ? x.asInstanceOf[T] }
[warn]                                                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\HeaderDirectives.scala:211: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   tag.runtimeClass.asInstanceOf[Class[T]]
[warn]       val runtimeClass: Class[T] = tag.runtimeClass.asInstanceOf[Class[T]]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\HeaderDirectives.scala:212: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x.asInstanceOf[T]
[warn]       val extractPF: PartialFunction[Any, T] = { case x if runtimeClass.isAssignableFrom(x.getClass) ? x.asInstanceOf[T] }
[warn]                                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\HeaderDirectives.scala:176: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val u: Unit = _).
[warn]   implicit def fromUnitForModeledCustomHeader[T <: ModeledCustomHeader[T], H <: ModeledCustomHeaderCompanion[T]](u: Unit)(implicit tag: ClassTag[T], companion: ModeledCustomHeaderCompanion[T]): HeaderMagnet[T] =
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\HeaderDirectives.scala:33: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val origin: akka.http.scaladsl.model.headers.HttpOrigin = _
[warn]       if (origin.origins.exists(allowed.matches)) pass
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\ParameterDirectives.scala:82: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   x$3.request.uri.query(x$3.request.uri.query$default$1, x$3.request.uri.query$default$2).toSeq
[warn]     extract(_.request.uri.query().toSeq)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\ParameterDirectives.scala:115: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val ec: scala.concurrent.ExecutionContext = _).
[warn]     private def handleParamResult[T](paramName: String, result: Future[T])(implicit ec: ExecutionContext): Directive1[T] =
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\RangeDirectives.scala:86: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   coalescedRanges.head
[warn]             val range = coalescedRanges.head
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\RangeDirectives.scala:127: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val ctx: akka.http.scaladsl.server.RequestContext = _
[warn]         extractRequestContext.flatMap { ctx ?
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\RangeDirectives.scala:146: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val ctx: akka.http.scaladsl.server.RequestContext = _
[warn]       def rangeHeaderOfGetRequests(ctx: RequestContext): Option[Range] =
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\RangeDirectives.scala:149: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val ctx: akka.http.scaladsl.server.RequestContext = _
[warn]       extract(rangeHeaderOfGetRequests).flatMap {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\directives\WebSocketDirectives.scala:77: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   subprotocol.get
[warn]         reject(UnsupportedWebSocketSubprotocolRejection(subprotocol.get)) // None.forall == true
[warn]                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\package.scala:19: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def FIXME = throw new RuntimeException("Not yet implemented")
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\ClassMagnet.scala:27: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   tag.runtimeClass.asInstanceOf[Class[T]]
[warn]       val runtimeClass: Class[T] = tag.runtimeClass.asInstanceOf[Class[T]]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\ClassMagnet.scala:22: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val u: Unit = _).
[warn]   implicit def fromUnit[T](u: Unit)(implicit tag: ClassTag[T]): ClassMagnet[T] = ClassMagnet(tag)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\Tuple.scala:10: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn] sealed trait Tuple[T]
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\TupleOps.scala:18: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val op: akka.http.scaladsl.server.util.BinaryPolyFunc = _).
[warn]   def foldLeft[In](zero: In)(op: BinaryPolyFunc)(implicit fold: FoldLeft[In, T, op.type]): fold.Out = fold(zero, tuple)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\TupleOps.scala:27: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit <synthetic> val evidence$1: akka.http.scaladsl.server.util.Tuple[T] = _).
[warn]   implicit def enhanceTuple[T: Tuple](tuple: T): TupleOps[T] = new TupleOps(tuple)
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\Tupler.scala:13: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def OutIsTuple: Tuple[Out]
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\Tupler.scala:21: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]       def OutIsTuple = implicitly[Tuple[Out]]
[info]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\server\util\Tupler.scala:30: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]       def OutIsTuple = implicitly[Tuple[Out]]
[info]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:111: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   entity.contentType.mediaType.asInstanceOf[akka.http.scaladsl.model.MediaType.Multipart]
[warn]                     createStreamed(entity.contentType.mediaType.asInstanceOf[MediaType.Multipart], bodyParts)
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:101: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$9.isInstanceOf[akka.http.impl.engine.parsing.BodyPartParser.PartStart]
[warn]                       .splitWhen(_.isInstanceOf[PartStart])
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:30: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   implicit def defaultMultipartGeneralUnmarshaller(implicit log: LoggingAdapter = NoLogging, parserSettings: ParserSettings = null): FromEntityUnmarshaller[Multipart.General] =
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:33: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def multipartGeneralUnmarshaller(defaultCharset: HttpCharset)(implicit log: LoggingAdapter = NoLogging, parserSettings: ParserSettings = null): FromEntityUnmarshaller[Multipart.General] =
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:42: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   implicit def multipartFormDataUnmarshaller(implicit log: LoggingAdapter = NoLogging, parserSettings: ParserSettings = null): FromEntityUnmarshaller[Multipart.FormData] =
[warn]                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:51: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   implicit def defaultMultipartByteRangesUnmarshaller(implicit log: LoggingAdapter = NoLogging, parserSettings: ParserSettings = null): FromEntityUnmarshaller[Multipart.ByteRanges] =
[warn]                                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:54: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def multipartByteRangesUnmarshaller(defaultCharset: HttpCharset)(implicit log: LoggingAdapter = NoLogging, parserSettings: ParserSettings = null): FromEntityUnmarshaller[Multipart.ByteRanges] =
[warn]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:69: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     createStrict:         (MediaType.Multipart, immutable.Seq[BPS]) ? T)(implicit log: LoggingAdapter = NoLogging, parserSettings: ParserSettings = null): FromEntityUnmarshaller[T] =
[warn]                                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:46: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.http.scaladsl.model.Multipart.General.BodyPart.apply(entity, headers).toFormDataBodyPart.get
[warn]       createBodyPart = (entity, headers) ? Multipart.General.BodyPart(entity, headers).toFormDataBodyPart.get,
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:48: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.http.scaladsl.model.Multipart.General.BodyPart.Strict.apply(entity, headers).toFormDataBodyPart.get
[warn]       createStrictBodyPart = (entity, headers) ? Multipart.General.BodyPart.Strict(entity, headers).toFormDataBodyPart.get,
[warn]                                                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:58: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.http.scaladsl.model.Multipart.General.BodyPart.apply(entity, headers).toByteRangesBodyPart.get
[warn]       createBodyPart = (entity, headers) ? Multipart.General.BodyPart(entity, headers).toByteRangesBodyPart.get,
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:60: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.http.scaladsl.model.Multipart.General.BodyPart.Strict.apply(entity, headers).toByteRangesBodyPart.get
[warn]       createStrictBodyPart = (entity, headers) ? Multipart.General.BodyPart.Strict(entity, headers).toByteRangesBodyPart.get,
[warn]                                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\MultipartUnmarshallers.scala:89: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val entity: akka.http.scaladsl.model.HttpEntity.Strict = createEntity.apply(akka.stream.scaladsl.Source.empty[Nothing]) match {

[warn]   case (x @ (_: akka.http.scaladsl.model.HttpEntity.Strict)) => x

[warn]   ca
[warn]                         val entity = createEntity(Source.empty) match {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\PredefinedFromStringUnmarshallers.scala:67: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   f.apply(string)

[warn] } catch {

[warn]   case (x$13 @ (_: Throwable)) => {

[warn]     <artifact> val catchExpr1: PartialFunction[Throwable,Nothing] = PredefinedFromStringUnmarshallers.this.numberFormatError(string, target);

[warn]     if (catchExpr1.isDefinedAt(x$13))

[warn]       catchExpr1.apply(x$13)

[warn]     else

[warn]     
[warn]       try f(string)
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\PredefinedFromStringUnmarshallers.scala:13: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def _fromStringUnmarshallerFromByteStringUnmarshaller[T](implicit bsum: FromByteStringUnmarshaller[T]): Unmarshaller[String, T] = {
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\PredefinedFromStringUnmarshallers.scala:46: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   implicit def CsvSeq[T](implicit unmarshaller: Unmarshaller[String, T]): Unmarshaller[String, immutable.Seq[T]] =
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\unmarshalling\Unmarshaller.scala:74: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   unmarshallers.apply(ix)
[warn]           unmarshallers(ix)(a).fast.recoverWith {
[warn]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\target\src_managed\main\akka\http\javadsl\server\JavaPathMatchers.scala:11: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.http.scaladsl.server.PathMatcher
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\target\src_managed\main\akka\http\javadsl\server\JavaPathMatchers.scala:12: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import java.util.{ List ? JList }
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\target\src_managed\main\akka\http\javadsl\server\JavaPathMatchers.scala:14: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import java.util.function.BiFunction
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\target\src_managed\main\akka\http\javadsl\server\JavaPathMatchers.scala:15: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import java.util.function.{ Function ? JFunction }
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\target\src_managed\main\akka\http\javadsl\server\JavaPathMatchers.scala:20: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.http.scaladsl.server.PathMatcher
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\target\src_managed\main\akka\http\javadsl\server\JavaPathMatchers.scala:21: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import java.util.{List => JList}
[info]        ^
[info] [warn] [scapegoat] Analysis complete: 123 files - 0 errors 115 warns 36 infos
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http\src\main\scala\akka\http\scaladsl\common\StrictForm.scala:67: Invalid implicitNotFound message for trait FieldUnmarshaller in object Field:

[warn] Missing argument `msg` on implicitNotFound annotation.
[warn]     sealed trait FieldUnmarshaller[T] {
[warn]                  ^
[warn] there were 6 deprecation warnings; re-run with -deprecation for details
[warn] 116 warnings found
[info] Compiling 8 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:544: [scapegoat] find().isDefined() instead of exists()
[info]   `find().isDefined` can be replaced with `exists()`, which is more concise.
[info]   clients.find(((x$8: akka.remote.testconductor.Controller.NodeInfo) => x$8.name.==(n.name))).isDefined
[info]       if (clients.find(_.name == n.name).isDefined) throw new DuplicateNode(d, n)
[info]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:501: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class BarrierTimeout extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with akka.remote.testconductor.BarrierCoordinator.Printer with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val data: akka.remote.testconductor.BarrierCoordinator.Data = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def data: akka.remote.testconductor.BarrierCoordinator.Data = BarrierTimeout.this.data;

[warn]   def <init>(data: akka.remote.testconducto
[warn]   final case class BarrierTimeout(data: Data)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:503: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class FailedBarrier extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with akka.remote.testconductor.BarrierCoordinator.Printer with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val data: akka.remote.testconductor.BarrierCoordinator.Data = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def data: akka.remote.testconductor.BarrierCoordinator.Data = FailedBarrier.this.data;

[warn]   def <init>(data: akka.remote.testconductor.
[warn]   final case class FailedBarrier(data: Data)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:505: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class DuplicateNode extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with akka.remote.testconductor.BarrierCoordinator.Printer with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val data: akka.remote.testconductor.BarrierCoordinator.Data = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def data: akka.remote.testconductor.BarrierCoordinator.Data = DuplicateNode.this.data;

[warn]   <caseaccessor> <paramaccessor> private[this
[warn]   final case class DuplicateNode(data: Data, node: Controller.NodeInfo)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:507: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class WrongBarrier extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with akka.remote.testconductor.BarrierCoordinator.Printer with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val barrier: String = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def barrier: String = WrongBarrier.this.barrier;

[warn]   <caseaccessor> <paramaccessor> private[this] val client: akka.actor.ActorRef = _;

[warn]   <stable> <caseaccessor> <accessor> <p
[warn]   final case class WrongBarrier(barrier: String, client: ActorRef, data: Data)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:510: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class BarrierEmpty extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with akka.remote.testconductor.BarrierCoordinator.Printer with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val data: akka.remote.testconductor.BarrierCoordinator.Data = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def data: akka.remote.testconductor.BarrierCoordinator.Data = BarrierEmpty.this.data;

[warn]   <caseaccessor> <paramaccessor> private[this] 
[warn]   final case class BarrierEmpty(data: Data, msg: String) extends RuntimeException(msg) with NoStackTrace with Printer
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:511: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class ClientLost extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with akka.remote.testconductor.BarrierCoordinator.Printer with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val data: akka.remote.testconductor.BarrierCoordinator.Data = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def data: akka.remote.testconductor.BarrierCoordinator.Data = ClientLost.this.data;

[warn]   <caseaccessor> <paramaccessor> private[this] val 
[warn]   final case class ClientLost(data: Data, client: RoleName)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:458: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   Controller.this.addrInterest.get(node).getOrElse[Set[akka.actor.ActorRef]](scala.this.Predef.Set.apply[akka.actor.ActorRef]())
[warn]           else addrInterest += node → ((addrInterest get node getOrElse Set()) + sender())
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:309: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var roleName: RoleName = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:63: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Conductor.this._controller.ne(null)
[warn]     if (_controller ne null) throw new RuntimeException("TestConductorServer was already started")
[warn]                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:418: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.remote.testconductor.RoleName, akka.remote.testconductor.Controller.NodeInfo]()
[info]   var nodes = Map[RoleName, NodeInfo]()
[info]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:421: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.remote.testconductor.RoleName, Set[akka.actor.ActorRef]]()
[info]   var addrInterest = Map[RoleName, Set[ActorRef]]()
[info]                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:458: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.actor.ActorRef]()
[info]           else addrInterest += node → ((addrInterest get node getOrElse Set()) + sender())
[info]                                                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Conductor.scala:540: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.remote.testconductor.Controller.NodeInfo]()
[info]   startWith(Idle, Data(Set(), "", Nil, null))
[info]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\DataTypes.scala:74: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def encode(ctx: org.jboss.netty.channel.ChannelHandlerContext, ch: org.jboss.netty.channel.Channel, msg: AnyRef): AnyRef = msg match {

[warn]   case (x @ (_: akka.remote.testconductor.NetworkOp)) => {

[warn]     val w: akka.remote.testconductor.TestConductorProtocol.Wrapper.Builder = akka.remote.testconductor.T
[warn]   def encode(ctx: ChannelHandlerContext, ch: Channel, msg: AnyRef): AnyRef = msg match {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\DataTypes.scala:125: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def decode(ctx: org.jboss.netty.channel.ChannelHandlerContext, ch: org.jboss.netty.channel.Channel, msg: AnyRef): AnyRef = msg match {

[warn]   case (w @ (_: akka.remote.testconductor.TestConductorProtocol.Wrapper)) if w.getAllFields().size().==(1) => if (w.hasHello())

[warn]     {

[warn]       val h: akka.remote.tes
[warn]   def decode(ctx: ChannelHandlerContext, ch: Channel, msg: AnyRef): AnyRef = msg match {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\DataTypes.scala:64: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.host.get
[warn]       .setHost(addr.host.get)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\DataTypes.scala:65: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]       .setPort(addr.port.get)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Extension.scala:80: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TestConductorExt.this.system.provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]   val transport = system.provider.asInstanceOf[RemoteActorRefProvider].transport
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Extension.scala:31: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.remote.testconductor.TestConductorExt = TestConductor.super.get(system)
[info]   override def get(system: ActorSystem): TestConductorExt = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Extension.scala:66: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val config: com.typesafe.config.Config = _
[warn]     private def computeWPS(config: Config): Int =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Player.scala:246: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClientFSM.this.context.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]           context.system.asInstanceOf[ActorSystemImpl].abort()
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Player.scala:226: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]           else if (t.rateMBit == 0.0f) Blackhole
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Player.scala:127: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class ConnectionFailure extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val msg: String = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def msg: String = ConnectionFailure.this.msg;

[warn]   def <init>(msg: String): akka.remote.testconductor.ClientFSM.ConnectionFailure = {

[warn]     ConnectionFailure.super.<init>(msg);

[warn]     ()

[warn]   };

[warn]   <synthetic> def copy(msg: String = msg):
[warn]   final case class ConnectionFailure(msg: String) extends RuntimeException(msg) with NoStackTrace
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Player.scala:52: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Player.this._client.ne(null)
[warn]     if (_client ne null) throw new IllegalStateException("TestConductorClient already started")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Player.scala:323: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = {

[warn]   RemoteConnection.shutdown(channel);

[warn]   ()

[warn] }
[warn]     executor.execute(new Runnable { def run = RemoteConnection.shutdown(channel) }) // Must be shutdown outside of the Netty IO pool
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Player.scala:96: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: akka.pattern.AskTimeoutException)) => {

[warn]   {

[warn]     <artifact> val qual$4: akka.actor.Sc
[warn]         case e: AskTimeoutException ?
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Player.scala:93: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   implicit val timeout: akka.util.Timeout = akka.util.Timeout.apply(barrierTimeout.+(Player.this.Settings.QueryTimeout.duration))
[warn]         implicit val timeout = Timeout(barrierTimeout + Settings.QueryTimeout.duration)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\Player.scala:233: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]           cmdFuture onSuccess {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testconductor\RemoteConnection.scala:56: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val handler: org.jboss.netty.channel.ChannelHandler = _
[warn]       (pipe, handler) ? pipe.addLast(Logging.simpleName(handler.getClass), handler); pipe
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:410: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sys.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val deployer = sys.asInstanceOf[ExtendedActorSystem].provider.deployer
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:441: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MultiNodeSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   protected val myAddress = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:279: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   MultiNodeSpec.selfIndex.==(0)
[warn]     if (selfIndex == 0) {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:390: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   MultiNodeSpec.selfIndex.==(0)
[warn]       if (selfIndex == 0) tc.startController(initialParticipants, myself, controllerAddr)
[warn]                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:21: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.testconductor.RoleName
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:88: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   MultiNodeConfig.this._deployments.get(role).getOrElse[scala.collection.immutable.Seq[String]](scala.`package`.Vector.apply[Nothing]())
[warn]     _deployments += role → ((_deployments get role getOrElse Vector()) :+ deployment)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:117: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   MultiNodeConfig.this._deployments.get(node).getOrElse[scala.collection.immutable.Seq[String]](immutable.this.Nil)
[warn]   private[testkit] def deployments(node: RoleName): immutable.Seq[String] = (_deployments get node getOrElse Nil) ++ _allDeploy
[warn]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:337: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var testConductor: TestConductorExt = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:458: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MultiNodeSpec.this.myAddress.port.get
[warn]     val config = ConfigFactory.parseString(s"akka.remote.netty.tcp{port=${myAddress.port.get}\nhostname=${myAddress.host.get}}")
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:458: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MultiNodeSpec.this.myAddress.host.get
[warn]     val config = ConfigFactory.parseString(s"akka.remote.netty.tcp{port=${myAddress.port.get}\nhostname=${myAddress.host.get}}")
[warn]                                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:273: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   final override def multiNodeSpecBeforeAll: Unit = MultiNodeSpec.this.atStartup()
[warn]   final override def multiNodeSpecBeforeAll {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:277: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   final override def multiNodeSpecAfterAll: Unit = {

[warn]   if (MultiNodeSpec.selfIndex.==(0))

[warn]     {

[warn]       MultiNodeSpec.this.testConductor.removeNode(MultiNodeSpec.this.myself);

[warn]       MultiNodeSpec.this.within[Unit](MultiNodeSpec.this.testConductor.Settings.BarrierTimeout.duration)(MultiNodeSpec.this.
[warn]   final override def multiNodeSpecAfterAll {
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:31: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.remote.testconductor.RoleName, com.typesafe.config.Config]()
[info]   private var _nodeConf = Map[RoleName, Config]()
[info]                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:33: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.remote.testconductor.RoleName, scala.collection.immutable.Seq[String]]()
[info]   private var _deployments = Map[RoleName, immutable.Seq[String]]()
[info]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:46: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   configs.reduceLeft
[warn]     val c = configs.reduceLeft(_ withFallback _)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-multi-node-testkit\src\main\scala\akka\remote\testkit\MultiNodeSpec.scala:114: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   configs.reduceLeft
[warn]     configs reduceLeft (_ withFallback _)
[warn]             ^
[info] [warn] [scapegoat] Analysis complete: 8 files - 0 errors 37 warns 9 infos
[warn] 37 warnings found
[info] Compiling 6 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-remote-java\target\classes...
[info] Compiling 8 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-remote-scala\target\classes...
[info] Compiling 19 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Cluster.scala:232: [scapegoat] Avoid Traversable.size != 0
[warn]   .size can be slow for some data structures, prefer .nonEmpty, which is O(1).
[warn]   to.length.>(0)
[warn]     require(to.length > 0, "at least one `ClusterDomainEvent` class is required")
[warn]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Cluster.scala:30: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.cluster.Cluster = Cluster.super.get(system)
[info]   override def get(system: ActorSystem): Cluster = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Cluster.scala:401: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Cluster.this.readView.!=(null)
[warn]       if (readView != null)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Cluster.scala:133: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Cluster.this.system.dynamicAccess.createInstanceFor[akka.actor.Scheduler](Cluster.this.system.settings.SchedulerClass, scala.collection.immutable.Seq.apply[(Class[_ >: java.util.concurrent.ThreadFactory with akka.event.LoggingAdapter with com.typesafe.config.Config <: Object], Object)](scala.this.Predef.ArrowAssoc[Class[com.typesafe.config.Config]](classOf[com.typesafe.config.Config]).→[com.typesafe.config.Config](cfg), scala.this.Predef.ArrowAssoc[Class[akka.event.LoggingAdapter]](classOf[akka.
[warn]         classOf[ThreadFactory] → threadFactory)).get
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterActorRefProvider.scala:81: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   deploy.routerConfig.isInstanceOf[akka.remote.routing.RemoteRouterConfig]
[warn]           if (deploy.routerConfig.isInstanceOf[RemoteRouterConfig])
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterDaemon.scala:1241: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       seedNodes.collect {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterJmx.scala:207: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: javax.management.InstanceAlreadyExistsException)) => ()
[warn]       case e: InstanceAlreadyExistsException ? // ignore - we are running multiple cluster nodes in the same JVM (probably for testing)
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterJmx.scala:218: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: javax.management.InstanceNotFoundException)) => ()
[warn]       case e: InstanceNotFoundException ? // ignore - we are running multiple cluster nodes in the same JVM (probably for testing)
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterJmx.scala:133: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (log).
[warn] private[akka] class ClusterJmx(cluster: Cluster, log: LoggingAdapter) {
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:67: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterMetricsCollector.this.context.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val collector: MetricsCollector = MetricsCollector(context.system.asInstanceOf[ExtendedActorSystem], settings)
[warn]                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:737: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   method.invoke(SigarMetricsCollector.this.sigar).asInstanceOf[Long]
[warn]       try method.invoke(sigar).asInstanceOf[Long] catch {
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:760: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SigarMetricsCollector.this.LoadAverage.get.invoke(SigarMetricsCollector.this.sigar).asInstanceOf[Array[AnyRef]].apply(0).asInstanceOf[Number]
[warn]     value = Try(LoadAverage.get.invoke(sigar).asInstanceOf[Array[AnyRef]](0).asInstanceOf[Number]),
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:775: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SigarMetricsCollector.this.CombinedCpu.get.invoke(SigarMetricsCollector.this.Cpu.get.invoke(SigarMetricsCollector.this.sigar)).asInstanceOf[Number]
[warn]     value = Try(CombinedCpu.get.invoke(Cpu.get.invoke(sigar)).asInstanceOf[Number]),
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:294: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]     if (newValue == value) this // no change
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:738: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.getCause().isInstanceOf[LinkageError]
[warn]         case e: InvocationTargetException if e.getCause.isInstanceOf[LinkageError] ?
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:497: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HeapMemory.this.max.get
[warn]     require(max.isEmpty || max.get > 0L, "max heap expected to be > 0 bytes")
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:731: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SigarMetricsCollector.this.Cpu.get
[warn]   private val CombinedCpu: Option[Method] = Try(Cpu.get.getReturnType.getMethod("getCombined")).toOption
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:760: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SigarMetricsCollector.this.LoadAverage.get
[warn]     value = Try(LoadAverage.get.invoke(sigar).asInstanceOf[Array[AnyRef]](0).asInstanceOf[Number]),
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:775: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SigarMetricsCollector.this.CombinedCpu.get
[warn]     value = Try(CombinedCpu.get.invoke(Cpu.get.invoke(sigar)).asInstanceOf[Number]),
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:775: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SigarMetricsCollector.this.Cpu.get
[warn]     value = Try(CombinedCpu.get.invoke(Cpu.get.invoke(sigar)).asInstanceOf[Number]),
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:781: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SigarMetricsCollector.this.createMethodFrom(SigarMetricsCollector.this.sigar, "close", SigarMetricsCollector.this.createMethodFrom$default$3).get
[warn]   override def close(): Unit = Try(createMethodFrom(sigar, "close").get.invoke(sigar))
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:105: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def postStop: Unit = {

[warn]   ClusterMetricsCollector.this.cluster.unsubscribe(ClusterMetricsCollector.this.self);

[warn]   ClusterMetricsCollector.this.gossipTask.cancel();

[warn]   ClusterMetricsCollector.this.metricsTask.cancel();

[warn]   ClusterMetricsCollector.this.collector.close()

[warn] }
[warn]   override def postStop: Unit = {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:738: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: java.lang.reflect.InvocationTargetException)) if e.getCause().isInstanceOf[LinkageErro
[warn]         case e: InvocationTargetException if e.getCause.isInstanceOf[LinkageError] ?
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:719: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   cluster.system.dynamicAccess.createInstanceFor[AnyRef]("org.hyperic.sigar.Sigar", immutable.this.Nil)((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])).get
[warn]       cluster.system.dynamicAccess.createInstanceFor[AnyRef]("org.hyperic.sigar.Sigar", Nil).get)
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterMetricsCollector.scala:814: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.dynamicAccess.createInstanceFor[akka.cluster.MetricsCollector](settings.MetricsCollectorClass, immutable.this.List.apply[(Class[akka.actor.ActorSystem], akka.actor.ExtendedActorSystem)](scala.this.Predef.ArrowAssoc[Class[akka.actor.ActorSystem]](classOf[akka.actor.ActorSystem]).→[akka.actor.ExtendedActorSystem](system)))((ClassTag.apply[akka.cluster.MetricsCollector](classOf[akka.cluster.MetricsCollector]): scala.reflect.ClassTag[akka.cluster.MetricsCollector])).recover[akka.cluster.Metri
[warn]         }.get
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\ClusterRemoteWatcher.scala:77: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       clusterNodes = state.members.collect { case m if m.address != selfAddress ? m.address }
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\DowningProvider.scala:23: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val eas = system.asInstanceOf[ExtendedActorSystem]
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\DowningProvider.scala:29: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   eas.dynamicAccess.createInstanceFor[akka.cluster.DowningProvider](fqcn, immutable.this.List.apply[(Class[akka.actor.ActorSystem], akka.actor.ActorSystem)](scala.Tuple2.apply[Class[akka.actor.ActorSystem], akka.actor.ActorSystem](classOf[akka.actor.ActorSystem], system)))((ClassTag.apply[akka.cluster.DowningProvider](classOf[akka.cluster.DowningProvider]): scala.reflect.ClassTag[akka.cluster.DowningProvider])).recover[akka.cluster.DowningProvider](({

[warn]   @SerialVersionUID(value = 0) final <synthet
[warn]       }.get
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Gossip.scala:274: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       ser = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Gossip.scala:241: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new GossipEnvelope(from, to, gossip, null, null)
[warn]     new GossipEnvelope(from, to, gossip, null, null)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Gossip.scala:244: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new GossipEnvelope(from, to, null, serDeadline, ser)
[warn]     new GossipEnvelope(from, to, null, serDeadline, ser)
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Gossip.scala:213: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   Gossip.this.members.maxBy
[warn]     members.maxBy(m ? if (m.upNumber == Int.MaxValue) 0 else m.upNumber)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Member.scala:142: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   members.reduceLeft
[warn]         if (members.size == 2) acc + members.reduceLeft(highestPriorityOf)
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Member.scala:144: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   members.head
[warn]           val m = members.head
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Member.scala:54: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val status: akka.cluster.MemberStatus = _
[warn]   def copy(status: MemberStatus): Member = {
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Member.scala:65: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val upNumber: Int = _
[warn]   def copyUp(upNumber: Int): Member = {
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Member.scala:285: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val address: akka.actor.Address = address
[warn]   def copy(address: Address = address, uid: Int = uid) = new UniqueAddress(address, uid)
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Reachability.scala:264: [scapegoat] Comparision with self
[warn]   Comparison with self will always yield true.
[warn]       records.size == other.records.size && versions == versions &&
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\Reachability.scala:274: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   rowsOption.get
[warn]       rows = rowsOption.get
[warn]                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\VectorClock.scala:113: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   private final def compareOnlyTo(that: VectorClock, order: Ordering): Ordering = {
[info]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\protobuf\ClusterMessageSerializer.scala:406: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   obj.asInstanceOf[Number]
[warn]           obj.asInstanceOf[jl.Number]
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\protobuf\ClusterMessageSerializer.scala:319: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   hashMapping.apply(v.getHashIndex())
[warn]       v ? (VectorClock.Node.fromHash(hashMapping(v.getHashIndex)), v.getTimestamp))(breakOut))
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\protobuf\ClusterMessageSerializer.scala:107: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = clazz match {

[warn]   case (x: Class[_])Some[Class[_]]((c @ _)) => ClusterMessageSerializer.this.fromBinaryMap.get(c.asInstanceOf[Class[akka.cluster.ClusterMessage]]) match {

[warn]     case (x: Array[Byte] => Object)Some[Array[Byte] => Obje
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = clazz match {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\protobuf\ClusterMessageSerializer.scala:141: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var protocolCache: String = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\protobuf\ClusterMessageSerializer.scala:143: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var systemCache: String = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\protobuf\ClusterMessageSerializer.scala:28: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ClusterMessageSerializer.this.<init>(null)
[warn]   def this() = this(null)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\protobuf\ClusterMessageSerializer.scala:32: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ClusterMessageSerializer.this.system.eq(null)
[warn]     if (system eq null) 5
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\AdaptiveLoadBalancing.scala:165: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   routingLogic.asInstanceOf[akka.cluster.routing.AdaptiveLoadBalancingRoutingLogic]
[warn]       routingLogic.asInstanceOf[AdaptiveLoadBalancingRoutingLogic]))
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\AdaptiveLoadBalancing.scala:246: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   routingLogic.asInstanceOf[akka.cluster.routing.AdaptiveLoadBalancingRoutingLogic]
[warn]       routingLogic.asInstanceOf[AdaptiveLoadBalancingRoutingLogic]))
[warn]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\AdaptiveLoadBalancing.scala:58: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @tailrec final def metricsChanged(event: ClusterMetricsChanged): Unit = {
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\AdaptiveLoadBalancing.scala:435: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   capacity.minBy
[warn]       val (_, min) = capacity.minBy { case (_, c) ? c }
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\AdaptiveLoadBalancing.scala:394: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   dynamicAccess.createInstanceFor[akka.cluster.routing.MetricsSelector](fqn, args)((ClassTag.apply[akka.cluster.routing.MetricsSelector](classOf[akka.cluster.routing.MetricsSelector]): scala.reflect.ClassTag[akka.cluster.routing.MetricsSelector])).recover[akka.cluster.routing.MetricsSelector](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => Nothing> = {

[warn]  
[warn]         }).get
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:161: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.local.withFallback(local).asInstanceOf[akka.routing.Group]
[warn]       copy(local = this.local.withFallback(local).asInstanceOf[Group])
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:163: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.local.withFallback(other).asInstanceOf[akka.routing.Group]
[warn]       copy(local = this.local.withFallback(other).asInstanceOf[Group])
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:186: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   context.asInstanceOf[akka.actor.ActorCell]
[warn]     val ref = context.asInstanceOf[ActorCell].attachChild(
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:216: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.local.withFallback(otherLocal).asInstanceOf[akka.routing.Pool]
[warn]       copy(local = this.local.withFallback(otherLocal).asInstanceOf[Pool])
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:218: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.local.withFallback(other).asInstanceOf[akka.routing.Pool]
[warn]       copy(local = this.local.withFallback(other).asInstanceOf[Pool])
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:237: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.isInstanceOf[akka.cluster.ClusterEvent.ClusterDomainEvent]
[warn]     (msg.isInstanceOf[ClusterDomainEvent]) || msg.isInstanceOf[CurrentClusterState] || super.isManagementMessage(msg)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:237: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.isInstanceOf[akka.cluster.ClusterEvent.CurrentClusterState]
[warn]     (msg.isInstanceOf[ClusterDomainEvent]) || msg.isInstanceOf[CurrentClusterState] || super.isManagementMessage(msg)
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:365: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterRouterActor.this.cell.routerConfig.isInstanceOf[akka.routing.Pool]
[warn]   if (!cell.routerConfig.isInstanceOf[Pool] && !cell.routerConfig.isInstanceOf[Group])
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:365: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterRouterActor.this.cell.routerConfig.isInstanceOf[akka.routing.Group]
[warn]   if (!cell.routerConfig.isInstanceOf[Pool] && !cell.routerConfig.isInstanceOf[Group])
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:130: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ClusterRouterSettingsBase.this.useRole.get
[warn]   require(useRole.isEmpty || useRole.get.nonEmpty, "useRole must be either None or non-empty Some wrapped role")
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:145: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ClusterRouterGroup.this.settings.useRole.get
[warn]       if (Cluster(system).selfRoles.contains(settings.useRole.get)) {
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:196: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ClusterRouterPool.this.settings.useRole.get
[warn]       if (Cluster(sys).selfRoles.contains(settings.useRole.get)) {
[warn]                                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:61: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   ClusterRouterGroupSettings.this.routeesPaths.foreach[Unit](((p: String) => p match {

[info]   case akka.actor.RelativeActorPath.unapply(<unapply-selector>) <unapply> ((elements @ _)) => ()

[info]   case _ => throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply("routeesPaths [", "] is not a valid actor path without address information").s(p))

[info] }))
[info]   routeesPaths.foreach(p ? p match {
[info]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:284: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   numberOfRouteesPerNode.minBy
[warn]       val (address, count) = numberOfRouteesPerNode.minBy(_._2)
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:341: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   unusedNodes.head
[warn]         Some((unusedNodes.head, settings.routeesPaths.head))
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:341: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   ClusterRouterGroupActor.this.settings.routeesPaths.head
[warn]         Some((unusedNodes.head, settings.routeesPaths.head))
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:343: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   ClusterRouterGroupActor.this.usedRouteePaths.minBy
[warn]         val (address, used) = usedRouteePaths.minBy { case (address, used) ? used.size }
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:411: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   a match {

[warn]   case (protocol: String, system: String, host: Option[String], port: Option[Int])akka.actor.Address(_, _, scala.None, scala.None) => ClusterRouterActor.this.cluster.selfAddress

[warn]   case (a 
[warn]     a match {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\main\scala\akka\cluster\routing\ClusterRouterConfig.scala:443: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       nodes = s.members.collect { case m if isAvailable(m) ? m.address }
[warn]                                 ^
[info] [warn] [scapegoat] Analysis complete: 19 files - 0 errors 68 warns 4 infos
[warn] there were 18 deprecation warnings; re-run with -deprecation for details
[warn] 68 warnings found
[info] Compiling 24 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\PersistenceQuery.scala:46: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PersistenceQuery.this.readJournalPluginFor(readJournalPluginId).scaladslPlugin.asInstanceOf[T]
[warn]     readJournalPluginFor(readJournalPluginId).scaladslPlugin.asInstanceOf[T]
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\PersistenceQuery.scala:53: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PersistenceQuery.this.readJournalPluginFor(readJournalPluginId).javadslPlugin.asInstanceOf[T]
[warn]     readJournalPluginFor(readJournalPluginId).javadslPlugin.asInstanceOf[T]
[warn]                                                                         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\PersistenceQuery.scala:27: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[persistence] case class PluginHolder(
[info]                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\PersistenceQuery.scala:20: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.persistence.query.PersistenceQuery = PersistenceQuery.super.get(system)
[info]   override def get(system: ActorSystem): PersistenceQuery = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\PersistenceQuery.scala:80: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   PersistenceQuery.this.system.dynamicAccess.getClassFor[AnyRef](pluginClassName)((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])).get
[warn]     val pluginClass = system.dynamicAccess.getClassFor[AnyRef](pluginClassName).get
[warn]                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\PersistenceQuery.scala:90: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   instantiate({

[warn]   <synthetic> <artifact> val x$2: (Class[akka.actor.ExtendedActorSystem], akka.actor.ExtendedActorSystem) = scala.Tuple2.apply[Class[akka.actor.ExtendedActorSystem], akka.actor.ExtendedActorSystem](classOf[akka.actor.ExtendedActorSystem], PersistenceQuery.this.system);

[warn]   {

[warn]   <synthetic> <artifact> val x$1: (Class[com.typesafe.config.Config], com.typesafe.config.Config) = scala.Tuple2.apply[Class[com.typesafe.config.Config], com.typesafe.config.Config](classOf[com.typesafe.config
[warn]       }.get
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\PersistenceQuery.scala:52: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val clazz: Class[T] = _).
[warn]   final def getReadJournalFor[T <: javadsl.ReadJournal](clazz: Class[T], readJournalPluginId: String): T =
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\journal\leveldb\AllPersistenceIdsPublisher.scala:29: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (maxBufSize).
[warn] private[akka] class AllPersistenceIdsPublisher(liveQuery: Boolean, maxBufSize: Int, writeJournalPluginId: String)
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\journal\leveldb\DeliveryBuffer.scala:19: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   DeliveryBuffer.this.buf.head
[warn]         onNext(buf.head)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence-query\src\main\scala\akka\persistence\query\journal\leveldb\DeliveryBuffer.scala:11: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val x$1: scala.collection.immutable.Vector[T] = _
[warn] private[akka] trait DeliveryBuffer[T] { _: ActorPublisher[T] ?
[warn]                     ^
[info] [warn] [scapegoat] Analysis complete: 24 files - 0 errors 8 warns 2 infos
[warn] 8 warnings found
[info] Compiling 3 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-camel-scala\target\classes...
[info] Compiling 11 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-camel-java\target\classes...
[info] Compiling 23 Scala sources and 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\target\test-classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\AkkaSpec.scala:111: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   a.==(b)
[warn]       def areEqual(a: Class[A], b: Class[B]) = a == b
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\AkkaSpec.scala:116: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   a.==(b)
[warn]       def areEqual(a: Set[A], b: T) = a == b
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\AkkaSpec.scala:77: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   final override def beforeAll: Unit = {

[warn]   AkkaSpec.this.startCoroner();

[warn]   AkkaSpec.this.atStartup()

[warn] }
[warn]   final override def beforeAll {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\AkkaSpec.scala:82: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   final override def afterAll: Unit = {

[warn]   AkkaSpec.this.beforeTermination();

[warn]   AkkaSpec.this.shutdown(AkkaSpec.this.shutdown$default$1, AkkaSpec.this.shutdown$default$2, AkkaSpec.this.shutdown$default$3);

[warn]   AkkaSpec.this.afterTermination();

[warn]   AkkaSpec.this.stopCoroner()

[warn] }
[warn]   final override def afterAll {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\Coroner.scala:260: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     coronerWatch = null
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\Coroner.scala:150: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ids.==(null)
[warn]       if (ids == null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\Coroner.scala:175: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ti.getLockName().!=(null)
[warn]       if (ti.getLockName != null) {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\Coroner.scala:179: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ti.getLockOwnerName().!=(null)
[warn]       if (ti.getLockOwnerName != null) {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\Coroner.scala:113: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = triggerReportIfOverdue(duration)
[warn]     new Thread(new Runnable { def run = triggerReportIfOverdue(duration) }, "Coroner").start()
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\Coroner.scala:85: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val duration: scala.concurrent.duration.Duration = _
[warn]     def triggerReportIfOverdue(duration: Duration): Unit = {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\CoronerSpec.scala:71: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   $anon.this.recursiveLock(initialLocks)

[warn] } catch {

[warn]   case (_: InterruptedException) => ()

[warn] }
[warn]           def run = try recursiveLock(initialLocks) catch { case _: InterruptedException ? () }
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\CoronerSpec.scala:71: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = try {

[warn]   $anon.this.recursiveLock(initialLocks)

[warn] } catch {

[warn]   case (_: InterruptedException) => ()

[warn] }
[warn]           def run = try recursiveLock(initialLocks) catch { case _: InterruptedException ? () }
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\CoronerSpec.scala:71: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (_: InterruptedException) => ()
[warn]           def run = try recursiveLock(initialLocks) catch { case _: InterruptedException ? () }
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\DefaultTimeoutSpec.scala:15: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def afterAll: Unit = {

[warn]   DefaultTimeoutSpec.this.system.terminate();

[warn]   ()

[warn] }
[warn]   override def afterAll = system.terminate
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\ImplicitSenderSpec.scala:15: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def afterAll: Unit = {

[warn]   ImplicitSenderSpec.this.system.terminate();

[warn]   ()

[warn] }
[warn]   override def afterAll = system.terminate
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\JavaTestKitSpec.scala:16: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]         val received = receiveN(sent.size, 5 seconds)
[info]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\JavaTestKitSpec.scala:25: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]         val received = receiveN(sent.size)
[info]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:60: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   replyTo.asInstanceOf[scala.concurrent.Promise[Any]]
[warn]       case replyTo: Promise[_] ? replyTo.asInstanceOf[Promise[Any]].success("complexReply")
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:276: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TestActorRefSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       ref.underlyingActor.supervisor should be(system.asInstanceOf[ActorSystemImpl].guardian)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:299: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TestActorRefSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       ref.underlyingActor.supervisor should be(system.asInstanceOf[ActorSystemImpl].guardian)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:22: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var otherthread: Thread = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:39: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var replyTo: ActorRef = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestActorRefSpec.scala:112: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   override def beforeEach(): Unit = otherthread = null
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\TestFSMRefSpec.scala:61: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TestFSMRefSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     val guardian = system.asInstanceOf[ActorSystemImpl].guardian
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\FileDescriptorMetricSet.scala:35: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   method.invoke(FileDescriptorMetricSet.this.os).asInstanceOf[Long]
[warn]     method.invoke(os).asInstanceOf[Long]
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:17: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("heap-init")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("heap-init")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:18: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("heap-used")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("heap-used")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:19: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("heap-max")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("heap-max")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("heap-committed")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("heap-committed")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:21: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("heap-usage")).asInstanceOf[com.codahale.metrics.RatioGauge]
[warn]       metrics.get(key("heap-usage")).asInstanceOf[RatioGauge].getValue)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:27: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("total-init")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("total-init")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:28: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("total-used")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("total-used")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:29: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("total-max")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("total-max")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:30: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("total-committed")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("total-committed")).asInstanceOf[Gauge[Long]].getValue)
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:36: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("non-heap-init")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("non-heap-init")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:37: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("non-heap-used")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("non-heap-used")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:38: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("non-heap-max")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("non-heap-max")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:39: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("non-heap-committed")).asInstanceOf[com.codahale.metrics.Gauge[Long]]
[warn]       metrics.get(key("non-heap-committed")).asInstanceOf[Gauge[Long]].getValue,
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:40: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metrics.get(MemoryUsageSnapshotting.this.key("non-heap-usage")).asInstanceOf[com.codahale.metrics.RatioGauge]
[warn]       metrics.get(key("non-heap-usage")).asInstanceOf[RatioGauge].getValue)
[warn]                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:47: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[akka] case class TotalMemoryUsage(init: Long, used: Long, max: Long, comitted: Long) {
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:58: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[akka] case class HeapMemoryUsage(init: Long, used: Long, max: Long, comitted: Long, usage: Double) {
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MemoryUsageSnapshotting.scala:69: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private[akka] case class NonHeapMemoryUsage(init: Long, used: Long, max: Long, comitted: Long, usage: Double) {
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MetricKeyDSL.scala:8: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class MetricKey private[MetricKeyDSL] (path: String) {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MetricsKit.scala:157: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MetricsKit.this.emptySortedMap.asInstanceOf[java.util.TreeMap[String,T]]
[warn]   private def empty[T] = emptySortedMap.asInstanceOf[util.TreeMap[String, T]]
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\MetricsKit.scala:194: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   metric.asInstanceOf[T]
[warn]     } yield key → metric.asInstanceOf[T]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\reporter\AkkaConsoleReporter.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   registry.asInstanceOf[com.codahale.metrics.MetricRegistry]
[warn]   extends ScheduledReporter(registry.asInstanceOf[MetricRegistry], "akka-console-reporter", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.NANOSECONDS) {
[warn]                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\reporter\AkkaConsoleReporter.scala:44: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   metrics.isEmpty.unary_!
[info]     if (!metrics.isEmpty) {
[info]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-testkit\src\test\scala\akka\testkit\metrics\reporter\AkkaConsoleReporter.scala:43: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val clazz: scala.reflect.ClassTag[T] = _).
[warn]   def printMetrics[T <: Metric](metrics: Iterable[(String, T)], printer: T ? Unit)(implicit clazz: ClassTag[T]) {
[warn]       ^
[info] [warn] [scapegoat] Analysis complete: 23 files - 0 errors 43 warns 7 infos
[warn] there were 7 deprecation warnings; re-run with -deprecation for details
[warn] 42 warnings found
[info] Compiling 1 Scala source to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-marshallers-scala\akka-http-xml\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-marshallers-scala\akka-http-xml\src\main\scala\akka\http\scaladsl\marshallers\xml\ScalaXmlSupport.scala:58: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: org.xml.sax.SAXNotRecognizedException)) => ()
[warn]       case e: org.xml.sax.SAXNotRecognizedException ? // property is not needed
[warn]            ^
[info] [warn] [scapegoat] Analysis complete: 1 files - 0 errors 1 warns 0 infos
[warn] one warning found
[info] Compiling 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-marshallers-java\akka-http-jackson\target\classes...
[info] Compiling 2 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-marshallers-scala\akka-http-spray-json\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[info] [info] [scapegoat] Analysis complete: 2 files - 0 errors 0 warns 0 infos
[info] Compiling 15 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\JUnitRouteTest.scala:46: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   block

[warn] } catch {

[warn]   case (t @ (_: Throwable)) => throw new java.this.lang.AssertionError(t.getMessage().+("\n").+("  Request was:      ").+(request).+("\n").+("  Route result was: ").+(result).+("\n"), t)

[warn] }
[warn]         try block catch {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\JUnitRouteTest.scala:70: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var _system: ActorSystem = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\JUnitRouteTest.scala:71: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private[this] var _materializer: ActorMaterializer = null
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\JUnitRouteTest.scala:80: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _system = null
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\JUnitRouteTest.scala:81: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     _materializer = null
[warn]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\TestRouteResult.scala:35: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def _response = _result match {
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\TestRouteResult.scala:40: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   private def _rejections = _result match {
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\TestRouteResult.scala:221: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   expectedRejections.toSeq
[warn]     if (rejections.asScala == expectedRejections.toSeq) {
[warn]                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\WSTestRequestBuilding.scala:20: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def WS(uri: Uri, clientSideHandler: Flow[Message, Message, Any], materializer: Materializer): HttpRequest = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\javadsl\testkit\WSTestRequestBuilding.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def WS(
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\MarshallingTestUtils.scala:30: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   fut.value.get
[warn]     fut.value.get
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\MarshallingTestUtils.scala:25: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MarshallingTestUtils.this.unmarshal[T](entity)(evidence$3, ec, mat).get
[warn]     unmarshal(entity).get
[warn]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTest.scala:133: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class DefaultHostInfo(host: Host, securedConnection: Boolean)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTest.scala:150: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]                                  exceptionHandler: ExceptionHandler = null) =
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTest.scala:52: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new scala.util.DynamicVariable[RouteTest.this.RouteTestResult](null)
[warn]   private val dynRR = new DynamicVariable[RouteTestResult](null)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTest.scala:54: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   RouteTest.this.dynRR.value.ne(null)
[warn]     if (dynRR.value ne null) dynRR.value
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTest.scala:59: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   RouteTest.this.dynRR.value.ne(null)
[warn]   private def responseSafe = if (dynRR.value ne null) dynRR.value.response else "<not available anymore>"
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTest.scala:94: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   r.head
[warn]     if (r.size == 1) r.head else failTest("Expected a single rejection but got %s (%s)".format(r.size, r))
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTest.scala:147: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   implicit val materializer: akka.stream.Materializer = _
[warn]                                  materializer:     Materializer,
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTestResultComponent.scala:30: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RouteTestResult.this.result.get
[warn]     def handled: Boolean = synchronized { result.isDefined && result.get.isRight }
[warn]                                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\RouteTestTimeout.scala:11: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class RouteTestTimeout(duration: FiniteDuration)
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\WSProbe.scala:143: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   akka.http.impl.util.`package`.AddFutureAwaitResult[scala.collection.immutable.Seq[T]](stream.grouped(maxChunks).runWith[scala.concurrent.Future[scala.collection.immutable.Seq[T]]](akka.stream.scaladsl.Sink.head[scala.collection.immutable.Seq[T]])(materializer)).awaitResult(scala.concurrent.duration.`package`.DurationLong(maxChunkCollectionMills).millis).reduce
[warn]           .reduce(reduce)
[warn]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-http-testkit\src\main\scala\akka\http\scaladsl\testkit\WSTestRequestBuilding.scala:16: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def WS(uri: Uri, clientSideHandler: Flow[Message, Message, Any], subprotocols: Seq[String] = Nil)(implicit materializer: Materializer): HttpRequest =
[info]       ^
[info] [warn] [scapegoat] Analysis complete: 15 files - 0 errors 16 warns 7 infos
[warn] 16 warnings found
[info] Compiling 10 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsCollector.scala:71: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Collection started.").s()
[warn]       log.debug(s"Collection started.")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsCollector.scala:74: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Collection stopped.").s()
[warn]       log.debug(s"Collection stopped.")
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsCollector.scala:189: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def postStop: Unit = {

[warn]   ClusterMetricsCollector.this.cluster.unsubscribe(ClusterMetricsCollector.this.self);

[warn]   ClusterMetricsCollector.this.gossipTask.cancel();

[warn]   ClusterMetricsCollector.this.sampleTask.cancel();

[warn]   ClusterMetricsCollector.this.collector.close()

[warn] }
[warn]   override def postStop: Unit = {
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsExtension.scala:85: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.cluster.metrics.ClusterMetricsExtension = ClusterMetricsExtension.super.get(system)
[info]   override def get(system: ActorSystem): ClusterMetricsExtension = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsRouting.scala:154: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   routingLogic.asInstanceOf[akka.cluster.metrics.AdaptiveLoadBalancingRoutingLogic]
[warn]       routingLogic.asInstanceOf[AdaptiveLoadBalancingRoutingLogic]))
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsRouting.scala:234: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   routingLogic.asInstanceOf[akka.cluster.metrics.AdaptiveLoadBalancingRoutingLogic]
[warn]       routingLogic.asInstanceOf[AdaptiveLoadBalancingRoutingLogic]))
[warn]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsRouting.scala:48: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   @tailrec final def metricsChanged(event: ClusterMetricsChanged): Unit = {
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsRouting.scala:434: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   capacity.minBy
[warn]       val (_, min) = capacity.minBy { case (_, c) ? c }
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsRouting.scala:395: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   dynamicAccess.createInstanceFor[akka.cluster.metrics.MetricsSelector](fqn, args)((ClassTag.apply[akka.cluster.metrics.MetricsSelector](classOf[akka.cluster.metrics.MetricsSelector]): scala.reflect.ClassTag[akka.cluster.metrics.MetricsSelector])).recover[akka.cluster.metrics.MetricsSelector](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => Nothing> = {

[warn]  
[warn]         }).get
[warn]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\ClusterMetricsSettings.scala:17: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class ClusterMetricsSettings(config: Config) {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\EWMA.scala:40: [scapegoat] Floating type comparison
[warn]   Due to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.
[warn]     if (newValue == value) this // no change
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Metric.scala:164: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HeapMemory.this.max.get
[warn]     require(max.isEmpty || max.get > 0L, "max heap expected to be > 0 bytes")
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\MetricsCollector.scala:62: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       system.asInstanceOf[ExtendedActorSystem].dynamicAccess
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\MetricsCollector.scala:232: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SigarMetricsCollector.this.sigar.getLoadAverage().apply(0).asInstanceOf[Number]
[warn]     value = sigar.getLoadAverage()(0).asInstanceOf[Number],
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\MetricsCollector.scala:247: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   cpuPerc.getCombined().asInstanceOf[Number]
[warn]     value = cpuPerc.getCombined.asInstanceOf[Number],
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\MetricsCollector.scala:259: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   cpuPerc.getStolen().asInstanceOf[Number]
[warn]     value = cpuPerc.getStolen.asInstanceOf[Number],
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\MetricsCollector.scala:270: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   cpuPerc.getIdle().asInstanceOf[Number]
[warn]     value = cpuPerc.getIdle.asInstanceOf[Number],
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\MetricsCollector.scala:63: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem].dynamicAccess.createInstanceFor[akka.cluster.metrics.MetricsCollector](provider, immutable.this.List.apply[(Class[akka.actor.ActorSystem], akka.actor.ActorSystem)](scala.this.Predef.ArrowAssoc[Class[akka.actor.ActorSystem]](classOf[akka.actor.ActorSystem]).→[akka.actor.ActorSystem](system)))((ClassTag.apply[akka.cluster.metrics.MetricsCollector](classOf[akka.cluster.metrics.MetricsCollector]): scala.reflect.ClassTag[akka.cluster.metrics.Metrics
[warn]         .createInstanceFor[MetricsCollector](provider, List(classOf[ActorSystem] → system)).get
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\MetricsCollector.scala:75: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   collector.recover[akka.cluster.metrics.MetricsCollector](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => Nothing> = {

[warn]       $anonfun.super.<init>();

[warn]       ()

[warn]     };

[warn]     final override def applyOrElse[A1 <: Throwable, B1](x1: A1, default: A1 => B1): B1 = ((x1.asInstanceOf[Throwable]: Throwable): Throwable @unchecked) match {

[warn]       case (e @ _) => th
[warn]     }.get
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Provision.scala:84: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sigar.asInstanceOf[org.hyperic.sigar.Sigar]
[warn]     if (sigar.isInstanceOf[Sigar]) sigar.asInstanceOf[Sigar].close()
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Provision.scala:37: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   val sigar: org.hyperic.sigar.SigarProxy = SigarProvider.this.verifiedSigarInstance;

[warn]   SigarProvider.close(sigar);

[warn]   true

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => false

[warn] }
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Provision.scala:100: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   scala.util.Success.apply[T](r)

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => scala.util.Failure.apply[Nothing](e)

[warn] }
[warn]     try Success(r) catch {
[warn]     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Provision.scala:91: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class DefaultSigarProvider(settings: ClusterMetricsSettings) extends SigarProvider {
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Provision.scala:84: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sigar.isInstanceOf[org.hyperic.sigar.Sigar]
[warn]     if (sigar.isInstanceOf[Sigar]) sigar.asInstanceOf[Sigar].close()
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\Provision.scala:72: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   TryNative.apply[org.hyperic.sigar.SigarProxy](SigarProvider.this.verifiedSigarInstance).orElse[org.hyperic.sigar.SigarProxy](TryNative.apply[org.hyperic.sigar.SigarProxy]({

[warn]   SigarProvider.this.provisionSigarLibrary();

[warn]   SigarProvider.this.verifiedSigarInstance

[warn] })).recover[org.hyperic.sigar.SigarProxy](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Throwable,Nothing] with Serializable {

[warn]     def <init>(): <$anon: Throwable => 
[warn]     } get
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\protobuf\MessageSerializer.scala:185: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   obj.asInstanceOf[Number]
[warn]           obj.asInstanceOf[jl.Number]
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\protobuf\MessageSerializer.scala:80: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var protocolCache: String = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-metrics\src\main\scala\akka\cluster\metrics\protobuf\MessageSerializer.scala:82: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var systemCache: String = null
[warn]               ^
[info] [warn] [scapegoat] Analysis complete: 10 files - 0 errors 24 warns 4 infos
[warn] 24 warnings found
[info] Compiling 20 Scala sources and 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\DistributedData.scala:15: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.cluster.ddata.DistributedData = DistributedData.super.get(system)
[info]   override def get(system: ActorSystem): DistributedData = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\FastMerge.scala:24: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   private var ancestor: FastMerge = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\FastMerge.scala:29: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     this.ancestor = null // only one level, for GC
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\FastMerge.scala:39: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     ancestor = null
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\GCounter.scala:82: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   delta.==(0)
[warn]     if (delta == 0) this
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\GSet.scala:8: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GSet.this._empty.asInstanceOf[akka.cluster.ddata.GSet[A]]
[warn]   def empty[A]: GSet[A] = _empty.asInstanceOf[GSet[A]]
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWMap.scala:11: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LWWMap.this._empty.asInstanceOf[akka.cluster.ddata.LWWMap[A]]
[warn]   def empty[A]: LWWMap[A] = _empty.asInstanceOf[LWWMap[A]]
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWMap.scala:153: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   LWWMap.this.underlying.==(other.underlying)
[warn]     case other: LWWMap[_] ? underlying == other.underlying
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:30: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LWWRegister.this._defaultClock.asInstanceOf[akka.cluster.ddata.LWWRegister.Clock[A]]
[warn]   def defaultClock[A]: Clock[A] = _defaultClock.asInstanceOf[Clock[A]]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:41: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LWWRegister.this._reverseClock.asInstanceOf[akka.cluster.ddata.LWWRegister.Clock[A]]
[warn]   def reverseClock[A]: Clock[A] = _reverseClock.asInstanceOf[Clock[A]]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:159: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   LWWRegister.this.value.==(other.value)
[warn]       timestamp == other.timestamp && value == other.value && node == other.node
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:116: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val clock: akka.cluster.ddata.LWWRegister.Clock[A] = LWWRegister.defaultClock[A]).
[warn]   def withValue(value: A)(implicit node: Cluster, clock: Clock[A] = defaultClock[A]): LWWRegister[A] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:116: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val value: A = _
[warn]   def withValue(value: A)(implicit node: Cluster, clock: Clock[A] = defaultClock[A]): LWWRegister[A] =
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:116: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   implicit val node: akka.cluster.Cluster = _
[warn]   def withValue(value: A)(implicit node: Cluster, clock: Clock[A] = defaultClock[A]): LWWRegister[A] =
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:122: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val node: akka.cluster.Cluster = _
[warn]   def withValue(node: Cluster, value: A): LWWRegister[A] =
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:122: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val value: A = _
[warn]   def withValue(node: Cluster, value: A): LWWRegister[A] =
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:133: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val node: akka.cluster.Cluster = _
[warn]   def withValue(node: Cluster, value: A, clock: Clock[A]): LWWRegister[A] =
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:133: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val value: A = _
[warn]   def withValue(node: Cluster, value: A, clock: Clock[A]): LWWRegister[A] =
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:144: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val node: akka.cluster.UniqueAddress = _
[warn]   private[akka] def withValue(node: UniqueAddress, value: A, clock: Clock[A]): LWWRegister[A] =
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\LWWRegister.scala:144: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val value: A = _
[warn]   private[akka] def withValue(node: UniqueAddress, value: A, clock: Clock[A]): LWWRegister[A] =
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMap.scala:12: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ORMap.this._empty.asInstanceOf[akka.cluster.ddata.ORMap[A]]
[warn]   def empty[A <: ReplicatedData]: ORMap[A] = _empty.asInstanceOf[ORMap[A]]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMap.scala:167: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   thisValue.merge(thatValue.asInstanceOf[thisValue.T]).asInstanceOf[A]
[warn]           val mergedValue = thisValue.merge(thatValue.asInstanceOf[thisValue.T]).asInstanceOf[A]
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMap.scala:191: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   data.prune(removedNode, collapseInto).asInstanceOf[A]
[warn]         acc.updated(key, data.prune(removedNode, collapseInto).asInstanceOf[A])
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMap.scala:201: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   data.pruningCleanup(removedNode).asInstanceOf[A]
[warn]         acc.updated(key, data.pruningCleanup(removedNode).asInstanceOf[A])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMap.scala:161: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   thisValue.getClass().!=(thatValue.getClass())
[warn]           if (thisValue.getClass != thatValue.getClass) {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMap.scala:212: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   ORMap.this.values.==(other.values)
[warn]     case other: ORMap[_] ? keys == other.keys && values == other.values
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMap.scala:97: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   value.isInstanceOf[akka.cluster.ddata.ORSet[_]]
[warn]     if (value.isInstanceOf[ORSet[_]] && values.contains(key))
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMultiMap.scala:14: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ORMultiMap.this._empty.asInstanceOf[akka.cluster.ddata.ORMultiMap[A]]
[warn]   def empty[A]: ORMultiMap[A] = _empty.asInstanceOf[ORMultiMap[A]]
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORMultiMap.scala:221: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   ORMultiMap.this.underlying.==(other.underlying)
[warn]     case other: ORMultiMap[_] ? underlying == other.underlying
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:14: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ORSet.this._empty.asInstanceOf[akka.cluster.ddata.ORSet[A]]
[warn]   def empty[A]: ORSet[A] = _empty.asInstanceOf[ORSet[A]]
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:347: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   ORSet.this.elementsMap.==(other.elementsMap)
[warn]     case other: ORSet[_] ? vvector == other.vvector && elementsMap == other.elementsMap
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:260: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val node: akka.cluster.UniqueAddress = _).
[warn]   private[akka] def remove(node: UniqueAddress, element: A): ORSet[A] =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:273: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val node: akka.cluster.UniqueAddress = _).
[warn]   private[akka] def clear(node: UniqueAddress): ORSet[A] =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:339: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val elementsMap: Map[A,akka.cluster.ddata.ORSet.Dot] = this.elementsMap
[warn]   private def copy(elementsMap: Map[A, ORSet.Dot] = this.elementsMap, vvector: VersionVector = this.vvector): ORSet[A] =
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ORSet.scala:339: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val vvector: akka.cluster.ddata.VersionVector = this.vvector
[warn]   private def copy(elementsMap: Map[A, ORSet.Dot] = this.elementsMap, vvector: VersionVector = this.vvector): ORSet[A] =
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\PNCounter.scala:110: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val increments: akka.cluster.ddata.GCounter = this.increments
[warn]   private def copy(increments: GCounter = this.increments, decrements: GCounter = this.decrements): PNCounter =
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\PNCounter.scala:110: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val decrements: akka.cluster.ddata.GCounter = this.decrements
[warn]   private def copy(increments: GCounter = this.increments, decrements: GCounter = this.decrements): PNCounter =
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\ReplicatedData.scala:55: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   that.asInstanceOf[D]
[warn]     mergeData(that.asInstanceOf[D])
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:245: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GetSuccess.this.data.asInstanceOf[T]
[warn]       data.asInstanceOf[T]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:295: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Changed.this.data.asInstanceOf[T]
[warn]       data.asInstanceOf[T]
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:522: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DataEnvelope.this.cleaned(otherData, DataEnvelope.this.pruning).asInstanceOf[DataEnvelope.this.data.T]
[warn]         else copy(data = data merge cleaned(otherData, pruning).asInstanceOf[data.T])
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:244: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   key.==(this.key)
[warn]       require(key == this.key, "wrong key used, must use contained key")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:294: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   key.==(this.key)
[warn]       require(key == this.key, "wrong key used, must use contained key")
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:905: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   existing.getClass().==(writeEnvelope.data.getClass())
[warn]         if (existing.getClass == writeEnvelope.data.getClass || writeEnvelope.data == DeletedData) {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:415: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class DataDeleted[A <: akka.cluster.ddata.ReplicatedData] extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with akka.cluster.ddata.Replicator.DeleteResponse[A] with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val key: akka.cluster.ddata.Key[A] = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def key: akka.cluster.ddata.Key[A] = DataDeleted.this.key;

[warn]   def <init>(key: akka.cluster.ddata.Key[A]): akka.cluster.ddata.
[warn]   final case class DataDeleted[A <: ReplicatedData](key: Key[A])
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:1059: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Replicator.this.getData(k).get
[warn]       val g = Gossip(keys.map(k ? k → getData(k).get)(collection.breakOut), sendBack = otherDifferentKeys.nonEmpty)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:104: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: String = _
[warn]   def withRole(role: String): ReplicatorSettings = copy(role = ReplicatorSettings.roleOption(role))
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:106: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = _
[warn]   def withRole(role: Option[String]): ReplicatorSettings = copy(role = role)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:108: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val gossipInterval: scala.concurrent.duration.FiniteDuration = _
[warn]   def withGossipInterval(gossipInterval: FiniteDuration): ReplicatorSettings =
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:111: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val notifySubscribersInterval: scala.concurrent.duration.FiniteDuration = _
[warn]   def withNotifySubscribersInterval(notifySubscribersInterval: FiniteDuration): ReplicatorSettings =
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:114: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxDeltaElements: Int = _
[warn]   def withMaxDeltaElements(maxDeltaElements: Int): ReplicatorSettings =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:117: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val dispatcher: String = _
[warn]   def withDispatcher(dispatcher: String): ReplicatorSettings = {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:125: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val pruningInterval: scala.concurrent.duration.FiniteDuration = _
[warn]   def withPruning(pruningInterval: FiniteDuration, maxPruningDissemination: FiniteDuration): ReplicatorSettings =
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:125: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxPruningDissemination: scala.concurrent.duration.FiniteDuration = _
[warn]   def withPruning(pruningInterval: FiniteDuration, maxPruningDissemination: FiniteDuration): ReplicatorSettings =
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:129: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = role
[warn]     role:                      Option[String] = role,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:130: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val gossipInterval: scala.concurrent.duration.FiniteDuration = gossipInterval
[warn]     gossipInterval:            FiniteDuration = gossipInterval,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:131: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val notifySubscribersInterval: scala.concurrent.duration.FiniteDuration = notifySubscribersInterval
[warn]     notifySubscribersInterval: FiniteDuration = notifySubscribersInterval,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:132: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxDeltaElements: Int = maxDeltaElements
[warn]     maxDeltaElements:          Int            = maxDeltaElements,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:133: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val dispatcher: String = dispatcher
[warn]     dispatcher:                String         = dispatcher,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:134: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val pruningInterval: scala.concurrent.duration.FiniteDuration = pruningInterval
[warn]     pruningInterval:           FiniteDuration = pruningInterval,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:135: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxPruningDissemination: scala.concurrent.duration.FiniteDuration = maxPruningDissemination
[warn]     maxPruningDissemination:   FiniteDuration = maxPruningDissemination): ReplicatorSettings =
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:243: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val key: akka.cluster.ddata.Key[T] = _
[warn]     def get[T <: ReplicatedData](key: Key[T]): T = {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\Replicator.scala:293: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val key: akka.cluster.ddata.Key[T] = _
[warn]     def get[T <: ReplicatedData](key: Key[T]): T = {
[warn]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\VersionVector.scala:11: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.cluster.UniqueAddress
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\VersionVector.scala:54: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def AfterInstance = After
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\VersionVector.scala:59: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def BeforeInstance = Before
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\VersionVector.scala:64: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def SameInstance = Same
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\VersionVector.scala:69: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def ConcurrentInstance = Concurrent
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\VersionVector.scala:81: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   scala.Tuple2.apply[Null, Long](null, -9223372036854775808L)
[warn]   private val cmpEndMarker = (null, Timestamp.EndMarker)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:175: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   orset.asInstanceOf[akka.cluster.ddata.ORSet[Any]]
[warn]     orsetToProtoImpl(orset.asInstanceOf[ORSet[Any]])
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:344: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatedDataSerializer.this.otherMessageFromProto(entry.getValue()).asInstanceOf[akka.cluster.ddata.ReplicatedData]
[warn]       entry.getKey → otherMessageFromProto(entry.getValue).asInstanceOf[ReplicatedData]).toMap
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:346: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatedDataSerializer.this.orsetFromProto(ormap.getKeys()).asInstanceOf[akka.cluster.ddata.ORSet[String]]
[warn]       keys = orsetFromProto(ormap.getKeys).asInstanceOf[ORSet[String]],
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:366: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatedDataSerializer.this.orsetFromProto(lwwmap.getKeys()).asInstanceOf[akka.cluster.ddata.ORSet[String]]
[warn]       keys = orsetFromProto(lwwmap.getKeys).asInstanceOf[ORSet[String]],
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:386: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatedDataSerializer.this.orsetFromProto(pncountermap.getKeys()).asInstanceOf[akka.cluster.ddata.ORSet[String]]
[warn]       keys = orsetFromProto(pncountermap.getKeys).asInstanceOf[ORSet[String]],
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializer.scala:406: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatedDataSerializer.this.orsetFromProto(multimap.getKeys()).asInstanceOf[akka.cluster.ddata.ORSet[String]]
[warn]       keys = orsetFromProto(multimap.getKeys).asInstanceOf[ORSet[String]],
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:66: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[B]
[warn]         if (end - i == 0) null.asInstanceOf[B]
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:290: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(get.getKey()).asInstanceOf[akka.cluster.ddata.Key.KeyR]
[warn]     val key = otherMessageFromProto(get.getKey).asInstanceOf[KeyR]
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:313: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(getSuccess.getKey()).asInstanceOf[akka.cluster.ddata.Key.KeyR]
[warn]     val key = otherMessageFromProto(getSuccess.getKey).asInstanceOf[KeyR]
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:315: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(getSuccess.getData()).asInstanceOf[akka.cluster.ddata.ReplicatedData]
[warn]     val data = otherMessageFromProto(getSuccess.getData).asInstanceOf[ReplicatedData]
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:328: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(notFound.getKey()).asInstanceOf[akka.cluster.ddata.Key.KeyR]
[warn]     val key = otherMessageFromProto(notFound.getKey).asInstanceOf[KeyR]
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:341: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(getFailure.getKey()).asInstanceOf[akka.cluster.ddata.Key.KeyR]
[warn]     val key = otherMessageFromProto(getFailure.getKey).asInstanceOf[KeyR]
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:353: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(subscribe.getKey()).asInstanceOf[akka.cluster.ddata.Key.KeyR]
[warn]     val key = otherMessageFromProto(subscribe.getKey).asInstanceOf[KeyR]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:365: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(unsubscribe.getKey()).asInstanceOf[akka.cluster.ddata.Key.KeyR]
[warn]     val key = otherMessageFromProto(unsubscribe.getKey).asInstanceOf[KeyR]
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:377: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(changed.getData()).asInstanceOf[akka.cluster.ddata.ReplicatedData]
[warn]     val data = otherMessageFromProto(changed.getData).asInstanceOf[ReplicatedData]
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:378: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(changed.getKey()).asInstanceOf[akka.cluster.ddata.Key.KeyR]
[warn]     val key = otherMessageFromProto(changed.getKey).asInstanceOf[KeyR]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:415: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializer.this.otherMessageFromProto(dataEnvelope.getData()).asInstanceOf[akka.cluster.ddata.ReplicatedData]
[warn]     val data = otherMessageFromProto(dataEnvelope.getData).asInstanceOf[ReplicatedData]
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:99: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   c.ne(null)
[warn]       if (c ne null)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:111: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   c2.ne(null)
[warn]           if (c2 ne null) c2 // found it
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializer.scala:128: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SmallCache.this.elements.update(i, null)
[warn]           elements(i) = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\SerializationSupport.scala:112: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.asInstanceOf[AnyRef]
[warn]       val m = msg.asInstanceOf[AnyRef]
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\SerializationSupport.scala:140: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def otherMessageFromBinary(bytes: Array[Byte]): AnyRef = SerializationSupport.this.otherMessageFromProto(akka.cluster.ddata.protobuf.msg.ReplicatorMessages.OtherMessage.parseFrom(bytes))
[warn]   def otherMessageFromBinary(bytes: Array[Byte]): AnyRef =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\SerializationSupport.scala:143: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def otherMessageFromProto(other: akka.cluster.ddata.protobuf.msg.ReplicatorMessages.OtherMessage): AnyRef = {

[warn]   val manifest: String = if (other.hasMessageManifest())

[warn]     other.getMessageManifest().toStringUtf8()

[warn]   else

[warn]     "";

[warn]   SerializationSupport.this.serialization.deserialize(other.getEncl
[warn]   def otherMessageFromProto(other: dm.OtherMessage): AnyRef = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\SerializationSupport.scala:35: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SerializationSupport.this.ser.==(null)
[warn]     if (ser == null) ser = SerializationExtension(system)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\SerializationSupport.scala:42: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SerializationSupport.this.protocol.==(null)
[warn]     if (protocol == null) protocol = system.provider.getDefaultAddress.protocol
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\SerializationSupport.scala:49: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SerializationSupport.this.transportInfo.==(null)
[warn]     if (transportInfo == null) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\SerializationSupport.scala:134: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   akka.serialization.Serialization.currentTransportInformation.value.==(null)
[warn]     if (Serialization.currentTransportInformation.value == null)
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\main\scala\akka\cluster\ddata\protobuf\SerializationSupport.scala:148: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SerializationSupport.this.serialization.deserialize(other.getEnclosedMessage().toByteArray(), other.getSerializerId(), manifest).get
[warn]       manifest).get
[warn]                 ^
[info] [warn] [scapegoat] Analysis complete: 20 files - 0 errors 93 warns 6 infos
[warn] 91 warnings found
[info] Compiling 8 Scala sources and 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:493: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.cluster.client.ClusterClientReceptionist = ClusterClientReceptionist.super.get(system)
[info]   override def get(system: ActorSystem): ClusterClientReceptionist = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:137: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val initialContacts: Set[akka.actor.ActorPath] = _
[warn]   def withInitialContacts(initialContacts: Set[ActorPath]): ClusterClientSettings = {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:145: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val initialContacts: java.util.Set[akka.actor.ActorPath] = _
[warn]   def withInitialContacts(initialContacts: java.util.Set[ActorPath]): ClusterClientSettings = {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:150: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val establishingGetContactsInterval: scala.concurrent.duration.FiniteDuration = _
[warn]   def withEstablishingGetContactsInterval(establishingGetContactsInterval: FiniteDuration): ClusterClientSettings =
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:153: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val refreshContactsInterval: scala.concurrent.duration.FiniteDuration = _
[warn]   def withRefreshContactsInterval(refreshContactsInterval: FiniteDuration): ClusterClientSettings =
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:156: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val heartbeatInterval: scala.concurrent.duration.FiniteDuration = _
[warn]   def withHeartbeat(heartbeatInterval: FiniteDuration, acceptableHeartbeatPause: FiniteDuration): ClusterClientSettings =
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:156: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val acceptableHeartbeatPause: scala.concurrent.duration.FiniteDuration = _
[warn]   def withHeartbeat(heartbeatInterval: FiniteDuration, acceptableHeartbeatPause: FiniteDuration): ClusterClientSettings =
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:159: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val bufferSize: Int = _
[warn]   def withBufferSize(bufferSize: Int): ClusterClientSettings =
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:162: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val reconnectTimeout: Option[scala.concurrent.duration.FiniteDuration] = _
[warn]   def withReconnectTimeout(reconnectTimeout: Option[FiniteDuration]): ClusterClientSettings =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:166: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val initialContacts: Set[akka.actor.ActorPath] = initialContacts
[warn]     initialContacts:                 Set[ActorPath]         = initialContacts,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:167: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val establishingGetContactsInterval: scala.concurrent.duration.FiniteDuration = establishingGetContactsInterval
[warn]     establishingGetContactsInterval: FiniteDuration         = establishingGetContactsInterval,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:168: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val refreshContactsInterval: scala.concurrent.duration.FiniteDuration = refreshContactsInterval
[warn]     refreshContactsInterval:         FiniteDuration         = refreshContactsInterval,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:169: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val heartbeatInterval: scala.concurrent.duration.FiniteDuration = heartbeatInterval
[warn]     heartbeatInterval:               FiniteDuration         = heartbeatInterval,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:170: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val acceptableHeartbeatPause: scala.concurrent.duration.FiniteDuration = acceptableHeartbeatPause
[warn]     acceptableHeartbeatPause:        FiniteDuration         = acceptableHeartbeatPause,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:171: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val bufferSize: Int = bufferSize
[warn]     bufferSize:                      Int                    = bufferSize,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:172: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val reconnectTimeout: Option[scala.concurrent.duration.FiniteDuration] = reconnectTimeout
[warn]     reconnectTimeout:                Option[FiniteDuration] = reconnectTimeout): ClusterClientSettings =
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:636: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: String = _
[warn]   def withRole(role: String): ClusterReceptionistSettings = copy(role = ClusterReceptionistSettings.roleOption(role))
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:638: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = _
[warn]   def withRole(role: Option[String]): ClusterReceptionistSettings = copy(role = role)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:640: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val numberOfContacts: Int = _
[warn]   def withNumberOfContacts(numberOfContacts: Int): ClusterReceptionistSettings =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:643: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val responseTunnelReceiveTimeout: scala.concurrent.duration.FiniteDuration = _
[warn]   def withResponseTunnelReceiveTimeout(responseTunnelReceiveTimeout: FiniteDuration): ClusterReceptionistSettings =
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:689: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = role
[warn]     role:                         Option[String] = role,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:690: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val numberOfContacts: Int = numberOfContacts
[warn]     numberOfContacts:             Int            = numberOfContacts,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:691: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val responseTunnelReceiveTimeout: scala.concurrent.duration.FiniteDuration = responseTunnelReceiveTimeout
[warn]     responseTunnelReceiveTimeout: FiniteDuration = responseTunnelReceiveTimeout,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\client\ClusterClient.scala:953: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       nodes = nodes.empty union state.members.collect { case m if m.status != MemberStatus.Joining && matchingRole(m) ? m.address }
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:49: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\'consistent-hashing\' routing logic can\'t be used by the pub-sub mediator").s()
[warn]         case "consistent-hashing" ? throw new IllegalArgumentException(s"'consistent-hashing' routing logic can't be used by the pub-sub mediator")
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:93: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DistributedPubSubSettings.this.routingLogic.isInstanceOf[akka.routing.ConsistentHashingRoutingLogic]
[warn]     !routingLogic.isInstanceOf[ConsistentHashingRoutingLogic],
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:486: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DistributedPubSubMediator.this.settings.routingLogic.isInstanceOf[akka.routing.ConsistentHashingRoutingLogic]
[warn]     !routingLogic.isInstanceOf[ConsistentHashingRoutingLogic],
[warn]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:831: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.cluster.pubsub.DistributedPubSub = DistributedPubSub.super.get(system)
[info]   override def get(system: ActorSystem): DistributedPubSub = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:96: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: String = _
[warn]   def withRole(role: String): DistributedPubSubSettings = copy(role = DistributedPubSubSettings.roleOption(role))
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:98: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = _
[warn]   def withRole(role: Option[String]): DistributedPubSubSettings = copy(role = role)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:100: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val routingLogic: akka.routing.RoutingLogic = _
[warn]   def withRoutingLogic(routingLogic: RoutingLogic): DistributedPubSubSettings =
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:103: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val gossipInterval: scala.concurrent.duration.FiniteDuration = _
[warn]   def withGossipInterval(gossipInterval: FiniteDuration): DistributedPubSubSettings =
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:106: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val removedTimeToLive: scala.concurrent.duration.FiniteDuration = _
[warn]   def withRemovedTimeToLive(removedTimeToLive: FiniteDuration): DistributedPubSubSettings =
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:109: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxDeltaElements: Int = _
[warn]   def withMaxDeltaElements(maxDeltaElements: Int): DistributedPubSubSettings =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:113: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = role
[warn]     role:              Option[String] = role,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:114: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val routingLogic: akka.routing.RoutingLogic = routingLogic
[warn]     routingLogic:      RoutingLogic   = routingLogic,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:115: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val gossipInterval: scala.concurrent.duration.FiniteDuration = gossipInterval
[warn]     gossipInterval:    FiniteDuration = gossipInterval,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:116: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val removedTimeToLive: scala.concurrent.duration.FiniteDuration = removedTimeToLive
[warn]     removedTimeToLive: FiniteDuration = removedTimeToLive,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:117: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val maxDeltaElements: Int = maxDeltaElements
[warn]     maxDeltaElements:  Int            = maxDeltaElements): DistributedPubSubSettings =
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\DistributedPubSubMediator.scala:667: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       nodes = state.members.collect {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\protobuf\DistributedPubSubMessageSerializer.scala:207: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   msg.asInstanceOf[AnyRef]
[warn]     val m = msg.asInstanceOf[AnyRef]
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\pubsub\protobuf\DistributedPubSubMessageSerializer.scala:231: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DistributedPubSubMessageSerializer.this.serialization.deserialize(payload.getEnclosedMessage().toByteArray(), payload.getSerializerId(), manifest).get
[warn]       manifest).get
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:322: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   class ClusterSingletonManagerIsStuck extends akka.AkkaException {

[warn]   <paramaccessor> private[this] val message: String = _;

[warn]   def <init>(message: String): akka.cluster.singleton.ClusterSingletonManagerIsStuck = {

[warn]     ClusterSingletonManagerIsStuck.super.<init>(message, null);

[warn]     ()

[warn]   }

[warn] }
[warn] class ClusterSingletonManagerIsStuck(message: String) extends AkkaException(message, null)
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:282: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mEvent.isInstanceOf[akka.cluster.ClusterEvent.MemberExited]
[warn]         case mEvent: MemberEvent if (mEvent.isInstanceOf[MemberExited] || mEvent.isInstanceOf[MemberRemoved]) ?
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:282: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mEvent.isInstanceOf[akka.cluster.ClusterEvent.MemberRemoved]
[warn]         case mEvent: MemberEvent if (mEvent.isInstanceOf[MemberExited] || mEvent.isInstanceOf[MemberRemoved]) ?
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:302: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mEvent.isInstanceOf[akka.cluster.ClusterEvent.MemberExited]
[warn]         case mEvent: MemberEvent if (mEvent.isInstanceOf[MemberExited] || mEvent.isInstanceOf[MemberRemoved]) ?
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:302: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mEvent.isInstanceOf[akka.cluster.ClusterEvent.MemberRemoved]
[warn]         case mEvent: MemberEvent if (mEvent.isInstanceOf[MemberExited] || mEvent.isInstanceOf[MemberRemoved]) ?
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:322: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ClusterSingletonManagerIsStuck.super.<init>(message, null)
[warn] class ClusterSingletonManagerIsStuck(message: String) extends AkkaException(message, null)
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:274: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   OldestChangedBuffer.this.changes.head
[warn]         val event = changes.head
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:275: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   OldestChangedBuffer.this.changes.tail
[warn]         changes = changes.tail
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:97: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: String = _
[warn]   def withRole(role: String): ClusterSingletonManagerSettings = copy(role = ClusterSingletonManagerSettings.roleOption(role))
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:99: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = _
[warn]   def withRole(role: Option[String]) = copy(role = role)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:101: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val removalMargin: scala.concurrent.duration.FiniteDuration = _
[warn]   def withRemovalMargin(removalMargin: FiniteDuration): ClusterSingletonManagerSettings =
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:108: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val singletonName: String = singletonName
[warn]     singletonName:         String         = singletonName,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:109: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = role
[warn]     role:                  Option[String] = role,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:110: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val removalMargin: scala.concurrent.duration.FiniteDuration = removalMargin
[warn]     removalMargin:         FiniteDuration = removalMargin,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:111: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val handOverRetryInterval: scala.concurrent.duration.FiniteDuration = handOverRetryInterval
[warn]     handOverRetryInterval: FiniteDuration = handOverRetryInterval): ClusterSingletonManagerSettings =
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonManager.scala:550: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       cluster.state.members.collectFirst { case m if m.address == senderAddress ? m.uniqueAddress } match {
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:226: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mEvent.isInstanceOf[akka.cluster.ClusterEvent.MemberExited]
[warn]     case mEvent: MemberEvent if mEvent.isInstanceOf[MemberExited] || mEvent.isInstanceOf[MemberRemoved] ? remove(mEvent.member)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:226: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mEvent.isInstanceOf[akka.cluster.ClusterEvent.MemberRemoved]
[warn]     case mEvent: MemberEvent if mEvent.isInstanceOf[MemberExited] || mEvent.isInstanceOf[MemberRemoved] ? remove(mEvent.member)
[warn]                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:279: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ClusterSingletonProxy.this.singleton.get
[warn]     val target = singleton.get
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:81: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: String = _
[warn]   def withRole(role: String): ClusterSingletonProxySettings = copy(role = ClusterSingletonProxySettings.roleOption(role))
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:83: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = _
[warn]   def withRole(role: Option[String]): ClusterSingletonProxySettings = copy(role = role)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:85: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val singletonIdentificationInterval: scala.concurrent.duration.FiniteDuration = _
[warn]   def withSingletonIdentificationInterval(singletonIdentificationInterval: FiniteDuration): ClusterSingletonProxySettings =
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:88: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val bufferSize: Int = _
[warn]   def withBufferSize(bufferSize: Int): ClusterSingletonProxySettings =
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:92: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val singletonName: String = singletonName
[warn]     singletonName:                   String         = singletonName,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:93: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = role
[warn]     role:                            Option[String] = role,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:94: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val singletonIdentificationInterval: scala.concurrent.duration.FiniteDuration = singletonIdentificationInterval
[warn]     singletonIdentificationInterval: FiniteDuration = singletonIdentificationInterval,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-tools\src\main\scala\akka\cluster\singleton\ClusterSingletonProxy.scala:95: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val bufferSize: Int = bufferSize
[warn]     bufferSize:                      Int            = bufferSize): ClusterSingletonProxySettings =
[warn]     ^
[info] [warn] [scapegoat] Analysis complete: 8 files - 0 errors 73 warns 2 infos
[warn] there was one deprecation warning; re-run with -deprecation for details
[warn] 68 warnings found
[info] Compiling 11 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\target\test-classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Coroner.scala:261: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     coronerWatch = null
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Coroner.scala:151: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ids.==(null)
[warn]       if (ids == null) {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Coroner.scala:176: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ti.getLockName().!=(null)
[warn]       if (ti.getLockName != null) {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Coroner.scala:180: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ti.getLockOwnerName().!=(null)
[warn]       if (ti.getLockOwnerName != null) {
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Coroner.scala:114: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = triggerReportIfOverdue(duration)
[warn]     new Thread(new Runnable { def run = triggerReportIfOverdue(duration) }, "Coroner").start()
[warn]                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Coroner.scala:167: [scapegoat] Unnecessary return
[info]   Scala returns the value of the last expression in a block. Use of return here is not an idiomatic Scala.
[info]     def threadInfoToString(ti: ThreadInfo): String = {
[info]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Coroner.scala:86: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val duration: scala.concurrent.duration.Duration = _
[warn]     def triggerReportIfOverdue(duration: Duration): Unit = {
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\ScriptedTest.scala:186: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   ScriptRunner.this.debugLog(scala.StringContext.apply("running ", "").s(ScriptRunner.this.script));

[warn]   ScriptRunner.this.request(ScriptRunner.this.getNextDemand());

[warn]   doRun(0)

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => {

[warn]     scala.this.Predef.println(ScriptRunner.this._debugLog.mkString("S
[warn]       try {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\StreamTestDefaultMailbox.scala:18: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] private[akka] final case class StreamTestDefaultMailbox() extends MailboxType with ProducesMessageQueue[UnboundedMailbox.MessageQueue] {
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\StreamTestDefaultMailbox.scala:22: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]   final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue = {
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\StreamTestDefaultMailbox.scala:20: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\StreamTestDefaultMailbox.scala:20: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\TestUtils.scala:32: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   TestUtils.this.temporaryServerAddresses(1, address, udp).head
[warn]     temporaryServerAddresses(1, address, udp).head
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Utils.scala:28: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   probe.awaitAssert({

[warn]     impl.supervisor.tell(akka.stream.impl.StreamSupervisor.GetChildren, probe.ref);

[warn]     children = probe.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Chi
[warn]           try probe.awaitAssert {
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Utils.scala:17: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TE(message: String) extends RuntimeException(message) with NoStackTrace
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-testkit\src\test\scala\akka\stream\testkit\Utils.scala:17: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   case class TE extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val message: String = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def message: String = TE.this.message;

[warn]   def <init>(message: String): akka.stream.testkit.Utils.TE = {

[warn]     TE.super.<init>(message);

[warn]     ()

[warn]   };

[warn]   <synthetic> def copy(message: String = message): akka.stream.testkit.Utils.TE = new TE(message);
[warn]   case class TE(message: String) extends RuntimeException(message) with NoStackTrace
[warn]              ^
[info] [warn] [scapegoat] Analysis complete: 11 files - 0 errors 13 warns 4 infos
[warn] 12 warnings found
[info] Compiling 111 Scala sources and 21 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\target\test-classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorConfigurationVerificationSpec.scala:39: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def atStartup: Unit = ActorConfigurationVerificationSpec.this.system.eventStream.publish(akka.testkit.TestEvent.Mute.apply(akka.testkit.EventFilter.apply[akka.ConfigurationException]("", akka.testkit.EventFilter.apply$default$2[akka.ConfigurationException], akka.testkit.EventFilter.apply$de
[warn]   override def atStartup {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorDSLSpec.scala:191: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         val system = null // shadow the implicit system
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorLifeCycleSpec.scala:122: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def postStop: Unit = throw new scala.`package`.Exception("hurrah")
[warn]         override def postStop { throw new Exception("hurrah") }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorLookupSpec.scala:44: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorLookupSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]   val sysImpl = system.asInstanceOf[ActorSystemImpl]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorLookupSpec.scala:284: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any]({

[warn]   <artifact> val qual$32: akka.pattern.AskableActorRef = akka.pattern.`package`.ask(ActorLookupSpec.this.c2);

[warn]   <artifact> val x$91: akka.actor.ActorLookupSpec.LookupPath = ActorLookupSpec.LookupPath.apply(a.path);

[warn]   <artifact> val x$92: akka.util.Timeout = ActorLookupSpec.this.timeout;

[warn]   <artifact> val x$93: akka.actor.ActorRef = qual$32.?$default$3(x$91);

[warn]   qual$32.?(x$91)(x$92, x$93)

[warn] }, ActorLookupSpec.this.timeout.duration).asInstanceOf[akka.actor.A
[warn]       awaitCond(Await.result(c2 ? LookupPath(a.path), timeout.duration).asInstanceOf[ActorRef].isTerminated, 1 second)
[warn]                                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorLookupSpec.scala:241: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import scala.collection.JavaConverters._
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorLookupSpec.scala:148: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]       check(system.actorFor(Seq()), system.deadLetters)
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorLookupSpec.scala:258: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]             LookupElems(Seq()) → system.deadLetters,
[info]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorMailboxSpec.scala:171: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   QueueReportingActor.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]       case _ ? sender() ! context.asInstanceOf[ActorCell].mailbox.messageQueue
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorMailboxSpec.scala:321: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   q.asInstanceOf[akka.dispatch.BoundedMessageQueueSemantics]
[warn]       q.asInstanceOf[BoundedMessageQueueSemantics].pushTimeOut should ===(Duration.Zero)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorMailboxSpec.scala:16: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n    unbounded-dispatcher {\n      mailbox-type = \"akka.dispatch.UnboundedMailbox\"\n    }\n\n    bounded-dispatcher {\n      mailbox-capacity = 1000\n      mailbox-push-timeout-time = 10s\n      mailbox-type = \"akka.dispatch.BoundedMailbox\"\n    }\n\n    requiring-bounded-dispatcher {\n      mailbox-capacity = 1000\n      mailbox-push-timeout-time = 10s\n      mailbox-type = \"akka.dispatch.BoundedMailbox\"\n      mailbox-requirement = \"akka.dispatch.BoundedMessa
[warn]   val mailboxConf = ConfigFactory.parseString(s"""
[warn]                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorMailboxSpec.scala:217: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue =
[info]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorMailboxSpec.scala:185: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (i).
[warn]   class StashQueueReportingActorWithParams(i: Int, s: String) extends StashQueueReportingActor
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorMailboxSpec.scala:185: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (s).
[warn]   class StashQueueReportingActorWithParams(i: Int, s: String) extends StashQueueReportingActor
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorMailboxSpec.scala:213: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]     def this(settings: ActorSystem.Settings, config: Config) = this(
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:269: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorRefSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val esys = system.asInstanceOf[ExtendedActorSystem]
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:325: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorRefSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       val sysImpl = system.asInstanceOf[ActorSystemImpl]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:115: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   val r: akka.actor.Actor = f;

[warn]   to.success(r);

[warn]   r

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => {

[warn]     to.failure(e);

[warn]     throw e

[warn]   }

[warn] }
[warn]   def promiseIntercept(f: ? Actor)(to: Promise[Actor]): Actor = try {
[warn]                                                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:301: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import java.io._
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:320: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import java.io._
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:287: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   a.isInstanceOf[akka.actor.ActorRefWithCell]
[warn]         a.isInstanceOf[ActorRefWithCell] should ===(true)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:288: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   readA.isInstanceOf[akka.actor.ActorRefWithCell]
[warn]         readA.isInstanceOf[ActorRefWithCell] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:294: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   readA.isInstanceOf[akka.actor.ActorRefWithCell]
[warn]       readA.isInstanceOf[ActorRefWithCell] should ===(true)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorRefSpec.scala:23: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var replyTo: ActorRef = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSelectionSpec.scala:45: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorSelectionSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]   val sysImpl = system.asInstanceOf[ActorSystemImpl]
[warn]                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSelectionSpec.scala:242: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import scala.collection.JavaConverters._
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSelectionSpec.scala:287: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.actor.ActorRef]()
[info]       val actors = Set() ++ receiveWhile(messages = 2) {
[info]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:129: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorSystemSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       system.asInstanceOf[ActorSystemImpl].internalCallingThreadExecutionContext.getClass.getName should ===("scala.concurrent.Future$InternalCallbackExecutor$")
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:205: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorSystem.apply().asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       val system = ActorSystem().asInstanceOf[ActorSystemImpl]
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:259: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]           println(system.asInstanceOf[ExtendedActorSystem].printTree)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:264: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.asInstanceOf[akka.actor.ActorRefWithCell]
[warn]       created filter (ref ? !ref.isTerminated && !ref.asInstanceOf[ActorRefWithCell].underlying.isInstanceOf[UnstartedCell]) should ===(Seq.empty[ActorRef])
[warn]                                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:230: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:264: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref.asInstanceOf[akka.actor.ActorRefWithCell].underlying.isInstanceOf[akka.actor.UnstartedCell]
[warn]       created filter (ref ? !ref.isTerminated && !ref.asInstanceOf[ActorRefWithCell].underlying.isInstanceOf[UnstartedCell]) should ===(Seq.empty[ActorRef])
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:140: [scapegoat] Looks like interpolated String
[warn]   Did you forget to prefix this string with an s, f or raw to interpolate it?
[warn]           "hallo$welt",
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:45: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Waves.this.master.ne(null)
[warn]       if (master ne null) {
[warn]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:26: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.actor.ActorRef]()
[info]     var terminaters = Set[ActorRef]()
[info]                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:31: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.actor.ActorRef]()
[info]         terminaters = Set() ++ (for (i ← 1 to n) yield {
[info]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorSystemSpec.scala:258: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   created.last
[warn]           println(created.last)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithBoundedStashSpec.scala:87: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def atStartup: Unit = ActorWithBoundedStashSpec.this.system.eventStream.publish(akka.testkit.TestEvent.Mute.apply({

[warn]   <artifact> val x$1: String = ".*received dead letter from.*hello.*";

[warn]   <artifact> val x$2: String = akka.testkit.EventFilter.warning$default$1;

[warn]   <artifact> val x$3: Stri
[warn]   override def atStartup: Unit = {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithBoundedStashSpec.scala:55: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class Bounded10(settings: Settings, config: Config) extends BoundedDequeBasedMailbox(10, 500 millis)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithBoundedStashSpec.scala:55: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class Bounded10(settings: Settings, config: Config) extends BoundedDequeBasedMailbox(10, 500 millis)
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithBoundedStashSpec.scala:57: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class Bounded100(settings: Settings, config: Config) extends BoundedDequeBasedMailbox(100, 500 millis)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithBoundedStashSpec.scala:57: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class Bounded100(settings: Settings, config: Config) extends BoundedDequeBasedMailbox(100, 500 millis)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithStashSpec.scala:93: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var expectedException: TestLatch = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithStashSpec.scala:107: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def atStartup: Unit = ActorWithStashSpec.this.system.eventStream.publish(akka.testkit.TestEvent.Mute.apply(akka.testkit.EventFilter.apply[Exception]("Crashing...", akka.testkit.EventFilter.apply$default$2[Exception], akka.testkit.EventFilter.apply$default$3[Exception], akka.testkit.EventFil
[warn]   override def atStartup {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\ActorWithStashSpec.scala:56: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]         context.become {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeathWatchSpec.scala:184: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DeathWatchSpec.this.testActor.asInstanceOf[akka.actor.InternalActorRef]
[warn]       testActor.asInstanceOf[InternalActorRef]
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeathWatchSpec.scala:113: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val supervisor: akka.actor.ActorRef = DeathWatchSpec.this.system.actorOf(Props.apply[akka.actor.Supervisor](new Supervisor(OneForOneStrategy.apply(2, OneForOneStrategy.apply$default$2, OneForOneStrate
[warn]         val supervisor = system.actorOf(Props(new Supervisor(
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeathWatchSpec.scala:140: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val supervisor: akka.actor.ActorRef = DeathWatchSpec.this.system.actorOf(Props.apply[akka.actor.Supervisor](new Supervisor(strategy))((ClassTag.apply[akka.actor.Supervisor](classOf[akka.actor.Supervis
[warn]         val supervisor = system.actorOf(Props(new Supervisor(strategy)).withDeploy(Deploy.local))
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:83: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DeployerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val deployment = system.asInstanceOf[ExtendedActorSystem].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:97: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DeployerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val deployment = system.asInstanceOf[ExtendedActorSystem].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:103: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DeployerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val deployment = system.asInstanceOf[ExtendedActorSystem].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:117: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DeployerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val deployment = system.asInstanceOf[ExtendedActorSystem].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:203: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DeployerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val mapping = system.asInstanceOf[ExtendedActorSystem].provider.deployer.routerTypeMapping
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:220: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DeployerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val deployment = system.asInstanceOf[ExtendedActorSystem].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:225: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DeployerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val deployment = system.asInstanceOf[ExtendedActorSystem].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:230: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   deployment.get.routerConfig.asInstanceOf[akka.routing.Pool]
[warn]         case pool: Pool ? deployment.get.routerConfig.asInstanceOf[Pool].resizer should ===(pool.resizer)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:88: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]           deployment.get.config,
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:108: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]           deployment.get.config,
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:122: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]           deployment.get.config,
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:227: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]       deployment.get.routerConfig.getClass should ===(expected.getClass)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:228: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]       deployment.get.scope should ===(NoScopeGiven)
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\DeployerSpec.scala:230: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]         case pool: Pool ? deployment.get.routerConfig.asInstanceOf[Pool].resizer should ===(pool.resizer)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FSMActorSpec.scala:186: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def preStart: Unit = started.countDown()
[warn]         override def preStart = { started.countDown }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FSMActorSpec.scala:81: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val from: akka.actor.FSMActorSpec.LockState = _).
[warn]     def transitionHandler(from: LockState, to: LockState) = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FSMTimingSpec.scala:226: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   StateMachine.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]         TestKit.awaitCond(context.asInstanceOf[ActorCell].mailbox.hasMessages, 1.second.dilated)
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FSMTimingSpec.scala:253: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   StateMachine.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]         TestKit.awaitCond(context.asInstanceOf[ActorCell].mailbox.hasMessages, 1.second.dilated)
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FSMTimingSpec.scala:160: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   l.resume(null)
[warn]     case l: ActorRefWithCell ? l.resume(causedByFailure = null)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FSMTimingSpec.scala:266: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]         whenUnhandled {
[warn]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FSMTransitionSpec.scala:120: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import FSM.Transition
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FunctionRefSpec.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Super.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]         val cell = context.asInstanceOf[ActorCell]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FunctionRefSpec.scala:24: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Super.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]         val cell = context.asInstanceOf[ActorCell]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FunctionRefSpec.scala:87: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FunctionRefSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val provider = system.asInstanceOf[ExtendedActorSystem].provider
[warn]                                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FunctionRefSpec.scala:13: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class GetForwarder(replyTo: ActorRef)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FunctionRefSpec.scala:14: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class DropForwarder(ref: FunctionRef)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\FunctionRefSpec.scala:15: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Forwarded(msg: Any, sender: ActorRef)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\LocalActorRefProviderSpec.scala:109: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   child.asInstanceOf[akka.actor.LocalActorRef]
[warn]       val childProps1 = child.asInstanceOf[LocalActorRef].underlying.props
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\LocalActorRefProviderSpec.scala:116: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   child.asInstanceOf[akka.actor.LocalActorRef]
[warn]         val childProps2 = child.asInstanceOf[LocalActorRef].underlying.props
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\LocalActorRefProviderSpec.scala:126: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LocalActorRefProviderSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       val impl = system.asInstanceOf[ActorSystemImpl]
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\LocalActorRefProviderSpec.scala:129: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   provider.isInstanceOf[akka.actor.LocalActorRefProvider]
[warn]       provider.isInstanceOf[LocalActorRefProvider] should ===(true)
[warn]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\LocalActorRefProviderSpec.scala:135: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[Any]()
[info]         val set = Set() ++ actors.map(a ? Await.ready(a, timeout.duration).value match {
[info]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\PropsCreationSpec.scala:23: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   new PropsCreationSpec.this.OneParamActor(null)
[warn]     override def create(): Actor = new OneParamActor(null)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\PropsCreationSpec.scala:14: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (blackhole).
[warn]   class OneParamActor(blackhole: A) extends Actor {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\PropsCreationSpec.scala:18: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (blackhole1).
[warn]   class TwoParamActor(blackhole1: A, blackhole2: B) extends Actor {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\PropsCreationSpec.scala:18: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (blackhole2).
[warn]   class TwoParamActor(blackhole1: A, blackhole2: B) extends Actor {
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\RestartStrategySpec.scala:21: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def atStartup: Unit = RestartStrategySpec.this.system.eventStream.publish(akka.testkit.TestEvent.Mute.apply(akka.testkit.EventFilter.apply[Exception]("Crashing...", akka.testkit.EventFilter.apply$default$2[Exception], akka.testkit.EventFilter.apply$default$3[Exception], akka.testkit.EventFi
[warn]   override def atStartup {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:311: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LightArrayRevolverSchedulerSpec.this.system.scheduler.asInstanceOf[akka.actor.LightArrayRevolverScheduler]
[warn]   def tickDuration = system.scheduler.asInstanceOf[LightArrayRevolverScheduler].TickDuration
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:549: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LightArrayRevolverSchedulerSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     val tf = system.asInstanceOf[ActorSystemImpl].threadFactory
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:590: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   driver.close();

[warn]   sched.close()

[warn] } catch {

[warn]   case (_: Exception) => ()

[warn] }
[warn]         try {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:562: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   $anon.this.time_=($anon.this.time.+(lbq.get() match {

[warn]     case (q @ (_: java.util.concurrent.LinkedBlockingQueue[Long])) => q.take()

[warn]     case _ => 0L

[warn]   }))

[warn] } catch {

[warn]   case (_: InterruptedException) => java.this.lang.Thread.currentThread().interrupt()

[warn] }
[warn]           try time += (lbq.get match {
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:326: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:335: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:345: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:379: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import system.dispatcher
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:402: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import driver._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:417: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import driver._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:432: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import driver._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:459: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import driver._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:489: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import driver._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:512: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import system.dispatcher
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:581: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   lbq.getAndSet(null)
[warn]       def close() = lbq.getAndSet(null) match {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:120: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: Int = _
[warn]       for (_ ← 1 to 10) system.scheduler.scheduleOnce(1 second, testActor, "fail").cancel()
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:286: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: Int = _
[warn]       for (_ ← 1 to N) {
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SchedulerSpec.scala:551: [scapegoat] Var could be val
[warn]   A variable (var) that is never written to could be turned into a value (val).
[warn]   def withScheduler(start: Long = 0L, _startTick: Int = 0, config: com.typesafe.config.Config = com.typesafe.config.ConfigFactory.empty())(thunk: (akka.actor.Scheduler with java.io.Closeable, LightArray
[warn]       new { @volatile var time = start } with LARS(config.withFallback(system.settings.config), log, tf) {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:150: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Hierarchy.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]     def suspendCount = context.asInstanceOf[ActorCell].mailbox.suspendCount
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:263: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Hierarchy.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]       } else if (context.asInstanceOf[ActorCell].mailbox.isSuspended) {
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:268: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Hierarchy.this.context.asInstanceOf[akka.actor.ActorCell]
[warn]           context.asInstanceOf[ActorCell].dispatcher.id)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:530: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   StressTest.this.context.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]         println(system.asInstanceOf[ActorSystemImpl].printTree)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:603: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   StressTest.this.context.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]         println(system.asInstanceOf[ActorSystemImpl].printTree)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:811: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   worker.asInstanceOf[akka.actor.LocalActorRef]
[warn]         awaitCond(worker.asInstanceOf[LocalActorRef].underlying.mailbox.isSuspended)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:65: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class Failure extends scala.`package`.RuntimeException with scala.util.control.NoStackTrace with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val directive: akka.actor.SupervisorStrategy.Directive = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def directive: akka.actor.SupervisorStrategy.Directive = Failure.this.directive;

[warn]   <caseaccessor> <paramaccessor> private[this] val stop: Boolean = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccess
[warn]   final case class Failure(directive: Directive, stop: Boolean, depth: Int, var failPre: Int, var failPost: Int, val failConstr: Int, stopKids: Int)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:250: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   state.ne(null)
[warn]         if (state ne null) stateCache.put(self.path, state.copy(log = log))
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:152: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def preStart: Unit = {

[warn]   Hierarchy.this.log_=(Hierarchy.this.log.:+[akka.actor.SupervisorHierarchySpec.Event, scala.collection.immutable.Vector[akka.actor.SupervisorHierarchySpec.Event]](SupervisorHierarchySpec.this.Event.apply("started", java.lang.System.identityHashCode(this).toLong))(im
[warn]     override def preStart {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:246: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def postStop: Unit = if (Hierarchy.this.failed.||(Hierarchy.this.suspended))

[warn]   {

[warn]     actor.this.`package`.actorRef2Scala(Hierarchy.this.listener).!(SupervisorHierarchySpec.this.ErrorLog.apply("not resumed (".+(Hierarchy.this.failed).+(", ").+(Hierarchy.this.suspended).+(")"), Hierarchy.th
[warn]     override def postStop {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:443: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def postStop: Unit = actor.this.`package`.actorRef2Scala(StressTest.this.testActor).!("stressTestStopped")(StressTest.this.self)
[warn]     override def postStop {
[warn]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:167: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.actor.ActorPath, Nothing]()
[info]         } else Map()
[info]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:252: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[akka.actor.ActorPath, Nothing]()
[info]         stateCache.put(self.path, HierarchyState(log, Map(), null))
[info]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:80: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val config: com.typesafe.config.Config = _
[warn]   class MyDispatcherConfigurator(config: Config, prerequisites: DispatcherPrerequisites)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorHierarchySpec.scala:128: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val log: scala.collection.immutable.Vector[akka.actor.SupervisorHierarchySpec.Event] = l.:+[akka.actor.SupervisorHierarchySpec.Event, scala.collection.immutable.Vector[akka.actor.SupervisorHierarchySp
[warn]         val log = l :+ Event("Failed in constructor", identityHashCode(this))
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorSpec.scala:91: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class Mailbox(settings: ActorSystem.Settings, config: Config) extends MailboxType {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\SupervisorSpec.scala:91: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class Mailbox(settings: ActorSystem.Settings, config: Config) extends MailboxType {
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:426: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TypedActorSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       JavaSerializer.currentSystem.withValue(system.asInstanceOf[ExtendedActorSystem]) {
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:436: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   in.readObject().asInstanceOf[akka.actor.TypedActor.MethodCall]
[warn]         val mNew = in.readObject().asInstanceOf[TypedActor.MethodCall]
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:445: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TypedActorSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       JavaSerializer.currentSystem.withValue(system.asInstanceOf[ExtendedActorSystem]) {
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:446: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   1.asInstanceOf[AnyRef]
[warn]         val m = TypedActor.MethodCall(classOf[Foo].getDeclaredMethod("testMethodCallSerialization", Array[Class[_]](classOf[Foo], classOf[String], classOf[Int]): _*), Array[AnyRef](someFoo, null, 1.asInstanceOf[AnyRef]))
[warn]                                                                                                                                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:455: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   in.readObject().asInstanceOf[akka.actor.TypedActor.MethodCall]
[warn]         val mNew = in.readObject().asInstanceOf[TypedActor.MethodCall]
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:463: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   mNew.parameters.apply(2).asInstanceOf[Int]
[warn]         mNew.parameters(2).asInstanceOf[Int] should ===(1)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:469: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TypedActorSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       JavaSerializer.currentSystem.withValue(system.asInstanceOf[ExtendedActorSystem]) {
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:482: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   in.readObject().asInstanceOf[akka.actor.TypedActorSpec.Foo]
[warn]         val tNew = in.readObject().asInstanceOf[Foo]
[warn]                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:443: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import java.io._
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:468: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import java.io._
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:100: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def nullReturn(): Any = null
[warn]     def nullReturn(): Any = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:330: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   t.optionPigdog(scala.concurrent.duration.`package`.DurationInt(100).millis).get
[warn]       t.optionPigdog(100 millis).get should ===("Pigdog")
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:51: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   newItems.tail
[warn]         if (current.compareAndSet(currentItems, newItems.tail)) newItems.head
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\TypedActorSpec.scala:51: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   newItems.head
[warn]         if (current.compareAndSet(currentItems, newItems.tail)) newItems.head
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\UidClashTest.scala:31: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]     new EvilCollidingActorRef(system.asInstanceOf[ActorSystemImpl].provider, oldActor.path, system.eventStream)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\UidClashTest.scala:14: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   class TerminatedForNonWatchedActor extends scala.`package`.Exception with scala.util.control.NoStackTrace {

[warn]   def <init>(): akka.actor.UidClashTest.TerminatedForNonWatchedActor = {

[warn]     TerminatedForNonWatchedActor.super.<init>("Received Terminated for actor that was not actually watched");

[warn]     ()

[warn]   }

[warn] }
[warn]   class TerminatedForNonWatchedActor extends Exception("Received Terminated for actor that was not actually watched")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:67: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DispatcherActor.this.context.dispatcher.asInstanceOf[akka.actor.dispatch.ActorModelSpec.MessageDispatcherInterceptor]
[warn]     def interceptor = context.dispatcher.asInstanceOf[MessageDispatcherInterceptor]
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:181: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   dispatcher.asInstanceOf[akka.actor.dispatch.ActorModelSpec.MessageDispatcherInterceptor]
[warn]     dispatcher.asInstanceOf[MessageDispatcherInterceptor].getStats(actorRef)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:209: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actorRef.asInstanceOf[akka.actor.ActorRefWithCell].underlying.asInstanceOf[akka.actor.ActorCell]
[warn]     val stats = statsFor(actorRef, Option(dispatcher).getOrElse(actorRef.asInstanceOf[ActorRefWithCell].underlying.asInstanceOf[ActorCell].dispatcher))
[warn]                                                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:342: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorModelSpec.this.newTestActor(dispatcher.id).asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a = newTestActor(dispatcher.id).asInstanceOf[InternalActorRef]
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:552: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DispatcherModelSpec.this.system.dispatchers.lookup("test-dispatcher-".+(DispatcherModelSpec.this.dispatcherCount.incrementAndGet())).asInstanceOf[akka.actor.dispatch.ActorModelSpec.MessageDispatcherInterceptor]
[warn]     system.dispatchers.lookup("test-dispatcher-" + dispatcherCount.incrementAndGet()).asInstanceOf[MessageDispatcherInterceptor]
[warn]                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:626: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BalancingDispatcherModelSpec.this.system.dispatchers.lookup("test-balancing-dispatcher-".+(BalancingDispatcherModelSpec.this.dispatcherCount.incrementAndGet())).asInstanceOf[akka.actor.dispatch.ActorModelSpec.MessageDispatcherInterceptor]
[warn]     system.dispatchers.lookup("test-balancing-dispatcher-" + dispatcherCount.incrementAndGet()).asInstanceOf[MessageDispatcherInterceptor]
[warn]                                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:235: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   done = condition;

[warn]   if (done.unary_!)

[warn]     java.this.lang.Thread.sleep(25L)

[warn]   else

[warn]     ()

[warn] } catch {

[warn]   case (e @ (_: InterruptedException)) => ()

[warn] }
[warn]       try {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:160: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   ActorModelSpec.this.await(deadline)(stops.==(dispatcher.stops.get()))

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => {

[warn]     system.eventStream.publish(akka.event.Logging.Error.apply(e, dispatcher.toString(), dispatcher.getClass(), "actual: stops=".+(dispatcher.stops.get()).+(" required: stops="
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:211: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   ActorModelSpec.this.await(deadline)(stats.suspensions.get().==(suspensions));

[warn]   ActorModelSpec.this.await(deadline)(stats.resumes.get().==(resumes));

[warn]   ActorModelSpec.this.await(deadline)(stats.registers.get().==(registers));

[warn]   ActorModelSpec.this.await(deadline)(stats.unregisters.get().
[warn]     try {
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:334: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   f

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => ActorModelSpec.this.system.eventStream.publish(akka.event.Logging.Error.apply(e, "spawn", this.getClass(), "error in spawned thread"))

[warn] }
[warn]           try f catch {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:385: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   ActorModelSpec.assertCountDown(cachedMessage.latch, waitTime, "Counting down from ".+(num))

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => {

[warn]     dispatcher match {

[warn]       case (dispatcher @ (_: akka.dispatch.BalancingDispatcher)) => {

[warn]         val team: java.util.concurrent.ConcurrentSkipListS
[warn]           try {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:574: [scapegoat] Empty while block
[warn]   An empty while block is considered as dead code.
[warn]   while$1(){

[warn]   if (a.isTerminated.unary_!.&&(b.isTerminated.unary_!))

[warn]     {

[warn]       ();

[warn]       while$1()

[warn]     }

[warn]   else

[warn]     ()

[warn] }
[warn]       while (!a.isTerminated && !b.isTerminated) {} //Busy wait for termination
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:648: [scapegoat] Empty while block
[warn]   An empty while block is considered as dead code.
[warn]   while$2(){

[warn]   if (a.isTerminated.unary_!.&&(b.isTerminated.unary_!))

[warn]     {

[warn]       ();

[warn]       while$2()

[warn]     }

[warn]   else

[warn]     ()

[warn] }
[warn]       while (!a.isTerminated && !b.isTerminated) {} //Busy wait for termination
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:59: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   final case class ThrowException extends AnyRef with akka.actor.dispatch.ActorModelSpec.ActorModelMessage with Product with Serializable {

[warn]   <caseaccessor> <paramaccessor> private[this] val e: Throwable = _;

[warn]   <stable> <caseaccessor> <accessor> <paramaccessor> def e: Throwable = ThrowException.this.e;

[warn]   def <init>(e: Throwable): akka.actor.dispatch.ActorModelSpec.ThrowException = {

[warn]     ThrowException.super.<init>();

[warn]     ()

[warn]   };

[warn]   <synthetic> def copy(e: Throwable = e): akka.actor.dispatch.
[warn]   final case class ThrowException(e: Throwable) extends ActorModelMessage
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:180: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def statsFor(actorRef: ActorRef, dispatcher: MessageDispatcher = null) =
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:183: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def assertRefDefaultZero(actorRef: ActorRef, dispatcher: MessageDispatcher = null)(
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:201: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   def assertRef(actorRef: ActorRef, dispatcher: MessageDispatcher = null)(
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:87: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   DispatcherActor.this.sender().tell(msg, null)
[warn]       case TryReply(msg)                ? { ack(); sender().tell(msg, null); busy.switchOff(()) }
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:239: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: InterruptedException)) => ()
[warn]         case e: InterruptedException ?
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:146: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stats: akka.actor.dispatch.ActorModelSpec.InterceptorStats = MessageDispatcherInterceptor.this.getStats(receiver.self)
[warn]       val stats = getStats(receiver.self)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:320: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val i: Int = _
[warn]           for (i ← 1 to 20) {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:389: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   dispatcher match {

[warn]   case (dispatcher @ (_: akka.dispatch.BalancingDispatcher)) => {

[warn]     val team: java.util.concurrent.ConcurrentSkipListSet[akka.actor.ActorCell] = dispatcher.team;

[warn]     val mq: ak
[warn]               dispatcher match {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:527: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val config: com.typesafe.config.Config = _
[warn]   class MessageDispatcherInterceptorConfigurator(config: Config, prerequisites: DispatcherPrerequisites)
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\ActorModelSpec.scala:601: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val config: com.typesafe.config.Config = _
[warn]   class BalancingMessageDispatcherInterceptorConfigurator(config: Config, prerequisites: DispatcherPrerequisites)
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\BalancingDispatcherSpec.scala:54: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BalancingDispatcherSpec.this.system.actorOf(akka.actor.Props.apply[BalancingDispatcherSpec.this.DelayableActor](new BalancingDispatcherSpec.this.DelayableActor(50, finishedCounter))((ClassTag.apply[BalancingDispatcherSpec.this.DelayableActor](classOf[akka.actor.dispatch.BalancingDispatcherSpec$DelayableActor]): scala.reflect.ClassTag[BalancingDispatcherSpec.this.DelayableActor])).withDispatcher(BalancingDispatcherSpec.this.delayableActorDispatcher)).asInstanceOf[akka.actor.ActorRefWithCell]
[warn]       val slow = system.actorOf(Props(new DelayableActor(50, finishedCounter)).withDispatcher(delayableActorDispatcher)).asInstanceOf[ActorRefWithCell]
[warn]                                                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\BalancingDispatcherSpec.scala:55: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   BalancingDispatcherSpec.this.system.actorOf(akka.actor.Props.apply[BalancingDispatcherSpec.this.DelayableActor](new BalancingDispatcherSpec.this.DelayableActor(10, finishedCounter))((ClassTag.apply[BalancingDispatcherSpec.this.DelayableActor](classOf[akka.actor.dispatch.BalancingDispatcherSpec$DelayableActor]): scala.reflect.ClassTag[BalancingDispatcherSpec.this.DelayableActor])).withDispatcher(BalancingDispatcherSpec.this.delayableActorDispatcher)).asInstanceOf[akka.actor.ActorRefWithCell]
[warn]       val fast = system.actorOf(Props(new DelayableActor(10, finishedCounter)).withDispatcher(delayableActorDispatcher)).asInstanceOf[ActorRefWithCell]
[warn]                                                                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\BalancingDispatcherSpec.scala:79: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   fast.underlying.asInstanceOf[akka.actor.ActorCell].mailbox.asInstanceOf[akka.dispatch.Mailbox]
[warn]       fast.underlying.asInstanceOf[ActorCell].mailbox.asInstanceOf[Mailbox].hasMessages should ===(false)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\BalancingDispatcherSpec.scala:80: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   slow.underlying.asInstanceOf[akka.actor.ActorCell].mailbox.asInstanceOf[akka.dispatch.Mailbox]
[warn]       slow.underlying.asInstanceOf[ActorCell].mailbox.asInstanceOf[Mailbox].hasMessages should ===(false)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\BalancingDispatcherSpec.scala:81: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   fast.underlying.asInstanceOf[akka.actor.ActorCell].actor.asInstanceOf[BalancingDispatcherSpec.this.DelayableActor]
[warn]       fast.underlying.asInstanceOf[ActorCell].actor.asInstanceOf[DelayableActor].invocationCount should be > sentToFast
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\BalancingDispatcherSpec.scala:82: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   fast.underlying.asInstanceOf[akka.actor.ActorCell].actor.asInstanceOf[BalancingDispatcherSpec.this.DelayableActor]
[warn]       fast.underlying.asInstanceOf[ActorCell].actor.asInstanceOf[DelayableActor].invocationCount should be >
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\BalancingDispatcherSpec.scala:83: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   slow.underlying.asInstanceOf[akka.actor.ActorCell].actor.asInstanceOf[BalancingDispatcherSpec.this.DelayableActor]
[warn]         (slow.underlying.asInstanceOf[ActorCell].actor.asInstanceOf[DelayableActor].invocationCount)
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\DispatchersSpec.scala:104: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   x$2.getClass().==(scala.this.Predef.implicitly[scala.reflect.ClassTag[T]](evidence$1).runtimeClass)
[warn]   def ofType[T <: MessageDispatcher: ClassTag]: (MessageDispatcher) ? Boolean = _.getClass == implicitly[ClassTag[T]].runtimeClass
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\DispatchersSpec.scala:217: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DispatchersSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val routee = expectMsgType[ActorIdentity].ref.get
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\DispatchersSpec.scala:71: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class OneShotMailboxType(settings: ActorSystem.Settings, config: Config)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\DispatchersSpec.scala:71: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class OneShotMailboxType(settings: ActorSystem.Settings, config: Config)
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\actor\dispatch\DispatchersSpec.scala:81: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (owner).
[warn]   class DoublingMailbox(owner: Option[ActorRef]) extends UnboundedQueueBasedMessageQueue {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dataflow\Future2Actor.scala:49: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Future2ActorSpec.this.intercept[concurrent.ExecutionException](scala.concurrent.Await.result[Any]({

[warn]   <artifact> val qual$4: akka.pattern.AskableActorRef = akka.pattern.`package`.ask(actor);

[warn]   <artifact> val x$8: String = "ex";

[warn]   <artifact> val x$9: akka.util.Timeout = Future2ActorSpec.this.timeout;

[warn]   <artifact> val x$10: akka.actor.ActorRef = qual$4.?$default$3(x$8);

[warn]   qual$4.?(x$8)(x$9, x$10)

[warn] }, Future2ActorSpec.this.timeout.duration))((ClassTag.apply[concurrent.ExecutionException](class
[warn]       }.getCause.isInstanceOf[AssertionError] should ===(true)
[warn]                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:68: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:92: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:115: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:39: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ExecutionContextSpec.this.system.dispatcher.isInstanceOf[akka.dispatch.BatchingExecutor]
[warn]       system.dispatcher.isInstanceOf[BatchingExecutor] should ===(true)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:67: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ExecutionContextSpec.this.system.dispatcher.isInstanceOf[akka.dispatch.BatchingExecutor]
[warn]       system.dispatcher.isInstanceOf[BatchingExecutor] should ===(true)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:91: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ExecutionContextSpec.this.system.dispatcher.isInstanceOf[akka.dispatch.BatchingExecutor]
[warn]       system.dispatcher.isInstanceOf[BatchingExecutor] should be(true)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:114: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ExecutionContextSpec.this.system.dispatcher.isInstanceOf[akka.dispatch.BatchingExecutor]
[warn]       system.dispatcher.isInstanceOf[BatchingExecutor] should be(true)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:45: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def run: Unit = {

[warn]   f;

[warn]   ()

[warn] }
[warn]         override def run: Unit = f
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:72: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def run: Unit = {

[warn]   f;

[warn]   ()

[warn] }
[warn]         override def run: Unit = f
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:133: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def run: Unit = ec.execute({

[warn]   final class $anon extends Object with Runnable {

[warn]     def <init>(): <$anon: Runnable> = {

[warn]       $anon.super.<init>();

[warn]       ()

[warn]     };

[warn]     override def run: Unit = scala.concurrent.`package`.blocking[Unit](x = 1)

[warn]   };

[warn]   new $anon()

[warn] })
[warn]         override def run = {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:170: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def run: Unit = {

[warn]   ec.execute({

[warn]     final class $anon extends RunBatch {

[warn]       def <init>(): <$anon: RunBatch> = {

[warn]         $anon.super.<init>();

[warn]         ()

[warn]       };

[warn]       override def run: Unit = scala.concurrent.`package`.blocking[Unit](x = 1)

[warn]     };

[warn]     new $anon()

[warn]   });

[warn]   sca
[warn]         override def run = {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:191: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = counter.set(f.apply(counter.get()))
[warn]       def perform(f: Int ? Int) = sec execute new Runnable { def run = counter.set(f(counter.get)) }
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:218: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = counter.set(f.apply(counter.get()))
[warn]       def perform(f: Int ? Int) = sec execute new Runnable { def run = counter.set(f(counter.get)) }
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:233: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = counter.set(f.apply(counter.get()))
[warn]       def perform(f: Int ? Int) = sec execute new Runnable { def run = counter.set(f(counter.get)) }
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\ExecutionContextSpec.scala:250: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   def run: Unit = counter.set(f.apply(counter.get()))
[warn]       def perform(f: Int ? Int) = sec execute new Runnable { def run = counter.set(f(counter.get)) }
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:448: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   i.asInstanceOf[AnyRef]
[warn]             case (l, i) if i % 2 == 0 ? l += i.asInstanceOf[AnyRef]
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:749: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   scala.this.Predef.implicitly[scala.reflect.ClassTag[A]](evidence$2).runtimeClass.==(reftag.runtimeClass)
[warn]   def checkType[A: ClassTag, B](in: Future[A], reftag: ClassTag[B]): Boolean = implicitly[ClassTag[A]].runtimeClass == reftag.runtimeClass
[warn]                                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:181: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FutureSpec.ready[T](f, FutureSpec.this.timeout.duration).value.get
[warn]               def wrap[T](f: Future[T]): Try[T] = FutureSpec.ready(f, timeout.duration).value.get
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:189: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   result.value.get
[warn]               }) :| result.value.get.toString + " is expected to be " + expected.toString
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:692: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   future.value.get
[warn]         future.value.get should be('failure)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:693: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   future.value.get
[warn]         val Failure(f) = future.value.get
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:445: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val testNumber: Int = _).
[warn]         def test(testNumber: Int) {
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:687: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit <synthetic> val evidence$1: scala.reflect.ClassTag[E] = _).
[warn]   def futureWithException[E <: Throwable: ClassTag](f: ((Future[Any], String) ? Unit) ? Unit) {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:749: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val in: scala.concurrent.Future[A] = _).
[warn]   def checkType[A: ClassTag, B](in: Future[A], reftag: ClassTag[B]): Boolean = implicitly[ClassTag[A]].runtimeClass == reftag.runtimeClass
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:67: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val that: Int = _
[warn]     def /:(that: Try[Int]): Try[Int] = that map action.apply
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:68: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val that: Int = _
[warn]     def /:(that: Future[Int]): Future[Int] = that map action.apply
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:72: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val that: Int = _
[warn]     def /:(that: Try[Int]): Try[Int] = that map action.apply
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\FutureSpec.scala:693: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val f: Throwable = (future.value.get: scala.util.Try[Any] @unchecked) match {

[warn]   case (exception: Throwable)scala.util.Failure[Any]((f @ _)) => f

[warn] }
[warn]         val Failure(f) = future.value.get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:243: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.asInstanceOf[akka.actor.ActorRefWithCell].underlying.asInstanceOf[akka.actor.ActorCell]
[warn]       val queue = actor.asInstanceOf[ActorRefWithCell].underlying.asInstanceOf[ActorCell].mailbox.messageQueue
[warn]                                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:173: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]       cs.flatten.distinct.size should ===(dequeueN)
[info]                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:175: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]       (cs.flatten diff ps.flatten).size should ===(0)
[info]                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:177: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]       (ps.flatten diff cs.flatten).size should ===(enqueueN - dequeueN)
[info]                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:150: [scapegoat] Simplify boolean expressions
[info]   Boolean expressions such as x == false can be re-written as !x.
[info]   parallel.==(false)
[info]         if (parallel == false)
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:159: [scapegoat] Simplify boolean expressions
[info]   Boolean expressions such as x == false can be re-written as !x.
[info]   x$2.isCompleted.==(false)
[info]         while (producers.exists(_.isCompleted == false) || q.hasMessages)
[info]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:223: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class MyMailboxType(settings: ActorSystem.Settings, config: Config) extends MailboxType {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:223: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class MyMailboxType(settings: ActorSystem.Settings, config: Config) extends MailboxType {
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\MailboxConfigSpec.scala:230: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (owner).
[warn]   class MyMailbox(owner: ActorRef) extends UnboundedQueueBasedMessageQueue {
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\PriorityDispatcherSpec.scala:21: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class Unbounded(settings: ActorSystem.Settings, config: Config) extends UnboundedPriorityMailbox(PriorityGenerator({
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\PriorityDispatcherSpec.scala:21: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class Unbounded(settings: ActorSystem.Settings, config: Config) extends UnboundedPriorityMailbox(PriorityGenerator({
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\PriorityDispatcherSpec.scala:26: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class Bounded(settings: ActorSystem.Settings, config: Config) extends BoundedPriorityMailbox(PriorityGenerator({
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\PriorityDispatcherSpec.scala:26: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class Bounded(settings: ActorSystem.Settings, config: Config) extends BoundedPriorityMailbox(PriorityGenerator({
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\StablePriorityDispatcherSpec.scala:24: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class Unbounded(settings: ActorSystem.Settings, config: Config) extends UnboundedStablePriorityMailbox(PriorityGenerator({
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\StablePriorityDispatcherSpec.scala:24: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class Unbounded(settings: ActorSystem.Settings, config: Config) extends UnboundedStablePriorityMailbox(PriorityGenerator({
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\StablePriorityDispatcherSpec.scala:30: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]   class Bounded(settings: ActorSystem.Settings, config: Config) extends BoundedStablePriorityMailbox(PriorityGenerator({
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\dispatch\StablePriorityDispatcherSpec.scala:30: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]   class Bounded(settings: ActorSystem.Settings, config: Config) extends BoundedStablePriorityMailbox(PriorityGenerator({
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:41: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EventBusSpec.this.createSubscriber(EventBusSpec.this.testActor).asInstanceOf[EventBusSpec.this.bus.Subscriber]
[warn]     def createNewSubscriber() = createSubscriber(testActor).asInstanceOf[bus.Subscriber]
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:42: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EventBusSpec.this.classifierFor(event).asInstanceOf[EventBusSpec.this.bus.Classifier]
[warn]     def getClassifierFor(event: BusType#Event) = classifierFor(event).asInstanceOf[bus.Classifier]
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:43: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EventBusSpec.this.createEvents(numberOfEvents).asInstanceOf[Iterable[EventBusSpec.this.bus.Event]]
[warn]     def createNewEvents(numberOfEvents: Int): Iterable[bus.Event] = createEvents(numberOfEvents).asInstanceOf[Iterable[bus.Event]]
[warn]                                                                                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:155: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Notification(ref: ActorRef, payload: Int)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:46: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   events.head
[warn]     val event = events.head
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:121: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   events.drop(1).head
[warn]       val otherClassifier = getClassifierFor(events.drop(1).head)
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:170: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   scala.this.Predef.intWrapper(0).until(numberOfEvents).map[akka.event.ActorEventBusSpec.Notification, scala.collection.immutable.IndexedSeq[akka.event.ActorEventBusSpec.Notification]](((x$5: Int) => ak
[warn]   def createEvents(numberOfEvents: Int) = (0 until numberOfEvents).map(Notification(TestProbe().ref, _)).toSeq
[warn]                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventBusSpec.scala:78: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val events: Iterable[EventBusSpec.this.BusType#Event] = EventBusSpec.this.createEvents(10)
[warn]       val events = createEvents(10)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\EventStreamSpec.scala:73: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EventStreamSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]   val impl = system.asInstanceOf[ActorSystemImpl]
[warn]                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\LoggerSpec.scala:93: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   event.mdc.isEmpty.unary_!
[info]       case event: LogEvent if !event.mdc.isEmpty ?
[info]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\LoggerSpec.scala:93: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   event.mdc.isEmpty.unary_!
[info]       case event: LogEvent if !event.mdc.isEmpty ?
[info]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\LoggerSpec.scala:124: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[Nothing, Nothing]()
[info]         case _      ? Map()
[info]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\event\LoggingReceiveSpec.scala:164: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LoggingReceiveSpec.this.appLifecycle.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]           val lifecycleGuardian = appLifecycle.asInstanceOf[ActorSystemImpl].guardian
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:149: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   $anon.this.clientSideChannel.socket().getLocalSocketAddress().asInstanceOf[java.net.InetSocketAddress]
[warn]         userHandler.expectMsg(Connected(serverAddress, clientSideChannel.socket.getLocalSocketAddress.asInstanceOf[InetSocketAddress]))
[warn]                                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:236: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   classOf[akka.io.TcpConnectionSpec].getClassLoader().asInstanceOf[java.net.URLClassLoader]
[warn]           classOf[TcpConnectionSpec].getClassLoader.asInstanceOf[URLClassLoader]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:664: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   $anon.this.clientSideChannel.socket().getLocalSocketAddress().asInstanceOf[java.net.InetSocketAddress]
[warn]         userHandler.expectMsg(Connected(serverAddress, clientSideChannel.socket.getLocalSocketAddress.asInstanceOf[InetSocketAddress]))
[warn]                                                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:970: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   EstablishedConnectionTest.this.clientSideChannel.socket().getLocalSocketAddress().asInstanceOf[java.net.InetSocketAddress]
[warn]         userHandler.expectMsg(Connected(serverAddress, clientSideChannel.socket.getLocalSocketAddress.asInstanceOf[InetSocketAddress]))
[warn]                                                                                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:31: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Ack(i: Int) extends Event
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:852: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     @volatile var serverSideChannel: SocketChannel = null
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:892: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val serverAddress: java.net.InetSocketAddress = serverAddress
[warn]       serverAddress: InetSocketAddress           = serverAddress,
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpConnectionSpec.scala:908: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val serverAddress: java.net.InetSocketAddress = serverAddress
[warn]       serverAddress: InetSocketAddress           = serverAddress,
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpIntegrationSpec.scala:180: [scapegoat] Empty catch block
[warn]   If you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.
[warn]   case (e @ (_: java.io.IOException)) => ()
[warn]           case e: IOException ? // this is also fine
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\TcpListenerSpec.scala:167: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val pullMode: Boolean = _
[warn]     private class ListenerParent(pullMode: Boolean) extends Actor with ChannelRegistry {
[warn]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\UdpIntegrationSpec.scala:106: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] private case class AssertBeforeBind() extends SocketOption {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\UdpIntegrationSpec.scala:115: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] private case class AssertAfterChannelBind() extends SocketOptionV2 {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\UdpIntegrationSpec.scala:124: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] private case class AssertOpenDatagramChannel() extends DatagramChannelCreator {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\UdpIntegrationSpec.scala:106: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private case class AssertBeforeBind() extends SocketOption {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\UdpIntegrationSpec.scala:115: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private case class AssertAfterChannelBind() extends SocketOptionV2 {
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\io\UdpIntegrationSpec.scala:124: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] private case class AssertOpenDatagramChannel() extends DatagramChannelCreator {
[info]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\AskSpec.scala:32: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   f.value.get
[warn]       f.value.get match {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\AskSpec.scala:43: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   f.value.get
[warn]       f.value.get match {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\AskSpec.scala:117: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   x$1.ref.get
[warn]         .mapTo[ActorIdentity].map(_.ref.get)
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffOnRestartSupervisorSpec.scala:168: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffOnRestartSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]         expectMsgType[BackoffSupervisor.CurrentChild].ref.get should !==(child)
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffSupervisorSpec.scala:55: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]       val c1 = expectMsgType[BackoffSupervisor.CurrentChild].ref.get
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffSupervisorSpec.scala:62: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]         expectMsgType[BackoffSupervisor.CurrentChild].ref.get should !==(c1)
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffSupervisorSpec.scala:78: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]         val c1 = expectMsgType[BackoffSupervisor.CurrentChild].ref.get
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffSupervisorSpec.scala:85: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]           expectMsgType[BackoffSupervisor.CurrentChild].ref.get should !==(c1)
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffSupervisorSpec.scala:110: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]         val c1 = expectMsgType[BackoffSupervisor.CurrentChild].ref.get
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffSupervisorSpec.scala:120: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]           expectMsgType[BackoffSupervisor.CurrentChild].ref.get should !==(c1)
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffSupervisorSpec.scala:132: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]           val c1 = expectMsgType[BackoffSupervisor.CurrentChild].ref.get
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\BackoffSupervisorSpec.scala:145: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   BackoffSupervisorSpec.this.expectMsgType[akka.pattern.BackoffSupervisor.CurrentChild]((ClassTag.apply[akka.pattern.BackoffSupervisor.CurrentChild](classOf[akka.pattern.BackoffSupervisor$$CurrentChild]): scala.reflect.ClassTag[akka.pattern.BackoffSupervisor.CurrentChild])).ref.get
[warn]             expectMsgType[BackoffSupervisor.CurrentChild].ref.get should !==(c1)
[warn]                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\CircuitBreakerStressSpec.scala:20: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Result(doneCount: Int, timeoutCount: Int, failCount: Int, circCount: Int)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\PromiseRefSpec.scala:14: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Request(replyTo: ActorRef)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\extended\ExplicitAskSpec.scala:13: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Request(respondTo: ActorRef)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\pattern\extended\ExplicitAskSpec.scala:14: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Response(sentFrom: ActorRef)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ConfiguredLocalRoutingSpec.scala:180: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ConfiguredLocalRoutingSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val parent = system.asInstanceOf[ExtendedActorSystem].systemActorOf(Props[Parent], "sys-parent")
[warn]                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ConfiguredLocalRoutingSpec.scala:18: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.testkit.TestProbe
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ConfiguredLocalRoutingSpec.scala:164: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.actor.ActorRef]()
[info]       val recv = Set() ++ (for (_ ← 1 to 3) yield expectMsgType[ActorRef])
[info]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ConfiguredLocalRoutingSpec.scala:68: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val config: com.typesafe.config.Config = _
[warn]   class MyRouter(config: Config) extends CustomRouterConfig {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ConfiguredLocalRoutingSpec.scala:72: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <caseaccessor> <paramaccessor> private[this] val config: com.typesafe.config.Config = _
[warn]   final case class MyRoutingLogic(config: Config) extends RoutingLogic {
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ConsistentHashingRouterSpec.scala:57: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(ConsistentHashingRouterSpec.this.router1).?(GetRoutees)(ConsistentHashingRouterSpec.this.timeout, ConsistentHashingRouterSpec.this.self), ConsistentHashingRouterSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]       val currentRoutees = Await.result(router1 ? GetRoutees, timeout.duration).asInstanceOf[Routees]
[warn]                                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:359: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(router).?(GetRoutees)(MetricsBasedResizerSpec.this.timeout, MetricsBasedResizerSpec.this.self), MetricsBasedResizerSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]       Await.result(router ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees.size
[warn]                                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:23: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Latches(first: TestLatch, second: TestLatch)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:43: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TestRouter(routees: Vector[ActorRefRoutee])(implicit system: ActorSystem, timeout: Timeout) {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:130: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   resizer.record.underutilizationStreak.get
[warn]       resizer.record.underutilizationStreak.get.start.isBefore(LocalDateTime.now.plusSeconds(1)) shouldBe true
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:131: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   resizer.record.underutilizationStreak.get
[warn]       resizer.record.underutilizationStreak.get.start.isAfter(LocalDateTime.now.minusSeconds(1)) shouldBe true
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:155: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   resizer.record.underutilizationStreak.get
[warn]       resizer.record.underutilizationStreak.get.start shouldBe start
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:167: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   resizer.record.underutilizationStreak.get
[warn]       resizer.record.underutilizationStreak.get.highestUtilization shouldBe 2
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:182: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   resizer.record.underutilizationStreak.get
[warn]       resizer.record.underutilizationStreak.get.highestUtilization shouldBe 2
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:73: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def atStartup: Unit = MetricsBasedResizerSpec.this.system.eventStream.publish(akka.testkit.TestEvent.Mute.apply({

[warn]   <artifact> val x$9: String = ".*Resize";

[warn]   <artifact> val x$10: String = akka.testkit.EventFilter.warning$default$1;

[warn]   <artifact> val x$11: String = akka.testkit.EventFilte
[warn]   override def atStartup: Unit = {
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\MetricsBasedResizerSpec.scala:45: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.testkit.TestLatch]()
[info]     var msgs: Set[TestLatch] = Set()
[info]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ResizerSpec.scala:49: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(router).?(GetRoutees)(ResizerSpec.this.timeout, ResizerSpec.this.self), ResizerSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]     Await.result(router ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees.size
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ResizerSpec.scala:43: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def atStartup: Unit = ResizerSpec.this.system.eventStream.publish(akka.testkit.TestEvent.Mute.apply({

[warn]   <artifact> val x$1: String = ".*Resize";

[warn]   <artifact> val x$2: String = akka.testkit.EventFilter.warning$default$1;

[warn]   <artifact> val x$3: String = akka.testkit.EventFilter.warning$defa
[warn]   override def atStartup: Unit = {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoundRobinSpec.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(router).?(GetRoutees)(RoundRobinSpec.this.timeout, RoundRobinSpec.this.self), RoundRobinSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]     Await.result(router ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees.size
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoundRobinSpec.scala:65: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: Int = _
[warn]       for (_ ← 1 to iterationCount; _ ← 1 to connectionCount) {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoundRobinSpec.scala:139: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: Int = _
[warn]       for (_ ← 1 to iterationCount; _ ← 1 to connectionCount) {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoundRobinSpec.scala:185: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: Int = _
[warn]       for (_ ← 1 to iterationCount; _ ← 1 to connectionCount) {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\RoutingSpec.scala:197: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]               def receive = { case x ? sender() ! x }
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\routing\ScatterGatherFirstCompletedSpec.scala:36: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def postStop: Unit = shudownLatch.foreach[Unit](((x$1: akka.testkit.TestLatch) => x$1.countDown()))
[warn]       override def postStop = {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:185: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   a.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]         JavaSerializer.currentSystem.withValue(a.asInstanceOf[ActorSystemImpl]) {
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:186: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   in.readObject().asInstanceOf[akka.actor.DeadLetterActorRef]
[warn]           val deadLetters = in.readObject().asInstanceOf[DeadLetterActorRef]
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:257: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SerializeSpec.this.ser.serializerFor(classOf[[B]).asInstanceOf[akka.serialization.ByteBufferSerializer]
[warn]       val byteSerializer = ser.serializerFor(classOf[Array[Byte]]).asInstanceOf[ByteBufferSerializer]
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:265: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   byteSerializer.fromBinary(byteBuffer, "").asInstanceOf[Array[Byte]]
[warn]       val deserialized = byteSerializer.fromBinary(byteBuffer, "").asInstanceOf[Array[Byte]]
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:26: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n    akka {\n      actor {\n        serialize-messages = off\n        serializers {\n          test = \"akka.serialization.TestSerializer\"\n        }\n\n        serialization-bindings {\n          \"akka.serialization.SerializationTests$Person\" = java\n          \"akka.serialization.SerializationTests$Address\" = java\n          \"akka.serialization.TestSerializable\" = test\n          \"akka.serialization.SerializationTests$PlainMessage\" = test\n          \"akka.s
[warn]   val serializeConf = s"""
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:527: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = null
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:50: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Person.this.<init>("", 0, null)
[warn]   final case class Person(name: String, age: Int, address: Address) { def this() = this("", 0, null) }
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:343: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SerializationCompatibilitySpec.this.ser.serialize(obj).map[Array[Char]]({

[warn]   ((x$1: Array[Byte]) => org.apache.commons.codec.binary.Hex.encodeHex(x$1))

[warn] }).get
[warn]       String.valueOf(ser.serialize(obj).map(encodeHex).get) should ===(asExpected)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:54: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (s).
[warn]   class SimpleMessage(s: String) extends TestSerializable
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:56: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (i).
[warn]   class ExtendedSimpleMessage(s: String, i: Int) extends SimpleMessage(s)
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\serialization\SerializeSpec.scala:95: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   class NonSerializableActor(system: ActorSystem) extends Actor {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\testkit\CallingThreadDispatcherModelSpec.scala:51: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CallingThreadDispatcherModelSpec.this.system.dispatchers.lookup("test-calling-thread-".+(CallingThreadDispatcherModelSpec.this.dispatcherCount.incrementAndGet())).asInstanceOf[akka.actor.dispatch.ActorModelSpec.MessageDispatcherInterceptor]
[warn]     system.dispatchers.lookup("test-calling-thread-" + dispatcherCount.incrementAndGet()).asInstanceOf[MessageDispatcherInterceptor]
[warn]                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\testkit\CallingThreadDispatcherModelSpec.scala:30: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val config: com.typesafe.config.Config = _
[warn]   class CallingThreadDispatcherInterceptorConfigurator(config: Config, prerequisites: DispatcherPrerequisites)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:500: [scapegoat] Avoid Traversable.size != 0
[warn]   .size can be slow for some data structures, prefer .nonEmpty, which is O(1).
[warn]   a.asByteBuffers.size.>(0)
[warn]         check { (a: ByteString) ? if (a.isCompact) a.asByteBuffers.size == 1 && a.asByteBuffers.head == a.asByteBuffer else a.asByteBuffers.size > 0 }
[warn]                                                                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:144: [scapegoat] Comparing unrelated types
[warn]   In most case comparing unrelated types cannot succeed and it's usually an indication of a bug.
[warn]   bsBuilder.result().==(vecBuilder.result())
[warn]     bsBuilder.result == vecBuilder.result
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:69: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def deserialize(bytes: Array[Byte]): AnyRef = {

[warn]   val is: java.io.ObjectInputStream = new java.io.ObjectInputStream(new java.io.ByteArrayInputStream(bytes));

[warn]   is.readObject()

[warn] }
[warn]   def deserialize(bytes: Array[Byte]): AnyRef = {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:513: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   ByteStringSpec.this.check[ByteStringSpec.this.ByteStringSlice, Boolean, org.scalatest.Assertion](((slice: ByteStringSpec.this.ByteStringSlice) => slice match {

[info]   case (_1: akka.util.ByteString, _2: Int, _3: Int)(akka.util.ByteString, Int, Int)((xs @ _), (i1 @ _), (i2 @ _)) => ByteStringSpec.this.likeVector(xs)(((seq: IndexedSeq[Byte]) => scala.Tuple2.apply[Int, Int](if (i1.>=(0).&&(i1.<(seq.length)))

[info]     seq.apply(i1).toInt

[info]   else

[info]     0, if (i2.>=(0).&&(i2.<(seq.length)))

[info]     seq.apply(i2).
[info]         check { slice: ByteStringSlice ?
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:540: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   ByteStringSpec.this.check[ByteStringSpec.this.ByteStringSlice, Boolean, org.scalatest.Assertion](((slice: ByteStringSpec.this.ByteStringSlice) => slice match {

[info]   case (_1: akka.util.ByteString, _2: Int, _3: Int)(akka.util.ByteString, Int, Int)((xs @ _), (from @ _), (until @ _)) => ByteStringSpec.this.likeVector(xs)(((x$48: IndexedSeq[Byte]) => x$48.slice(from, until)))

[info] }))
[info]         check { slice: ByteStringSlice ?
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:550: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   ByteStringSpec.this.check[ByteStringSpec.this.ByteStringSlice, Boolean, org.scalatest.Assertion](((slice: ByteStringSpec.this.ByteStringSlice) => slice match {

[info]   case (_1: akka.util.ByteString, _2: Int, _3: Int)(akka.util.ByteString, Int, Int)((xs @ _), (from @ _), (until @ _)) => ByteStringSpec.this.likeVector(xs)(((x$49: IndexedSeq[Byte]) => x$49.drop(from).take(until.-(from))))

[info] }))
[info]         check { slice: ByteStringSlice ?
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:560: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   ByteStringSpec.this.check[ByteStringSpec.this.ByteStringSlice, Boolean, org.scalatest.Assertion](((slice: ByteStringSpec.this.ByteStringSlice) => slice match {

[info]   case (_1: akka.util.ByteString, _2: Int, _3: Int)(akka.util.ByteString, Int, Int)((xs @ _), (from @ _), (until @ _)) => ByteStringSpec.this.likeVector(xs)(((it: IndexedSeq[Byte]) => {

[info]     val array: Array[Byte] = scala.Array.ofDim[Byte](xs.length)((ClassTag.Byte: scala.reflect.ClassTag[Byte]));

[info]     it.slice(from, until).copyToArray[B
[info]         check { slice: ByteStringSlice ?
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:621: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   ByteStringSpec.this.check[ByteStringSpec.this.ByteStringSlice, Boolean, org.scalatest.Assertion](((slice: ByteStringSpec.this.ByteStringSlice) => slice match {

[info]   case (_1: akka.util.ByteString, _2: Int, _3: Int)(akka.util.ByteString, Int, Int)((xs @ _), (from @ _), (until @ _)) => ByteStringSpec.this.likeVecIt(xs)(((x$70: BufferedIterator[Byte]) => x$70.slice(from, until).toSeq), false)

[info] }))
[info]         check { slice: ByteStringSlice ?
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:631: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   ByteStringSpec.this.check[ByteStringSpec.this.ByteStringSlice, Boolean, org.scalatest.Assertion](((slice: ByteStringSpec.this.ByteStringSlice) => slice match {

[info]   case (_1: akka.util.ByteString, _2: Int, _3: Int)(akka.util.ByteString, Int, Int)((xs @ _), (from @ _), (until @ _)) => ByteStringSpec.this.likeVecIt(xs)(((x$71: BufferedIterator[Byte]) => x$71.drop(from).take(until.-(from)).toSeq), false)

[info] }))
[info]         check { slice: ByteStringSlice ?
[info]               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:641: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   ByteStringSpec.this.check[ByteStringSpec.this.ByteStringSlice, Boolean, org.scalatest.Assertion](((slice: ByteStringSpec.this.ByteStringSlice) => slice match {

[info]   case (_1: akka.util.ByteString, _2: Int, _3: Int)(akka.util.ByteString, Int, Int)((xs @ _), (from @ _), (until @ _)) => ByteStringSpec.this.likeVecIt(xs)(((it: BufferedIterator[Byte]) => {

[info]     val array: Array[Byte] = scala.Array.ofDim[Byte](xs.length)((ClassTag.Byte: scala.reflect.ClassTag[Byte]));

[info]     it.slice(from, until).copyToAr
[info]         check { slice: ByteStringSlice ?
[info]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:523: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   x$29.head
[warn]       "calling head" in { check { a: ByteString ? a.isEmpty || likeVector(a) { _.head } } }
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:524: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   x$30.tail
[warn]       "calling tail" in { check { a: ByteString ? a.isEmpty || likeVector(a) { _.tail } } }
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:525: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   x$31.last
[warn]       "calling last" in { check { a: ByteString ? a.isEmpty || likeVector(a) { _.last } } }
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ByteStringSpec.scala:526: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   x$32.init
[warn]       "calling init" in { check { a: ByteString ? a.isEmpty || likeVector(a) { _.init } } }
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ReflectSpec.scala:18: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MultipleOne.this.<init>(a, null)
[warn]     def this(a: A) { this(a, null) }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ReflectSpec.scala:19: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   MultipleOne.this.<init>(null, b)
[warn]     def this(b: B) { this(null, b) }
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ReflectSpec.scala:14: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (a).
[warn]   class One(a: A)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ReflectSpec.scala:15: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (a).
[warn]   class Two(a: A, b: B)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ReflectSpec.scala:15: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (b).
[warn]   class Two(a: A, b: B)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ReflectSpec.scala:17: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (a).
[warn]   class MultipleOne(a: A, b: B) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\ReflectSpec.scala:17: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (b).
[warn]   class MultipleOne(a: A, b: B) {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\TokenBucketSpec.scala:226: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("  EMITTING").s()
[warn]             if (Debug) println(s"  EMITTING")
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:20: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "b")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree.find(Array("a", "b")).get shouldBe 2
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:21: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree.find(Array("a")).get shouldBe 1
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:29: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree1.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree1.find(Array("a")).get shouldBe 1
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:30: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree1.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "b")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree1.find(Array("a", "b")).get shouldBe 1
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:31: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree1.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "x")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree1.find(Array("a", "x")).get shouldBe 1
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:35: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree2.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "b")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree2.find(Array("a", "b")).get shouldBe 1
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:36: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree2.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "x")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree2.find(Array("a", "x")).get shouldBe 1
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:37: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree2.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "x", "c")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree2.find(Array("a", "x", "c")).get shouldBe 2
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:50: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree1.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "b")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree1.find(Array("a", "b")).get shouldBe 1
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:51: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree1.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "x")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree1.find(Array("a", "x")).get shouldBe 1
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:52: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree1.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("a", "x", "y")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree1.find(Array("a", "x", "y")).get shouldBe 1
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:55: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree2.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("anything", "I", "want")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree2.find(Array("anything", "I", "want")).get shouldBe 1
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-actor-tests\src\test\scala\akka\util\WildcardIndexSpec.scala:56: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   tree2.find(scala.this.Predef.wrapRefArray[String](scala.Array.apply[String]("anything")((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String])))).get
[warn]       tree2.find(Array("anything")).get shouldBe 1
[warn]                                     ^
[info] [warn] [scapegoat] Analysis complete: 111 files - 0 errors 278 warns 65 infos
[warn] there were 100 deprecation warnings; re-run with -deprecation for details
[warn] 272 warnings found
[info] Compiling 28 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\target\test-classes...
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryCrashSpec.scala:28: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class SendingMessage(deliveryId: Long, recovering: Boolean)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:18: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n      akka.persistence.sender.chaos.live-processing-failure-rate = 0.3\n      akka.persistence.sender.chaos.replay-processing-failure-rate = 0.1\n      akka.persistence.destination.chaos.confirm-failure-rate = 0.3\n      akka.persistence.journal.plugin = \"akka.persistence.journal.chaos\"\n      akka.persistence.journal.chaos.write-failure-rate = 0.3\n      akka.persistence.journal.chaos.confirm-failure-rate = 0.2\n      akka.persistence.journal.chaos.delete-failure-
[warn]     s"""
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:160: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("sender stopped, starting it again").s()
[warn]         log.debug(s"sender stopped, starting it again")
[warn]                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:36: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Done(ints: Vector[Int])
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:38: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Ack(i: Int)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:40: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Msg(deliveryId: Long, i: Int)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:41: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Confirm(deliveryId: Long, i: Int)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:44: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class MsgSent(i: Int) extends Evt
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:45: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class MsgConfirmed(deliveryId: Long, i: Int) extends Evt
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:67: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val config: com.typesafe.config.Config = ChaosSender.this.context.system.settings.config.getConfig("akka.persistence.sender.chaos")
[warn]     val config = context.system.settings.config.getConfig("akka.persistence.sender.chaos")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliveryFailureSpec.scala:126: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val config: com.typesafe.config.Config = ChaosDestination.this.context.system.settings.config.getConfig("akka.persistence.destination.chaos")
[warn]     val config = context.system.settings.config.getConfig("akka.persistence.destination.chaos")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:394: [scapegoat] Broken odd check
[warn]   Code that attempts to check for oddness using `x % 2 == 1` will fail on negative numbers. Consider using `x % 2 != 0`.
[warn]   n.%(2).==(1)
[warn]       for (n ← 1 to N if n % 2 == 1) probeA.expectMsg(Action(n, s"a-$n"))
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:165: [scapegoat] Catch exception
[warn]   Did you intend to catch all exceptions? Consider catching a more specific exception class.
[warn]   try {

[warn]   DeliverToStarSelection.this.deliver(DeliverToStarSelection.this.context.actorSelection("*"))(((id: Long) => scala.StringContext.apply("", "", "").s(any, id)))

[warn] } catch {

[warn]   case (ex @ (_: Exception)) => akka.actor.`package`.actorRef2Scala(DeliverToStarSelection.this.sender()).!(scala.util.F
[warn]         try deliver(context.actorSelection("*"))(id ? s"$any$id")
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:17: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Req(payload: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:22: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class AcceptedReq(payload: String, destination: ActorPath) extends Evt
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:23: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ReqDone(id: Long) extends Evt
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:25: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Action(id: Long, payload: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:26: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ActionAck(id: Long)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\AtLeastOnceDeliverySpec.scala:29: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Snap(deliverySnapshot: AtLeastOnceDeliverySnapshot) // typically includes some user data as well
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:22: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class A(payload: Any) extends AppModel
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:23: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class B(payload: Any) extends AppModel
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:24: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NewA(payload: Any) extends AppModel
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:25: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NewB(payload: Any) extends AppModel
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:27: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class JSON(payload: Any)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:29: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   class AEndToEndAdapter(system: ExtendedActorSystem) extends EventAdapter {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:39: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   class NewAEndToEndAdapter(system: ExtendedActorSystem) extends EventAdapter {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:49: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   class BEndToEndAdapter(system: ExtendedActorSystem) extends EventAdapter {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:59: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   class NewBEndToEndAdapter(system: ExtendedActorSystem) extends EventAdapter {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EndToEndEventAdapterSpec.scala:70: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (probe).
[warn]   class EndToEndAdapterActor(name: String, override val journalPluginId: String, probe: Option[ActorRef])
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EventAdapterSpec.scala:115: [scapegoat] Looks like interpolated String
[warn]   Did you forget to prefix this string with an s, f or raw to interpolate it?
[warn]          |      "${EventAdapterSpec.JournalModelClassName}" = age
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EventAdapterSpec.scala:138: [scapegoat] Looks like interpolated String
[warn]   Did you forget to prefix this string with an s, f or raw to interpolate it?
[warn]          |      "${EventAdapterSpec.DomainEventClassName}"  = replay-pass-through
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\EventAdapterSpec.scala:153: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def toJournal(in: Any, journalId: String = EventAdapterSpec.this.journalName): Any = Persistence.apply(EventAdapterSpec.this.system).adaptersFor("akka.persistence.journal.".+(journalId)).get(in.getClass()).toJournal(in)
[warn]   def toJournal(in: Any, journalId: String = journalName) =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistenceSpec.scala:105: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   IndependentlyOrdered.this.prefixes.apply(pos)
[warn]         nrs = seq.map(_.replaceFirst(prefixes(pos), "").toInt)
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistenceSpec.scala:110: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   IndependentlyOrdered.this.prefixes.apply(pos)
[warn]         s"""Messages sequence with prefix ${prefixes(pos)} was not sorted! Was: $seq"""",
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistenceSpec.scala:111: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   IndependentlyOrdered.this.prefixes.apply(pos)
[warn]         s"""Messages sequence with prefix ${prefixes(pos)} was sorted! Was: $seq"""")
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistenceSpec.scala:114: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   results.find(((r: org.scalatest.matchers.MatchResult) => r.matches.unary_!)).get
[warn]       else results.find(r ? !r.matches).get
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorBoundedStashingSpec.scala:65: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def atStartup: Unit = SteppingInMemPersistentActorBoundedStashingSpec.this.system.eventStream.publish(akka.testkit.TestEvent.Mute.apply({

[warn]   <artifact> val x$13: String = ".*received dead letter from.*Cmd.*";

[warn]   <artifact> val x$14: String = akka.testkit.EventFilter.warning$default$1;

[warn]   <a
[warn]   override def atStartup: Unit = {
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorDeleteFailureSpec.scala:19: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class DeleteTo(n: Long)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorDeleteFailureSpec.scala:28: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (probe).
[warn]   class DoesNotHandleDeleteFailureActor(name: String, probe: ActorRef) extends PersistentActor {
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorFailureSpec.scala:105: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (recoveryFailureProbe).
[warn]   class FailingRecovery(name: String, recoveryFailureProbe: Option[ActorRef]) extends ExamplePersistentActor(name) {
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorFailureSpec.scala:61: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]           a.payload.collectFirst {
[warn]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:24: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Persist(id: Int, msgs: Any*) extends Command
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:25: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PersistAsync(id: Int, msgs: Any*) extends Command
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:26: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Multi(cmd: Command*) extends Command
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:27: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Echo(id: Int) extends Command
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:28: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Fail(ex: Throwable) extends Command
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:29: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Done(id: Int, sub: Int)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:31: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PreStart(name: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:32: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PreRestart(name: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:33: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PostRestart(name: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:34: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PostStop(name: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:96: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Msgs(msg: Any*)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:60: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def P(p: Persist): Unit = {
[info]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorJournalProtocolSpec.scala:67: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]     def PA(p: PersistAsync): Unit = {
[info]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorSpec.scala:31: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   d.asInstanceOf[Some[akka.actor.ActorRef]]
[warn]       case d @ Some(ref: ActorRef) ? askedForDelete = d.asInstanceOf[Some[ActorRef]]
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorSpec.scala:768: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   this.receiveN(40).asInstanceOf[scala.collection.immutable.Seq[String]]
[warn]       val all: Seq[String] = this.receiveN(40).asInstanceOf[Seq[String]] // each command = 1 reply + 3 event-replies
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentActorStashingSpec.scala:25: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   d.asInstanceOf[Some[akka.actor.ActorRef]]
[warn]       case d @ Some(ref: ActorRef) ? askedForDelete = d.asInstanceOf[Some[ActorRef]]
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\PersistentViewSpec.scala:122: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]         context.become {
[warn]                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\SnapshotFailureRobustnessSpec.scala:20: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Cmd(payload: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\SnapshotFailureRobustnessSpec.scala:21: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class DeleteSnapshot(seqNr: Int)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\SnapshotFailureRobustnessSpec.scala:22: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class DeleteSnapshots(criteria: SnapshotSelectionCriteria)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\SnapshotSerializationSpec.scala:43: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = {

[warn]   val bStream: java.io.ByteArrayInputStream = new java.io.ByteArrayInputStream(bytes);

[warn]   val reader: java.io.BufferedReader = new java.io.BufferedReader(new java.io.InputStreamReader(bStream));

[warn]   new SnapshotSerializationSpec
[warn]     def fromBinary(bytes: Array[Byte], clazz: Option[Class[_]]): AnyRef = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\SnapshotSpec.scala:18: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   snapshot.asInstanceOf[List[String]]
[warn]       case SnapshotOffer(_, snapshot: List[_]) ? state = snapshot.asInstanceOf[List[String]]
[warn]                                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\fsm\PersistentFSMSpec.scala:353: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Item(id: String, name: String, price: Float)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\fsm\PersistentFSMSpec.scala:363: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NonEmptyShoppingCart(items: Seq[Item]) extends ShoppingCart {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\fsm\PersistentFSMSpec.scala:371: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class AddItem(item: Item) extends Command
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\fsm\PersistentFSMSpec.scala:379: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ItemAdded(item: Item) extends DomainEvent
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\fsm\PersistentFSMSpec.scala:386: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PurchaseWasMade(items: Seq[Item]) extends ReportEvent
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\InmemEventAdaptersSpec.scala:44: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   InmemEventAdaptersSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val extendedActorSystem = system.asInstanceOf[ExtendedActorSystem]
[warn]                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\InmemEventAdaptersSpec.scala:119: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] case class ReadMeEvent()
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\InmemEventAdaptersSpec.scala:125: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] case class WriteMeEvent()
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\InmemEventAdaptersSpec.scala:132: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] final case class SampleEvent() extends EventMarkerInterface
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\InmemEventAdaptersSpec.scala:133: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info] final case class PreciseAdapterEvent() extends EventMarkerInterface
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\InmemEventAdaptersSpec.scala:119: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class ReadMeEvent()
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\InmemEventAdaptersSpec.scala:125: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class WriteMeEvent()
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\SteppingInmemJournal.scala:76: [scapegoat] List append is slow
[info]   List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).
[info]     case Token if queuedOps.isEmpty ? queuedTokenRecipients = queuedTokenRecipients :+ sender()
[info]                                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\SteppingInmemJournal.scala:43: [scapegoat] Prefer Map.empty
[info]   `Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Map.apply[String, Nothing]()
[info]   private[this] var _current: Map[String, ActorRef] = Map()
[info]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\scala\akka\persistence\journal\chaos\ChaosJournal.scala:23: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("recovery failed when reading highest sequence number").s()
[warn]   extends TestException(s"recovery failed when reading highest sequence number")
[warn]                         ^
[info] [warn] [scapegoat] Analysis complete: 28 files - 0 errors 30 warns 48 infos
[warn] there were 7 deprecation warnings; re-run with -deprecation for details
[warn] 31 warnings found
[info] 注: D:\data\akka-akka\akka-akka-4f9dc51\akka-persistence\src\test\java\akka\persistence\fsm\AbstractPersistentFSMTest.java使用或覆盖了已过时的 API。
[info] 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。
[info] Compiling 5 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-http-tests\target\classes...
[info] Compiling 5 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-distributed-data-java\target\classes...
[info] Compiling 5 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-distributed-data-scala\target\classes...
[info] Compiling 27 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-cluster-java\target\classes...
[info] Compiling 8 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\target\classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:128: postfix operator milliseconds should be enabled
[warn] by making the implicit value scala.language.postfixOps visible.
[warn] This can be achieved by adding the import clause 'import scala.language.postfixOps'
[warn] or by setting the compiler option -language:postfixOps.
[warn] See the Scaladoc for value scala.language.postfixOps for a discussion
[warn] why the feature should be explicitly enabled.
[warn]         100 milliseconds,
[warn]             ^
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterSharding.scala:140: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.cluster.sharding.ClusterSharding = ClusterSharding.super.get(system)
[info]   override def get(system: ActorSystem): ClusterSharding = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:163: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: String = _
[warn]   def withRole(role: String): ClusterShardingSettings = copy(role = ClusterShardingSettings.roleOption(role))
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:165: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = _
[warn]   def withRole(role: Option[String]): ClusterShardingSettings = copy(role = role)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:167: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val rememberEntities: Boolean = _
[warn]   def withRememberEntities(rememberEntities: Boolean): ClusterShardingSettings =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:170: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val journalPluginId: String = _
[warn]   def withJournalPluginId(journalPluginId: String): ClusterShardingSettings =
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:173: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val snapshotPluginId: String = _
[warn]   def withSnapshotPluginId(snapshotPluginId: String): ClusterShardingSettings =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:176: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val tuningParameters: akka.cluster.sharding.ClusterShardingSettings.TuningParameters = _
[warn]   def withTuningParameters(tuningParameters: ClusterShardingSettings.TuningParameters): ClusterShardingSettings =
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:179: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stateStoreMode: String = _
[warn]   def withStateStoreMode(stateStoreMode: String): ClusterShardingSettings =
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:186: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val coordinatorSingletonSettings: akka.cluster.singleton.ClusterSingletonManagerSettings = _
[warn]   def withCoordinatorSingletonSettings(coordinatorSingletonSettings: ClusterSingletonManagerSettings): ClusterShardingSettings =
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:190: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val role: Option[String] = role
[warn]     role:                         Option[String]                           = role,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:191: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val rememberEntities: Boolean = rememberEntities
[warn]     rememberEntities:             Boolean                                  = rememberEntities,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:192: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val journalPluginId: String = journalPluginId
[warn]     journalPluginId:              String                                   = journalPluginId,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:193: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val snapshotPluginId: String = snapshotPluginId
[warn]     snapshotPluginId:             String                                   = snapshotPluginId,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:194: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val stateStoreMode: String = stateStoreMode
[warn]     stateStoreMode:               String                                   = stateStoreMode,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:195: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val tuningParameters: akka.cluster.sharding.ClusterShardingSettings.TuningParameters = tuningParameters
[warn]     tuningParameters:             ClusterShardingSettings.TuningParameters = tuningParameters,
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ClusterShardingSettings.scala:196: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val coordinatorSingletonSettings: akka.cluster.singleton.ClusterSingletonManagerSettings = coordinatorSingletonSettings
[warn]     coordinatorSingletonSettings: ClusterSingletonManagerSettings          = coordinatorSingletonSettings): ClusterShardingSettings =
[warn]     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\RemoveInternalClusterShardingData.scala:115: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Result(removals: Try[Removals])
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\RemoveInternalClusterShardingData.scala:116: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Removals(events: Boolean, snapshots: Boolean)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\RemoveInternalClusterShardingData.scala:203: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   RemoveInternalClusterShardingData.this.remainingPids.head
[warn]     currentPid = remainingPids.head
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\RemoveInternalClusterShardingData.scala:83: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val terminateSystem: Boolean = _).
[warn]   def remove(system: ActorSystem, journalPluginId: String, typeNames: Set[String],
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\Shard.scala:446: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[scala.concurrent.Future[Set[akka.cluster.sharding.ShardRegion.EntityId]]]()
[info]     entities.grouped(numberOfEntities).foldLeft((frequency, Set[Future[Set[EntityId]]]())) {
[info]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\Shard.scala:118: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (typeName).
[warn]   typeName:           String,
[warn]   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\Shard.scala:123: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (extractShardId).
[warn]   extractShardId:     ShardRegion.ExtractShardId,
[warn]   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\Shard.scala:284: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val msg: Any = _).
[warn]   def deliverTo(id: EntityId, msg: Any, payload: Msg, snd: ActorRef): Unit = {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:897: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   f.asInstanceOf[akka.cluster.sharding.ShardCoordinator.Internal.DomainEvent => Unit]
[warn]     context.become(waitingForUpdate(evt, f.asInstanceOf[DomainEvent ? Unit]), discardOld = false)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:766: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   st.unallocatedShards.==(null)
[warn]       if (st.unallocatedShards == null)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:143: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   currentShardAllocations.minBy
[warn]       val (regionWithLeastShards, _) = currentShardAllocations.minBy { case (_, v) ? v.size }
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:151: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   currentShardAllocations.minBy
[warn]         val (regionWithLeastShards, leastShards) = currentShardAllocations.minBy { case (_, v) ? v.size }
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:154: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   currentShardAllocations.collect[scala.collection.immutable.IndexedSeq[akka.cluster.sharding.ShardRegion.ShardId], scala.collection.immutable.Iterable[scala.collection.immutable.IndexedSeq[akka.cluster.sharding.ShardRegion.ShardId]]](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[(akka.actor.ActorRef, scala.collection.immutable.IndexedSeq[akka.cluster.sharding.ShardRegion.ShardId]),scala.collection.immutable.IndexedSeq[akka.cluste
[warn]         }.maxBy(_.size)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:482: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]                   }.recover {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:519: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]             }.recover {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardCoordinator.scala:568: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val default: A1 => B1 = _
[warn]       }.recover {
[warn]                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardRegion.scala:204: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   @SerialVersionUID(1L) case class GetClusterShardingStats(timeout: FiniteDuration) extends ShardRegionQuery
[info]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardRegion.scala:617: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def registrationMessage: Any = if (ShardRegion.this.entityProps.isDefined)

[warn]   ShardCoordinator.Internal.Register.apply(ShardRegion.this.self)

[warn] else

[warn]   ShardCoordinator.Internal.RegisterProxy.apply(ShardRegion.this.self)
[warn]   def registrationMessage: Any =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardRegion.scala:441: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   msg match {

[warn]   case (shard: akka.cluster.sharding.ShardRegion.ShardId)akka.cluster.sharding.ShardCoordinator.Internal.HostShard((shard @ _)) => {

[warn]     ShardRegion.this.log.debug("Host Shard [{}] ", sh
[warn]   def receiveCoordinatorMessage(msg: CoordinatorMessage): Unit = msg match {
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster-sharding\src\main\scala\akka\cluster\sharding\ShardRegion.scala:552: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shards: Set[akka.cluster.sharding.ShardRegion.ShardId] = ShardRegion.this.regions.apply(ref)
[warn]       val shards = regions(ref)
[warn]           ^
[info] [warn] [scapegoat] Analysis complete: 8 files - 0 errors 31 warns 5 infos
[warn] 32 warnings found
[info] Compiling 18 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-samples\akka-sample-cluster-scala\target\classes...
[info] Compiling 8 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\circuitbreaker\CircuitBreakerProxy.scala:57: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait CircuitBreakerResponse
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\circuitbreaker\CircuitBreakerProxy.scala:60: [scapegoat] Lonely sealed trait
[warn]   A sealed trait that is not extended is considered dead code.
[warn]   sealed trait CircuitBreakerEvent
[warn]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\circuitbreaker\askExtensions.scala:69: [scapegoat] Match instead of a partial function
[info]   A map match can be replaced with a partial function for greater readability.
[info]   CircuitBreakerAwareFuture.this.future.flatMap[Any](((x$1: Any) => x$1 match {

[info]   case (failedMsg: Any)akka.contrib.circuitbreaker.CircuitBreakerProxy.CircuitOpenFailure(_) => scala.concurrent.Future.failed[Nothing](throwing)

[info]   case (result @ _) => scala.concurrent.Future.successful[Any](result)

[info] }))
[info]     future.flatMap {
[info]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:39: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaLogger.this.log(java.util.logging.Level.WARNING, null, event)
[warn]     case event: Warning                ? log(logging.Level.WARNING, null, event)
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:40: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaLogger.this.log(java.util.logging.Level.INFO, null, event)
[warn]     case event: Info                   ? log(logging.Level.INFO, null, event)
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:41: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaLogger.this.log(java.util.logging.Level.CONFIG, null, event)
[warn]     case event: Debug                  ? log(logging.Level.CONFIG, null, event)
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:53: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   record.setSourceMethodName(null)
[warn]     record.setSourceMethodName(null) // lost forever
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:74: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaLoggingAdapter.this.log(java.util.logging.Level.SEVERE, null, message)
[warn]     log(logging.Level.SEVERE, null, message)
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:82: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaLoggingAdapter.this.log(java.util.logging.Level.WARNING, null, message)
[warn]     log(logging.Level.WARNING, null, message)
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:86: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaLoggingAdapter.this.log(java.util.logging.Level.INFO, null, message)
[warn]     log(logging.Level.INFO, null, message)
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:90: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JavaLoggingAdapter.this.log(java.util.logging.Level.CONFIG, null, message)
[warn]     log(logging.Level.CONFIG, null, message)
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:124: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   record.setSourceClassName(null)
[warn]       record.setSourceClassName(null)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:125: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   record.setSourceMethodName(null)
[warn]       record.setSourceMethodName(null)
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:101: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   JavaLoggingAdapter.this.loggingExecutionContext.get
[warn]       implicit val context = loggingExecutionContext.get
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:121: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   source.get
[warn]       record.setSourceClassName(source.get.getClassName)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\jul\JavaLogger.scala:122: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   source.get
[warn]       record.setSourceMethodName(source.get.getMethodName)
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\mailbox\PeekMailbox.scala:43: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn] class PeekMailboxType(settings: ActorSystem.Settings, config: Config) extends MailboxType {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\mailbox\PeekMailbox.scala:55: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (owner).
[warn] class PeekMailbox(owner: ActorRef, system: ActorSystem, maxRetries: Int)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\mailbox\PeekMailbox.scala:96: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val owner: akka.actor.ActorRef = _
[warn]   override def cleanUp(owner: ActorRef, deadLetters: MessageQueue): Unit = {
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:93: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var next: Entry[T] = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:193: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       head.next = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:141: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   entry.next.!=(null)
[warn]       } else if (entry.next != null) remove(entry, entry.next)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:145: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   WorkList.this.head.next.==(null)
[warn]     if (head.next == null) false else remove(head, head.next)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:166: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   entry.next.!=(null)
[warn]       } else if (entry.next != null) process(entry, entry.next)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:170: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   WorkList.this.head.next.==(null)
[warn]     if (head.next == null) false else process(head, head.next)
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:179: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   other.head.next.!=(null)
[warn]     if (other.head.next != null) {
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:191: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   WorkList.this.head.next.==(null)
[warn]     if (head.next == null) false
[warn]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:136: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   entry.ref.get
[warn]       if (entry.ref.get == ref) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:158: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   entry.ref.get
[warn]       val processed = processFn(entry.ref.get)
[warn]                                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\Aggregator.scala:48: [scapegoat] Unnecessary if condition.
[info]   If comparison is not needed. Use the condition, e.g. instead of if (a == b) true else false, use a == b or instead of if (a == b) false else true, use !(a == b).
[info]   if (Aggregator.this.processing.&&(Aggregator.this.addBuffer.remove(fn)))

[info]   true

[info] else

[info]   false
[info]     else if (processing && (addBuffer remove fn)) true
[info]          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\ReceivePipeline.scala:11: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Inner(transformedMsg: Any) extends Delegation {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\ReceivePipeline.scala:21: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[ReceivePipeline] case class InnerAndAfter(transformedMsg: Any, after: Unit ? Unit) extends Delegation
[info]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\ReceivePipeline.scala:91: [scapegoat] Pointless type bounds
[warn]   Type bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?
[warn]   type A1
[warn]     override def applyOrElse[A1 <: Any, B1 >: Unit](m: A1, default: A1 ? B1): B1 = {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\pattern\ReliableProxy.scala:325: [scapegoat] Var in closure
[warn]   Closing over a var can lead to subtle bugs.
[warn]   x$4.==(ReliableProxy.this.attemptedReconnects)
[warn]       if (maxConnectAttempts exists (_ == attemptedReconnects)) {
[warn]                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\throttle\TimerBasedThrottler.scala:230: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   d.queue.isEmpty.unary_!
[info]     case Event(SetTarget(t @ Some(_)), d) if !d.queue.isEmpty ?
[info]                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\throttle\TimerBasedThrottler.scala:230: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   d.queue.isEmpty.unary_!
[info]     case Event(SetTarget(t @ Some(_)), d) if !d.queue.isEmpty ?
[info]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\throttle\TimerBasedThrottler.scala:300: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   data.target.get
[warn]     queue.take(nrOfMsgToSend).foreach(x ? data.target.get.tell(x.message, x.sender))
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-contrib\src\main\scala\akka\contrib\throttle\TimerBasedThrottler.scala:289: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val rate: akka.contrib.throttle.Throttler.Rate = _
[warn]   private def startTimer(rate: Rate) = setTimer("morePermits", Tick, rate.duration, true)
[warn]                          ^
[info] [warn] [scapegoat] Analysis complete: 8 files - 0 errors 33 warns 6 infos
[warn] there was one deprecation warning; re-run with -deprecation for details
[warn] 33 warnings found
[info] Compiling 145 Scala sources and 17 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\target\test-classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\ActorMaterializerSpec.scala:42: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ActorMaterializer.create(ActorMaterializerSpec.this.system).asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]       val m = ActorMaterializer.create(system).asInstanceOf[ActorMaterializerImpl]
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslConsistencySpec.scala:12: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ScalaSubSource.super.<init>(null, null, null)
[warn]   class ScalaSubSource[Out, Mat] extends impl.SubFlowImpl[Out, Out, Mat, scaladsl.Source[Out, Mat]#Repr, scaladsl.RunnableGraph[Mat]](null, null, null)
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslConsistencySpec.scala:13: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ScalaSubFlow.super.<init>(null, null, null)
[warn]   class ScalaSubFlow[In, Out, Mat] extends impl.SubFlowImpl[Out, Out, Mat, scaladsl.Flow[In, Out, Mat]#Repr, scaladsl.Sink[In, Mat]](null, null, null)
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:165: [scapegoat] Avoid Traversable.size == 0
[warn]   Traversable.size can be slow for some data structures, prefer Traversable.isEmpty, which is O(1).
[warn]   matches.length.==(0)
[warn]       if (matches.length == 0) {
[warn]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:61: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TestCase(name: String, sClass: Option[Class[_]], jClass: Option[Class[_]], jFactory: Option[Class[_]])
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:109: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private case class Ignore(cls: Class[_] ? Boolean, name: String ? Boolean, parameters: Int ? Boolean, paramTypes: List[Class[_]] ? Boolean)
[info]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:191: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Method(name: String, parameterTypes: List[Class[_]], returnType: Class[_], declaringClass: Class[_])
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:199: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class MatchFailure(s: Method, j: Method, reason: String = "") extends MatchResult { val matches = false }
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:200: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Match(s: Method, j: Method, reason: String = "") extends MatchResult { val matches = true }
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:146: [scapegoat] List append is slow
[info]   List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).
[info]       m.copy(name = m.name.filter(Character.isLetter), parameterTypes = m.parameterTypes.dropRight(1) :+ classOf[akka.japi.function.Function[_, _]])
[info]                                                                                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:145: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]     case m if m.parameterTypes.size > 1 ?
[info]                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:145: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]     case m if m.parameterTypes.size > 1 ?
[info]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:238: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toList on a List.
[warn]   scalaParams.toList
[warn]     (scalaParams.toList, javaParams.toList) match {
[warn]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:238: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toList on a List.
[warn]   javaParams.toList
[warn]     (scalaParams.toList, javaParams.toList) match {
[warn]                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\DslFactoriesConsistencySpec.scala:246: [scapegoat] Unnecessary if condition.
[info]   If comparison is not needed. Use the condition, e.g. instead of if (a == b) true else false, use a == b or instead of if (a == b) false else true, use !(a == b).
[info]   if (DslFactoriesConsistencySpec.this.scala -> java types.contains[(Class[_], Class[_])](p))

[info]   true

[info] else

[info]   false
[info]     else if (`scala -> java types` contains p) true
[info]          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\FusingSpec.scala:105: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.stream.impl.fusing.GraphInterpreter.currentInterpreter.log.asInstanceOf[akka.event.BusLogging]
[warn]         val bus = GraphInterpreter.currentInterpreter.log.asInstanceOf[BusLogging]
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\FusingSpec.scala:124: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.stream.impl.fusing.GraphInterpreter.currentInterpreter.log.asInstanceOf[akka.event.BusLogging]
[warn]         val bus = GraphInterpreter.currentInterpreter.log.asInstanceOf[BusLogging]
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\FusingSpec.scala:21: [scapegoat] Broken odd check
[warn]   Code that attempts to check for oddness using `x % 2 == 1` will fail on negative numbers. Consider using `x % 2 != 0`.
[warn]   x$1.%(2).==(1)
[warn]     Source.unfold(1)(x ? Some(x → x)).filter(_ % 2 == 1)
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\FusingSpec.scala:33: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(akka.stream.Attributes.extractName(curr, "unknown"))

[warn] else

[warn]   ()
[warn]       if (Debug) println(extractName(curr, "unknown"))
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\FusingSpec.scala:28: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   starts.head
[warn]     val start = starts.head
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\FusingSpec.scala:40: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   outs.head
[warn]           rec(owner(outs.head))
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:22: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n      my-dispatcher1 = ${akka.test.stream-dispatcher}\n      my-dispatcher2 = ${akka.test.stream-dispatcher}\n    ").s()
[warn]     s"""
[warn]     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:39: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TotalDemand(elements: Long)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:40: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Produce(elem: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:41: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Err(reason: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorPublisherSpec.scala:42: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ErrThenStop(reason: String)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorSubscriberSpec.scala:63: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Msg(id: Int, replyTo: ActorRef)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorSubscriberSpec.scala:64: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Work(id: Int)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorSubscriberSpec.scala:65: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Reply(id: Int)
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\actor\ActorSubscriberSpec.scala:66: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Done(id: Int)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\extra\FlowTimedSpec.scala:79: [scapegoat] Broken odd check
[warn]   Code that attempts to check for oddness using `x % 2 == 1` will fail on negative numbers. Consider using `x % 2 != 0`.
[warn]   in.%(2).==(1)
[warn]       val flow: Flow[Int, Long, _] = Flow[Int].map(_.toLong).timedIntervalBetween(in ? in % 2 == 1, d ? probe.ref ! d)
[warn]                                                                                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\extra\FlowTimedSpec.scala:74: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]     import akka.stream.extra.Implicits.TimedFlowDsl
[info]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\FixedBufferSpec.scala:98: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   buf.asInstanceOf[AnyRef{def readIdx_=(l: Long): Unit; def writeIdx_=(l: Long): Unit}]
[warn]         val cheat = buf.asInstanceOf[{ def readIdx_=(l: Long): Unit; def writeIdx_=(l: Long): Unit }]
[warn]                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\FixedBufferSpec.scala:62: [scapegoat] Avoid (j to k - 1)
[info]   A range in the following format (j to k - 1) can be simplified to (j until k).
[info]   scala.this.Predef.intWrapper(1).to(size.-(1)).foreach[org.scalatest.Assertion](((elem: Int) => FixedBufferSpec.this.convertToAnyShouldWrapper[Int](buf.dequeue())(org.scalactic.source.Position.apply("F
[info]         for (elem ← 1 to size - 1) buf.dequeue() should be(elem)
[info]                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\ResizableMultiReaderRingBufferSpec.scala:175: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   activeCursors.apply(index)
[warn]             val cursor = activeCursors(index)
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\ResizableMultiReaderRingBufferSpec.scala:191: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   Test.this.cursors.cursors.apply(cursorIx)
[warn]       try read(cursors.cursors(cursorIx)) catch { case NothingToReadException ? null }
[warn]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\ResizableMultiReaderRingBufferSpec.scala:163: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]           val activeCursorCount = activeCursors.size
[info]                                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:190: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TestPublisher(owner: Module, port: OutPort) extends Publisher[Any] with Subscription {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:205: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TestSubscriber(owner: Module, port: InPort) extends Subscriber[Any] {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:46: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   stage1.outPorts.head
[warn]       val flow12 = stage1.compose(stage2, Keep.none).wire(stage1.outPorts.head, stage2.inPorts.head)
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:46: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   stage2.inPorts.head
[warn]       val flow12 = stage1.compose(stage2, Keep.none).wire(stage1.outPorts.head, stage2.inPorts.head)
[warn]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:71: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   source0.outPorts.head
[warn]       val source012 = source0.compose(flow12, Keep.none).wire(source0.outPorts.head, flow12.inPorts.head)
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:71: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   flow12.inPorts.head
[warn]       val source012 = source0.compose(flow12, Keep.none).wire(source0.outPorts.head, flow12.inPorts.head)
[warn]                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:79: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   flow12.outPorts.head
[warn]       val sink123 = flow12.compose(sink3, Keep.none).wire(flow12.outPorts.head, sink3.inPorts.head)
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:79: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   sink3.inPorts.head
[warn]       val sink123 = flow12.compose(sink3, Keep.none).wire(flow12.outPorts.head, sink3.inPorts.head)
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:87: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   source0.outPorts.head
[warn]       val runnable0123a = source0.compose(sink123, Keep.none).wire(source0.outPorts.head, sink123.inPorts.head)
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:87: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   sink123.inPorts.head
[warn]       val runnable0123a = source0.compose(sink123, Keep.none).wire(source0.outPorts.head, sink123.inPorts.head)
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:88: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   source012.outPorts.head
[warn]       val runnable0123b = source012.compose(sink3, Keep.none).wire(source012.outPorts.head, sink3.inPorts.head)
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:88: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   sink3.inPorts.head
[warn]       val runnable0123b = source012.compose(sink3, Keep.none).wire(source012.outPorts.head, sink3.inPorts.head)
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:93: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   flow12.outPorts.head
[warn]           .compose(sink3, Keep.none).wire(flow12.outPorts.head, sink3.inPorts.head)
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:93: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   sink3.inPorts.head
[warn]           .compose(sink3, Keep.none).wire(flow12.outPorts.head, sink3.inPorts.head)
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:111: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   stage2.outPorts.head
[warn]         .compose(sink, Keep.none).wire(stage2.outPorts.head, sink.inPorts.head)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:111: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   sink.inPorts.head
[warn]         .compose(sink, Keep.none).wire(stage2.outPorts.head, sink.inPorts.head)
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:240: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: StreamLayoutSpec.this.FlatTestMaterializer = new StreamLayoutSpec.this.FlatTestMaterializer(topLevel)
[warn]     val materializer = new FlatTestMaterializer(topLevel)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\StreamLayoutSpec.scala:262: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val module: akka.stream.impl.StreamLayout.Module = _
[warn]       atomics ++ composites.flatMap(getAllAtomic)
[warn]                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\TimeoutsSpec.scala:336: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\TimeoutsSpec.scala:320: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   error1.isInstanceOf[java.util.concurrent.TimeoutException]
[warn]       error1.isInstanceOf[TimeoutException] should be(true)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpec.scala:155: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val zip: akka.stream.scaladsl.Zip[Int,Int] = new akka.stream.scaladsl.Zip[Int,Int]()
[warn]       val zip = new Zip[Int, Int]
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpec.scala:183: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val zip: akka.stream.scaladsl.Zip[Int,Int] = new akka.stream.scaladsl.Zip[Int,Int]()
[warn]       val zip = new Zip[Int, Int]
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpec.scala:184: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val bcast: akka.stream.scaladsl.Broadcast[(Int, Int)] = akka.stream.scaladsl.Broadcast.apply[(Int, Int)](2, akka.stream.scaladsl.Broadcast.apply$default$2[(Int, Int)])
[warn]       val bcast = Broadcast[(Int, Int)](2)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:337: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   s.asInstanceOf[akka.stream.stage.Stage[Any,Any]]
[warn]         (_) ? s.asInstanceOf[Stage[Any, Any]],
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:376: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   OneBoundedSetupWithDecider.this.ops.apply(i).asInstanceOf[akka.stream.stage.GraphStageWithMaterializedValue[akka.stream.FlowShape[_, _], _]]
[warn]         val stage = ops(i).asInstanceOf[GraphStageWithMaterializedValue[FlowShape[_, _], _]]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:138: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("----- NEXT: ", " ", "").s(this, elem))

[warn] else

[warn]   ()
[warn]         if (GraphInterpreter.Debug) println(s"----- NEXT: $this $elem")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:144: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("----- COMPLETE ", "").s(this))

[warn] else

[warn]   ()
[warn]         if (GraphInterpreter.Debug) println(s"----- COMPLETE $this")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:150: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("----- FAIL ", "").s(this))

[warn] else

[warn]   ()
[warn]         if (GraphInterpreter.Debug) println(s"----- FAIL $this")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:167: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("----- REQ ", "").s(this))

[warn] else

[warn]   ()
[warn]         if (GraphInterpreter.Debug) println(s"----- REQ $this")
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:173: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (false)

[warn]   scala.this.Predef.println(scala.StringContext.apply("----- CANCEL ", "").s(this))

[warn] else

[warn]   ()
[warn]         if (GraphInterpreter.Debug) println(s"----- CANCEL $this")
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:15: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.stream.impl.fusing.GraphInterpreter.GraphAssembly
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:109: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class OnComplete(source: GraphStageLogic) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:110: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Cancel(source: GraphStageLogic) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:111: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class OnError(source: GraphStageLogic, cause: Throwable) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:112: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class OnNext(source: GraphStageLogic, elem: Any) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:113: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class RequestOne(source: GraphStageLogic) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:114: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class RequestAnother(source: GraphStageLogic) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:115: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class PreStart(source: GraphStageLogic) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:116: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class PostStop(source: GraphStageLogic) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:353: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class OnError(cause: Throwable) extends TestEvent
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:354: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class OnNext(elem: Any) extends TestEvent
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:89: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Builder.this._interpreter.init(null)
[warn]         _interpreter.init(null)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:261: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   PortTestSetup.this.interpreter.init(null)
[warn]     interpreter.init(null)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:370: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   ins.update(OneBoundedSetupWithDecider.this.ops.length, null)
[warn]       ins(ops.length) = null
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:372: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   outs.update(0, null)
[warn]       outs(0) = null
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:388: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   OneBoundedSetupWithDecider.this.interpreter.init(null)
[warn]       interpreter.init(null)
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:186: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val in: akka.stream.Inlet[Int] = akka.stream.Inlet.apply[Int]("Propagate.in")
[warn]       val in = Inlet[Int]("Propagate.in")
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\GraphInterpreterSpecKit.scala:187: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] val out: akka.stream.Outlet[Int] = akka.stream.Outlet.apply[Int]("Propagate.out")
[warn]       val out = Outlet[Int]("Propagate.out")
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\IteratorInterpreterSpec.scala:102: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class NaiveTake[T](count: Int) extends SimpleLinearGraphStage[T] {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\IteratorInterpreterSpec.scala:124: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ByteStringBatcher(threshold: Int, compact: Boolean = true) extends SimpleLinearGraphStage[ByteString] {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\KeepGoingStageSpec.scala:21: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Register(probe: ActorRef) extends PingCmd
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\KeepGoingStageSpec.scala:33: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PingRef(private val cb: AsyncCallback[PingCmd]) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\LifecycleInterpreterSpec.scala:145: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[akka] case class PreStartAndPostStopIdentity[T](
[info]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\LifecycleInterpreterSpec.scala:175: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[akka] case class PreStartFailer[T](pleaseThrow: () ? Unit) extends SimpleLinearGraphStage[T] {
[info]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\LifecycleInterpreterSpec.scala:190: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   private[akka] case class PostStopFailer[T](pleaseThrow: () ? Unit) extends SimpleLinearGraphStage[T] {
[info]                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\LifecycleInterpreterSpec.scala:95: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[Nothing]()
[info]       lastEvents() should ===(Set())
[info]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSinkSpec.scala:113: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]           materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSinkSpec.scala:134: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]           materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSinkSpec.scala:114: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FileSinkSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$4: akka.actor.ActorRef) => x$4.path.toString().contains("fileSink"))).get
[warn]           val ref = expectMsgType[Children].children.find(_.path.toString contains "fileSink").get
[warn]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSinkSpec.scala:135: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FileSinkSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$5: akka.actor.ActorRef) => x$5.path.toString().contains("File"))).get
[warn]           val ref = expectMsgType[Children].children.find(_.path.toString contains "File").get
[warn]                                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSinkSpec.scala:109: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]         val materializer = ActorMaterializer()(sys)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSinkSpec.scala:125: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]         val materializer = ActorMaterializer()(sys)
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:180: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]         materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:198: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]         materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:181: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FileSourceSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$5: akka.actor.ActorRef) => x$5.path.toString().contains("fileSource"))).get
[warn]         val ref = expectMsgType[Children].children.find(_.path.toString contains "fileSource").get
[warn]                                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:199: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FileSourceSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$6: akka.actor.ActorRef) => x$6.path.toString().contains("File"))).get
[warn]         val ref = expectMsgType[Children].children.find(_.path.toString contains "File").get
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:96: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toString on instance of String.
[warn]   nextChunk().toString
[warn]       c.expectNext().utf8String should ===(nextChunk().toString)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:98: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toString on instance of String.
[warn]   nextChunk().toString
[warn]       c.expectNext().utf8String should ===(nextChunk().toString)
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:102: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toString on instance of String.
[warn]   nextChunk().toString
[warn]       var expectedChunk = nextChunk().toString
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:105: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toString on instance of String.
[warn]   nextChunk().toString
[warn]         expectedChunk = nextChunk().toString
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:160: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val settings: akka.stream.io.FileSourceSpec.Settings = _
[warn]       Settings(chunkSize = 2048, readAhead = 4)) foreach { settings ?
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:176: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]       val materializer = ActorMaterializer()(sys)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\FileSourceSpec.scala:190: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]       val materializer = ActorMaterializer()(sys)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\InputStreamSinkSpec.scala:206: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]         materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\InputStreamSinkSpec.scala:156: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   bytes.apply(i.*(2))
[warn]         readN(inputStream, 8) should ===((8, bytes(i * 2) ++ bytes(i * 2 + 1)))
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\InputStreamSinkSpec.scala:156: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   bytes.apply(i.*(2).+(1))
[warn]         readN(inputStream, 8) should ===((8, bytes(i * 2) ++ bytes(i * 2 + 1)))
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\InputStreamSinkSpec.scala:207: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   InputStreamSinkSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$12: akka.actor.ActorRef) => x$12.path.toString().contains("inputStreamSink"))).get
[warn]         val ref = expectMsgType[Children].children.find(_.path.toString contains "inputStreamSink").get
[warn]                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\InputStreamSinkSpec.scala:203: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]       val materializer = ActorMaterializer()(sys)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSourceSpec.scala:33: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.util.Random.nextInt(1024).asInstanceOf[Byte]
[warn]   val bytesArray = Array.fill[Byte](3)(Random.nextInt(1024).asInstanceOf[Byte])
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSourceSpec.scala:137: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]         materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSourceSpec.scala:138: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   OutputStreamSourceSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$7: akka.actor.ActorRef) => x$7.path.toString().contains("outputStreamSource"))).get
[warn]         val ref = expectMsgType[Children].children.find(_.path.toString contains "outputStreamSource").get
[warn]                                                                                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSourceSpec.scala:50: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]     awaitAssert(threadsBlocked should ===(Seq()), 5.seconds, interval = 500.millis)
[info]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSourceSpec.scala:116: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   immutable.this.List.fill[akka.util.ByteString](17)(OutputStreamSourceSpec.this.byteString).toSeq
[warn]       probe.expectNextN(List.fill(17)(byteString).toSeq)
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSourceSpec.scala:36: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val timeout: scala.concurrent.duration.Duration = _
[warn]   def expectTimeout[T](f: Future[T], timeout: Duration) =
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\OutputStreamSourceSpec.scala:133: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]       val materializer = ActorMaterializer()(sys)
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpHelper.scala:20: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ClientWrite(bytes: ByteString) extends NoSerializationVerificationNeeded
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpHelper.scala:21: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ClientRead(count: Int, readTo: ActorRef) extends NoSerializationVerificationNeeded
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpHelper.scala:22: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ClientClose(cmd: Tcp.CloseCommand) extends NoSerializationVerificationNeeded
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpHelper.scala:23: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ReadResult(bytes: ByteString) extends NoSerializationVerificationNeeded
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpHelper.scala:28: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class PingClose(requester: ActorRef)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:51: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$2.asInstanceOf[Byte]
[warn]       val expectedOutput = ByteString(Array.tabulate(256)(_.asInstanceOf[Byte]))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:63: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$4.asInstanceOf[Byte]
[warn]       val expectedOutput = ByteString(Array.tabulate(256)(_.asInstanceOf[Byte]))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:436: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$21.asInstanceOf[Byte]
[warn]       val expectedOutput = ByteString(Array.tabulate(256)(_.asInstanceOf[Byte]))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:459: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$24.asInstanceOf[Byte]
[warn]       val expectedOutput = ByteString(Array.tabulate(256)(_.asInstanceOf[Byte]))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:409: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("$a").s()
[warn]       system2.actorSelection(akka.io.Tcp(system2).getManager.path / "selectors" / s"$$a" / "*") ! Kill
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TcpSpec.scala:527: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   x$27.head
[warn]       }).grouped(2).take(1).map(_.head)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TlsSpec.scala:102: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply(" ----------- truncated ").s()
[warn]         case SessionTruncated   ? system.log.debug(s" ----------- truncated ")
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TlsSpec.scala:149: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       var binding: Tcp.ServerBinding = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TlsSpec.scala:159: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       var binding: Tcp.ServerBinding = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TlsSpec.scala:179: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]             var session: SSLSession = null
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TlsSpec.scala:304: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         var session: SSLSession = null
[warn]             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\io\TlsSpec.scala:59: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn]   class Timeout(duration: FiniteDuration)(implicit system: ActorSystem) extends GraphStage[FlowShape[ByteString, ByteString]] {
[warn]                                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\ActorRefSinkSpec.scala:15: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Fw(ref: ActorRef) extends Actor {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\AttributesSpec.scala:30: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[Nothing] = _
[warn]     override protected def newInstance(shape: SinkShape[Nothing]): SinkModule[Nothing, Future[Attributes]] =
[warn]                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\BidiFlowSpec.scala:110: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import Attributes._
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:137: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m1.isInstanceOf[akka.NotUsed]
[warn]       m1.isInstanceOf[NotUsed] should be(true)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:138: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m2.isInstanceOf[akka.NotUsed]
[warn]       m2.isInstanceOf[NotUsed] should be(true)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:150: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m1.isInstanceOf[akka.NotUsed]
[warn]       m1.isInstanceOf[NotUsed] should be(true)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:151: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m2.isInstanceOf[akka.NotUsed]
[warn]       m2.isInstanceOf[NotUsed] should be(true)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:152: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m3.isInstanceOf[akka.NotUsed]
[warn]       m3.isInstanceOf[NotUsed] should be(true)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:163: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m1.isInstanceOf[akka.NotUsed]
[warn]           m1.isInstanceOf[NotUsed] should be(true)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:164: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m2.isInstanceOf[akka.NotUsed]
[warn]           m2.isInstanceOf[NotUsed] should be(true)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowConcatSpec.scala:165: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   m3.isInstanceOf[akka.NotUsed]
[warn]           m3.isInstanceOf[NotUsed] should be(true)
[warn]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowDelaySpec.scala:74: [scapegoat] List append is slow
[info]   List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).
[info]         1200.millis) should ===((1 to 15).toList :+ 20)
[info]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowDispatcherSpec.scala:11: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("my-dispatcher = ${akka.test.stream-dispatcher}").s()
[warn] class FlowDispatcherSpec extends StreamSpec(s"my-dispatcher = $${akka.test.stream-dispatcher}") {
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowExpandSpec.scala:25: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   implicit val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(FlowExpandSpec.this.settings.withFuzzing(false))(FlowExpandSpec.this.system)
[warn]       implicit val materializer = ActorMaterializer(settings.withFuzzing(false))
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFilterSpec.scala:28: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]       def script = Script(TestConfig.RandomTestRange map { _ ? val x = random.nextInt(); Seq(x) → (if ((x & 1) == 0) Seq(x) else Seq()) }: _*)
[info]                                                                                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFilterSpec.scala:68: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]           Seq(x) → (if ((x & 1) == 1) Seq(x) else Seq())
[info]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFilterSpec.scala:33: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val settings: akka.stream.ActorMaterializerSettings = akka.stream.ActorMaterializerSettings.apply(FlowFilterSpec.this.system).withInputBuffer(1, 1)
[warn]       val settings = ActorMaterializerSettings(system)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFilterSpec.scala:35: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   implicit val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(settings)(FlowFilterSpec.this.system)
[warn]       implicit val materializer = ActorMaterializer(settings)
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFlattenMergeSpec.scala:61: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FlowFlattenMergeSpec.this.intercept[org.scalatest.exceptions.TestFailedException](FlowFlattenMergeSpec.this.convertScalaFuture[Nothing](Source.failed[Nothing](ex).flatMapMerge[Nothing, Nothing](1, {

[warn]   ((x: Nothing) => scala.this.Predef.identity[Nothing](x))

[warn] }).runWith[scala.concurrent.Future[Nothing]](Sink.head[Nothing])(FlowFlattenMergeSpec.this.materializer)).futureValue(FlowFlattenMergeSpec.this.patience, org.scalactic.source.Position.apply("FlowFlattenMergeSpec.scala", "D:\\data\\akka-akka
[warn]       }.cause.get should ===(ex)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFlattenMergeSpec.scala:71: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FlowFlattenMergeSpec.this.intercept[org.scalatest.exceptions.TestFailedException](FlowFlattenMergeSpec.this.convertScalaFuture[Int](Source.apply[akka.stream.scaladsl.Source[Int,akka.NotUsed]](immutable.this.List.apply[akka.stream.scaladsl.Source[Int,akka.NotUsed]](FlowFlattenMergeSpec.this.blocked, FlowFlattenMergeSpec.this.blocked)).++[akka.stream.scaladsl.Source[Int,akka.NotUsed], akka.NotUsed](Source.failed[Nothing](ex)).flatMapMerge[Int, akka.NotUsed](10, {

[warn]   ((x: akka.stream.scaladsl.Sourc
[warn]       }.cause.get should ===(ex)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFlattenMergeSpec.scala:81: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FlowFlattenMergeSpec.this.intercept[org.scalatest.exceptions.TestFailedException](FlowFlattenMergeSpec.this.convertScalaFuture[Int](Source.apply[Int](scala.this.Predef.intWrapper(1).to(3)).flatMapMerge[Int, akka.NotUsed](10, ((i: Int) => if (i.==(3))

[warn]   throw ex

[warn] else

[warn]   FlowFlattenMergeSpec.this.blocked)).runWith[scala.concurrent.Future[Int]](Sink.head[Int])(FlowFlattenMergeSpec.this.materializer)).futureValue(FlowFlattenMergeSpec.this.patience, org.scalactic.source.Position.apply("FlowFlattenM
[warn]       }.cause.get should ===(ex)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFlattenMergeSpec.scala:91: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   FlowFlattenMergeSpec.this.intercept[org.scalatest.exceptions.TestFailedException](FlowFlattenMergeSpec.this.convertScalaFuture[Int](Source.apply[akka.stream.scaladsl.Source[Int,akka.NotUsed]](immutable.this.List.apply[akka.stream.scaladsl.Source[Int,akka.NotUsed]](FlowFlattenMergeSpec.this.blocked, FlowFlattenMergeSpec.this.blocked, Source.failed[Nothing](ex))).flatMapMerge[Int, akka.NotUsed](10, {

[warn]   ((x: akka.stream.scaladsl.Source[Int,akka.NotUsed]) => scala.this.Predef.identity[akka.stream.s
[warn]       }.cause.get should ===(ex)
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFoldAsyncSpec.scala:216: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[String]
[warn]         Future.successful(null.asInstanceOf[String])
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFoldAsyncSpec.scala:226: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[String]
[warn]         if (elem == "b") Future.successful(null.asInstanceOf[String])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFoldAsyncSpec.scala:239: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[String]
[warn]         if (elem == "b") Future.successful(null.asInstanceOf[String])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowFoldAsyncSpec.scala:269: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ((x$5: Any, x$6: Any) => scala.concurrent.Future.successful[akka.NotUsed.type](akka.NotUsed)).asInstanceOf[(L, R) => scala.concurrent.Future[akka.NotUsed]]
[warn]   }.asInstanceOf[(L, R) ? Future[NotUsed]]
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupBySpec.scala:416: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   null.asInstanceOf[akka.util.ByteString]
[warn]       var blockingNextElement: ByteString = null.asInstanceOf[ByteString]
[warn]                                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupBySpec.scala:48: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class StreamPuppet(p: Publisher[Int]) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupBySpec.scala:424: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]       case class SubFlowState(probe: TestSubscriber.Probe[ByteString], hasDemand: Boolean, firstElement: ByteString)
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupBySpec.scala:148: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ex.isInstanceOf[IllegalArgumentException]
[warn]       ex.isInstanceOf[IllegalArgumentException] should be(true)
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupBySpec.scala:457: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]             blockingNextElement = null
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowGroupBySpec.scala:435: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val shape: akka.stream.SinkShape[akka.util.ByteString] = _
[warn]         override protected def newInstance(shape: SinkShape[ByteString]): SinkModule[ByteString, TestSubscriber.Probe[ByteString]] = new ProbeSink(attributes, shape)
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowIntersperseSpec.scala:57: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toString on instance of String.
[warn]   x$6.toString
[warn]         .map(_.toString)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowJoinSpec.scala:46: [scapegoat] Broken odd check
[warn]   Code that attempts to check for oddness using `x % 2 == 1` will fail on negative numbers. Consider using `x % 2 != 0`.
[warn]   x$4.%(2).==(1)
[warn]         .filter(_ % 2 == 1)
[warn]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowJoinSpec.scala:63: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowJoinSpec.scala:80: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowJoinSpec.scala:97: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowJoinSpec.scala:108: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowJoinSpec.scala:125: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowJoinSpec.scala:147: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowJoinSpec.scala:30: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[Int]()
[info]       val result = Set() ++ even ++ odd ++ odd.map(_ * 10)
[info]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitSpec.scala:31: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   input.toSeq
[warn]       result should be(input.toSeq)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitSpec.scala:39: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   input.toSeq
[warn]       result should be(input.toSeq)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:33: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   input.toSeq
[warn]       result should be(input.toSeq)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:42: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   input.toSeq
[warn]       result should be(input.toSeq)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:51: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   input.toSeq
[warn]       result should be(input.toSeq)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:21: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val e: Int = _).
[warn]       def costFn(e: Int): Long = 999999L // set to an arbitrarily big value
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:29: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val e: Int = _).
[warn]       def costFn(e: Int): Long = 0L
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLimitWeightedSpec.scala:38: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val e: Int = _).
[warn]       def costFn(e: Int): Long = 1L
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowLogSpec.scala:100: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]         case class Complex(a: Int, b: String)
[info]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMapAsyncSpec.scala:245: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   <synthetic> <artifact> private[this] val x$1: (scala.concurrent.Promise[Int], Long) = (queue.take(): (scala.concurrent.Promise[Int], Long) @unchecked) match {

[warn]     case (_1: scala.concurrent.Promise[Int], _2: Long)(scala.concurrent.Promise[Int], Long)((promise @ _), (enqueued @ _)) => scala
[warn]           val cont = try {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMapAsyncSpec.scala:248: [scapegoat] Empty while block
[warn]   An empty while block is considered as dead code.
[warn]   while$1(){

[warn]   if (java.this.lang.System.nanoTime().<(wakeup))

[warn]     {

[warn]       ();

[warn]       while$1()

[warn]     }

[warn]   else

[warn]     ()

[warn] }
[warn]             while (System.nanoTime() < wakeup) {}
[warn]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMapAsyncSpec.scala:244: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]         @tailrec final override def run(): Unit = {
[info]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMapAsyncUnorderedSpec.scala:238: [scapegoat] Catch fatal exception
[warn]   Did you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.
[warn]   try {

[warn]   <synthetic> <artifact> private[this] val x$2: (scala.concurrent.Promise[Int], Long) = (queue.take(): (scala.concurrent.Promise[Int], Long) @unchecked) match {

[warn]     case (_1: scala.concurrent.Promise[Int], _2: Long)(scala.concurrent.Promise[Int], Long)((promise @ _), (enqueued @ _)) => scala
[warn]           val cont = try {
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMapAsyncUnorderedSpec.scala:241: [scapegoat] Empty while block
[warn]   An empty while block is considered as dead code.
[warn]   while$1(){

[warn]   if (java.this.lang.System.nanoTime().<(wakeup))

[warn]     {

[warn]       ();

[warn]       while$1()

[warn]     }

[warn]   else

[warn]     ()

[warn] }
[warn]             while (System.nanoTime() < wakeup) {}
[warn]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMapAsyncUnorderedSpec.scala:237: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]         @tailrec final override def run(): Unit = {
[info]                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowMapConcatSpec.scala:22: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]         Seq(0) → Seq(),
[info]                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowScanSpec.scala:59: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import ActorAttributes._
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSectionSpec.scala:15: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n      my-dispatcher1 = ${akka.test.stream-dispatcher}\n      my-dispatcher2 = ${akka.test.stream-dispatcher}\n    ").s()
[warn]     s"""
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:72: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   FlowSpec.this.materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]       materializer.asInstanceOf[ActorMaterializerImpl])
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:531: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   $anon.this.downstream2.expectSubscriptionAndError().isInstanceOf[IllegalStateException]
[warn]         downstream2.expectSubscriptionAndError().isInstanceOf[IllegalStateException] should be(true)
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:546: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   error.isInstanceOf[akka.stream.AbruptTerminationException]
[warn]           error.isInstanceOf[AbruptTerminationException] should be(true)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSpec.scala:310: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val identity2: akka.stream.scaladsl.Flow[Int,Int,akka.NotUsed] = Flow.fromProcessor[Int, Int]((() => identity1.run()(FlowSpec.this.materializer)))
[warn]       val identity2 = Flow.fromProcessor(() ? identity1.run())
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitAfterSpec.scala:34: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class StreamPuppet(p: Publisher[Int]) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSplitWhenSpec.scala:25: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class StreamPuppet(p: Publisher[Int]) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowStageSpec.scala:10: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.stream.ActorMaterializer
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowStageSpec.scala:11: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.stream.ActorMaterializerSettings
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowStageSpec.scala:16: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import scala.concurrent.duration._
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowStageSpec.scala:17: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import scala.util.control.NoStackTrace
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowStatefulMapConcatSpec.scala:22: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]         Seq(2) → Seq(),
[info]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\FlowSupervisionSpec.scala:27: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   scala.this.Predef.intWrapper(1).to(5).toSeq
[warn]     Await.result(Source((1 to 5).toSeq ++ (1 to 5)).via(f).limit(1000).runWith(Sink.seq), 3.seconds)
[warn]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:109: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:123: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:147: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:161: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:179: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:184: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:201: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:228: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:249: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:267: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:272: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:278: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:284: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBackedFlowSpec.scala:312: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]           import GraphDSL.Implicits._
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBalanceSpec.scala:118: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Int]()
[info]       }).runFold(Seq[Int]())(_ :+ _)
[info]                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBroadcastSpec.scala:92: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphBroadcastSpec.scala:58: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Int]()
[info]       }).runFold(Seq[Int]())(_ :+ _)
[info]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:25: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   elem.asInstanceOf[Out]
[warn]         ctx.push(elem.asInstanceOf[Out])
[warn]                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:90: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:137: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:149: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:173: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:190: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:203: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:232: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:243: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:285: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:314: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import GraphDSL.Implicits._
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:348: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphDSLCompileSpec.scala:169: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val out2: akka.stream.scaladsl.Sink[String,org.reactivestreams.Publisher[String]] = Sink.asPublisher[String](false)
[warn]         val out2 = Sink.asPublisher[String](false)
[warn]             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMatValueSpec.scala:129: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]             import GraphDSL.Implicits._
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMatValueSpec.scala:168: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]             import GraphDSL.Implicits._
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMatValueSpec.scala:187: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]             import GraphDSL.Implicits._
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMatValueSpec.scala:209: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMergePreferredSpec.scala:46: [scapegoat] filter().size() instead of count()
[info]   `filter().size` can be replaced with `count()`, which is more concise.
[info]   scala.concurrent.Await.result[Seq[Int]](result, scala.concurrent.duration.`package`.DurationInt(3).seconds).filter(((x$1: Int) => x$1.==(1))).size
[info]       Await.result(result, 3.seconds).filter(_ == 1).size should be(numElements)
[info]                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMergeSortedSpec.scala:35: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]         val N = picks.size
[info]                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphMergeSpec.scala:69: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Int]()
[info]       }).runFold(Seq[Int]())(_ :+ _)
[info]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphOpsIntegrationSpec.scala:25: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   inlets.asInstanceOf[Seq[akka.stream.Inlet[In]]]
[warn]         val i = inlets.asInstanceOf[Seq[Inlet[In]]]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphOpsIntegrationSpec.scala:26: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   outlets.asInstanceOf[Seq[akka.stream.Outlet[Out]]]
[warn]         val o = outlets.asInstanceOf[Seq[Outlet[Out]]]
[warn]                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphOpsIntegrationSpec.scala:15: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class ShufflePorts[In, Out](in1: Inlet[In], in2: Inlet[In], out1: Outlet[Out], out2: Outlet[Out]) extends Shape {
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphPartialSpec.scala:100: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]         import GraphDSL.Implicits._
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphPartitionSpec.scala:123: [scapegoat] Duplicated set value
[warn]   A set value is overwritten by a later entry.
[warn]   scala.this.Predef.Set.apply[Int](5, 2, 9, 1, 1, 1, 10)
[warn]       val input = Set(5, 2, 9, 1, 1, 1, 10)
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphStageTimersSpec.scala:24: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Tick(n: Int)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphStageTimersSpec.scala:30: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   SideChannel.this.asyncCallback.ne(null)
[warn]     def isReady: Boolean = asyncCallback ne null
[warn]                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphUnzipWithSpec.scala:195: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]       case class Person(name: String, surname: String, int: Int)
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphUnzipWithSpec.scala:198: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Person.unapply(a).get
[warn]         val unzip = b.add(UnzipWith((a: Person) ? Person.unapply(a).get))
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphUnzipWithSpec.scala:52: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val f: GraphUnzipWithSpec.this.Fixture = GraphUnzipWithSpec.this.fixture(b)
[warn]       val f = fixture(b)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphUnzipWithSpec.scala:144: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val settings: akka.stream.ActorMaterializerSettings = akka.stream.ActorMaterializerSettings.apply(GraphUnzipWithSpec.this.system).withInputBuffer(1, 1)
[warn]       val settings = ActorMaterializerSettings(system)
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\GraphZipWithSpec.scala:115: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]       case class Person(name: String, surname: String, int: Int)
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:163: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:169: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{ "name": "john"}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:175: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{ "name": "john doe"}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:181: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{ "name": "john o'doe"}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:192: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{ "name": "john{}"}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:208: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{ "name": "john\"{}\" hey"}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:214: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{ "age": 101}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:220: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{ "age": 101}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:235: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{  "name": "john",
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:259: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{  "name": "john",
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:286: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{  "name": "john",
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:326: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:355: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{ "name": "john", "age": 101}"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:366: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:389: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:394: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:405: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]           buffer.poll().get.utf8String shouldBe """{"name":"jenkins","age": 65 }"""
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\JsonFramingSpec.scala:419: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   buffer.poll().get
[warn]         buffer.poll().get.utf8String shouldBe """{ "name": "john"}"""
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\QueueSinkSpec.scala:112: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.isInstanceOf[IllegalStateException]
[warn]       queue.pull().onFailure { case e ? e.isInstanceOf[IllegalStateException] should ===(true) }
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\QueueSourceSpec.scala:212: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.isInstanceOf[IllegalStateException]
[warn]       queue.offer(1).onFailure { case e ? e.isInstanceOf[IllegalStateException] should ===(true) }
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SeqSinkSpec.scala:23: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   input.toSeq
[warn]       result should be(input.toSeq)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SinkAsJavaStreamSpec.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]         materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SinkAsJavaStreamSpec.scala:57: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SinkAsJavaStreamSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$3: akka.actor.ActorRef) => x$3.path.toString().contains("asJavaStream"))).get
[warn]         val ref = expectMsgType[Children].children.find(_.path.toString contains "asJavaStream").get
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SinkAsJavaStreamSpec.scala:52: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]       val materializer = ActorMaterializer()(sys)
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SinkForeachParallelSpec.scala:50: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SinkForeachParallelSpec.scala:75: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import system.dispatcher
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:156: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   probes.apply(i)
[warn]       for (i ← 0 to 4) probes(i).subscribe(s(i))
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:156: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   s.apply(i)
[warn]       for (i ← 0 to 4) probes(i).subscribe(s(i))
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:161: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   probes.apply(i)
[warn]         val s = probes(i).expectSubscription()
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:174: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   probes.apply(i)
[warn]       val source = for (i ← 0 to 2) yield Source.fromPublisher(probes(i))
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:183: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   probes.apply(i)
[warn]         val s = probes(i).expectSubscription()
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:205: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   probes.apply(i)
[warn]         val s = probes(i).expectSubscription()
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\SourceSpec.scala:133: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ready.value.get
[warn]       val Failure(ex) = ready.value.get
[warn]                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\StageActorRefSpec.scala:168: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class Add(n: Int) extends NoSerializationVerificationNeeded
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\StageActorRefSpec.scala:169: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]     case class AddAndTell(n: Int) extends NoSerializationVerificationNeeded
[info]                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\StageActorRefSpec.scala:178: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class SumTestStage(probe: ActorRef) extends GraphStageWithMaterializedValue[SinkShape[Int], Future[Int]] {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceAsyncSourceSpec.scala:220: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]         materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceAsyncSourceSpec.scala:221: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   UnfoldResourceAsyncSourceSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$2: akka.actor.ActorRef) => x$2.path.toString().contains("unfoldResourceSourceAsync"))).get
[warn]         val ref = expectMsgType[Children].children.find(_.path.toString contains "unfoldResourceSourceAsync").get
[warn]                                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceAsyncSourceSpec.scala:206: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toString on instance of String.
[warn]   nextChunk().toString
[warn]         c.expectNext().utf8String should ===(nextChunk().toString)
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceAsyncSourceSpec.scala:214: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]       val materializer = ActorMaterializer()(sys)
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceSourceSpec.scala:153: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   materializer.asInstanceOf[akka.stream.impl.ActorMaterializerImpl]
[warn]         materializer.asInstanceOf[ActorMaterializerImpl].supervisor.tell(StreamSupervisor.GetChildren, testActor)
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceSourceSpec.scala:154: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   UnfoldResourceSourceSpec.this.expectMsgType[akka.stream.impl.StreamSupervisor.Children]((ClassTag.apply[akka.stream.impl.StreamSupervisor.Children](classOf[akka.stream.impl.StreamSupervisor$$Children]): scala.reflect.ClassTag[akka.stream.impl.StreamSupervisor.Children])).children.find(((x$2: akka.actor.ActorRef) => x$2.path.toString().contains("unfoldResourceSource"))).get
[warn]         val ref = expectMsgType[Children].children.find(_.path.toString contains "unfoldResourceSource").get
[warn]                                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceSourceSpec.scala:138: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toString on instance of String.
[warn]   nextChunk().toString
[warn]         c.expectNext().utf8String should ===(nextChunk().toString)
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\scaladsl\UnfoldResourceSourceSpec.scala:146: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val materializer: akka.stream.ActorMaterializer = akka.stream.ActorMaterializer.apply(akka.stream.ActorMaterializer.apply$default$1, akka.stream.ActorMaterializer.apply$default$2)(sys)
[warn]       val materializer = ActorMaterializer()(sys)
[warn]           ^
[info] [warn] [scapegoat] Analysis complete: 145 files - 0 errors 184 warns 119 infos
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\GraphStageLogicSpec.scala:81: The outer reference in this type test cannot be checked at run time.
[warn]   final case class ReadNEmitN(n: Int) extends GraphStage[FlowShape[Int, Int]] {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\GraphStageLogicSpec.scala:92: The outer reference in this type test cannot be checked at run time.
[warn]   final case class ReadNEmitRestOnComplete(n: Int) extends GraphStage[FlowShape[Int, Int]] {
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterSpec.scala:580: The outer reference in this type test cannot be checked at run time.
[warn]   private[akka] final case class Doubler[T]() extends GraphStage[FlowShape[T, T]] {
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-stream-tests\src\test\scala\akka\stream\impl\fusing\InterpreterSpec.scala:614: The outer reference in this type test cannot be checked at run time.
[warn]   private[akka] final case class KeepGoing[T]() extends GraphStage[FlowShape[T, T]] {
[warn]                                  ^
[warn] there were 57 deprecation warnings; re-run with -deprecation for details
[warn] 189 warnings found
[info] 注: 某些输入文件使用或覆盖了已过时的 API。
[info] 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。
[info] Compiling 87 Scala sources and 3 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\target\test-classes...
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\AkkaProtocolStressTest.scala:119: possible missing interpolator: detected interpolated identifier `$a`
[warn]       EventFilter.warning(source = "akka://AkkaProtocolStressTest/user/$a", start = "received dead letter"),
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:180: possible missing interpolator: detected interpolated identifier `$a`
[warn]       EventFilter.warning(source = "akka://AkkaProtocolStressTest/user/$a", start = "received dead letter"),
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:139: possible missing interpolator: detected interpolated identifier `$a`
[warn]       EventFilter.warning(source = "akka://AkkaProtocolStressTest/user/$a", start = "received dead letter"),
[warn]                                    ^
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:17: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   timeIntervals.head
[warn]       @volatile var times = timeIntervals.tail.foldLeft(List[Long](timeIntervals.head))((acc, c) ? acc ::: List[Long](acc.last + c))
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:19: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.times.head
[warn]         val currentTime = times.head
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AccrualFailureDetectorSpec.scala:20: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.times.tail
[warn]         times = times.tail
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\AckedDeliverySpec.scala:274: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   scala.this.Predef.intWrapper(0).until(MsgCount).toSeq
[warn]       val referenceList: Seq[Sequenced] = (0 until MsgCount).toSeq map { i ? msg(i.toLong) }
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\ActorsLeakSpec.scala:186: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ActorsLeakSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         val remoteActor = expectMsgType[ActorIdentity].ref.get
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\ActorsLeakSpec.scala:50: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val node: akka.actor.ActorRef = _
[warn]       node :: children.flatMap(recurse)
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DaemonicSpec.scala:17: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sys.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     sys.asInstanceOf[ExtendedActorSystem].provider.getExternalAddressFor(Address(s"akka.$proto", "", "", 0)).get
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DaemonicSpec.scala:17: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   sys.asInstanceOf[akka.actor.ExtendedActorSystem].provider.getExternalAddressFor(akka.actor.Address.apply(scala.StringContext.apply("akka.", "").s(proto), "", "", 0)).get
[warn]     sys.asInstanceOf[ExtendedActorSystem].provider.getExternalAddressFor(Address(s"akka.$proto", "", "", 0)).get
[warn]                                                                                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DaemonicSpec.scala:48: [scapegoat] Simplify boolean expressions
[info]   Boolean expressions such as x == false can be re-written as !x.
[info]   t.isDaemon().==(false)
[info]         filter(t ? !origThreads(t) && t.isDaemon == false).to[Set]
[info]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DeadlineFailureDetectorSpec.scala:16: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   timeIntervals.head
[warn]       @volatile var times = timeIntervals.tail.foldLeft(List[Long](timeIntervals.head))((acc, c) ? acc ::: List[Long](acc.last + c))
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DeadlineFailureDetectorSpec.scala:18: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.times.head
[warn]         val currentTime = times.head
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\DeadlineFailureDetectorSpec.scala:19: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.times.tail
[warn]         times = times.tail
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:10: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   timeIntervals.head
[warn]     @volatile var times = timeIntervals.tail.foldLeft(List[Long](timeIntervals.head))((acc, c) ? acc ::: List[Long](acc.last + c))
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:12: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.times.head
[warn]       val currentTime = times.head
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\FailureDetectorRegistrySpec.scala:13: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   $anon.this.times.tail
[warn]       times = times.tail
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\LogSourceSpec.scala:49: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LogSourceSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val defaultAddress = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\NetworkFailureSpec.scala:24: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   NetworkFailureSpec.this.enableTcpReset();

[warn]   scala.this.Predef.println("===>>> Reply with [TCP RST] for [".+(duration).+("]"));

[warn]   java.this.lang.Thread.sleep(duration.toMillis);

[warn]   NetworkFailureSpec.this.restoreIP()

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => {

[warn]     dead.set(true);

[warn]     e.
[warn]       try {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\NetworkFailureSpec.scala:39: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   NetworkFailureSpec.this.enableNetworkThrottling();

[warn]   scala.this.Predef.println("===>>> Throttling network with [".+(NetworkFailureSpec.this.BytesPerSecond).+(", ").+(NetworkFailureSpec.this.DelayMillis).+("] for [").+(duration).+("]"));

[warn]   java.this.lang.Thread.sleep(duration.toMillis);

[warn]  
[warn]       try {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\NetworkFailureSpec.scala:54: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   NetworkFailureSpec.this.enableNetworkDrop();

[warn]   scala.this.Predef.println("===>>> Blocking network [TCP DENY] for [".+(duration).+("]"));

[warn]   java.this.lang.Thread.sleep(duration.toMillis);

[warn]   NetworkFailureSpec.this.restoreIP()

[warn] } catch {

[warn]   case (e @ (_: Throwable)) => {

[warn]     dead.set(true
[warn]       try {
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteDeployerSpec.scala:38: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteDeployerSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       val deployment = system.asInstanceOf[ActorSystemImpl].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteDeployerSpec.scala:43: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]           deployment.get.config,
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteInitErrorSpec.scala:11: [scapegoat] Java conversions
[warn]   Use of Java conversions can lead to unusual behaviour. It is recommended to use JavaConverters.
[warn] import scala.collection.JavaConversions._
[warn]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteRouterSpec.scala:46: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteRouterSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val port = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress.port.get
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteRouterSpec.scala:241: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteRouterSpec.this.masterSystem.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val parent = masterSystem.asInstanceOf[ExtendedActorSystem].systemActorOf(Props[Parent], "sys-parent")
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteRouterSpec.scala:46: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteRouterSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem].provider.getDefaultAddress.port.get
[warn]   val port = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress.port.get
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteWatcherSpec.scala:82: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.remoteSystem.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val remoteAddress = remoteSystem.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteWatcherSpec.scala:98: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get.asInstanceOf[akka.actor.InternalActorRef]
[warn]     expectMsgType[ActorIdentity].ref.get.asInstanceOf[InternalActorRef]
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteWatcherSpec.scala:109: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.RemoteWatcherSpec.MyActor](classOf[akka.remote.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.RemoteWatcherSpec.MyActor])), "a1").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a1 = system.actorOf(Props[MyActor], "a1").asInstanceOf[InternalActorRef]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteWatcherSpec.scala:110: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.RemoteWatcherSpec.MyActor](classOf[akka.remote.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.RemoteWatcherSpec.MyActor])), "a2").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a2 = system.actorOf(Props[MyActor], "a2").asInstanceOf[InternalActorRef]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteWatcherSpec.scala:173: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.RemoteWatcherSpec.MyActor](classOf[akka.remote.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.RemoteWatcherSpec.MyActor])), "a4").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a = system.actorOf(Props[MyActor], "a4").asInstanceOf[InternalActorRef]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteWatcherSpec.scala:212: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.RemoteWatcherSpec.MyActor](classOf[akka.remote.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.RemoteWatcherSpec.MyActor])), "a5").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a = system.actorOf(Props[MyActor], "a5").asInstanceOf[InternalActorRef]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteWatcherSpec.scala:246: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.RemoteWatcherSpec.MyActor](classOf[akka.remote.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.RemoteWatcherSpec.MyActor])), "a6").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a = system.actorOf(Props[MyActor], "a6").asInstanceOf[InternalActorRef]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemoteWatcherSpec.scala:98: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteWatcherSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get.asInstanceOf[InternalActorRef]
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:149: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sys.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     sys.asInstanceOf[ExtendedActorSystem].provider.getExternalAddressFor(Address(s"akka.$proto", "", "", 0)).get
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:152: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sys.asInstanceOf[akka.actor.ExtendedActorSystem].provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]     sys.asInstanceOf[ExtendedActorSystem].provider.asInstanceOf[RemoteActorRefProvider].deployer.deploy(d)
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:329: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   grandchild.asInstanceOf[akka.actor.ActorRefScope]
[warn]       grandchild.asInstanceOf[ActorRefScope].isLocal should ===(true)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:338: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   child.asInstanceOf[akka.remote.RemoteActorRef]
[warn]       child.asInstanceOf[RemoteActorRef].getParent should ===(l)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:340: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(l).?(RemotingSpec.ActorForReq.apply("child/.."))(RemotingSpec.this.timeout, RemotingSpec.this.self), RemotingSpec.this.timeout.duration).asInstanceOf[AnyRef]
[warn]       Await.result(l ? ActorForReq("child/.."), timeout.duration).asInstanceOf[AnyRef] should be theSameInstanceAs l
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:341: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(RemotingSpec.this.system.actorFor(RemotingSpec.this.system./("looker1")./("child"))).?(RemotingSpec.ActorForReq.apply(".."))(RemotingSpec.this.timeout, RemotingSpec.this.self), RemotingSpec.this.timeout.duration).asInstanceOf[AnyRef]
[warn]       Await.result(system.actorFor(system / "looker1" / "child") ? ActorForReq(".."), timeout.duration).asInstanceOf[AnyRef] should be theSameInstanceAs l
[warn]                                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:372: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   grandchild.asInstanceOf[akka.actor.ActorRefScope]
[warn]       grandchild.asInstanceOf[ActorRefScope].isLocal should ===(true)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:596: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   message.asInstanceOf[AnyRef]
[warn]           override def !(message: Any)(implicit sender: ActorRef): Unit = lastMsg = message.asInstanceOf[AnyRef]
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:681: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   inboundHandle.asInstanceOf[akka.remote.transport.TestAssociationHandle]
[warn]           registry.getRemoteReadHandlerFor(inboundHandle.asInstanceOf[TestAssociationHandle]).get
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:760: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   inboundHandle.asInstanceOf[akka.remote.transport.TestAssociationHandle]
[warn]           registry.getRemoteReadHandlerFor(inboundHandle.asInstanceOf[TestAssociationHandle]).get
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:786: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n            akka.remote.enabled-transports = [\"akka.remote.netty.tcp\"]\n            akka.remote.netty.tcp.port = 0\n            akka.remote.retry-gate-closed-for = 5s\n            ").s()
[warn]       val config = ConfigFactory.parseString(s"""
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:823: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n            akka.remote.enabled-transports = [\"akka.remote.netty.tcp\"]\n            akka.remote.netty.tcp.port = 0\n            akka.remote.retry-gate-closed-for = 5s\n            ").s()
[warn]       val config = ConfigFactory.parseString(s"""
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:333: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   myref.isInstanceOf[akka.remote.RemoteActorRef]
[warn]       myref.isInstanceOf[RemoteActorRef] should ===(true)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:588: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]           @volatile var lastMsg: AnyRef = null
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:149: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   sys.asInstanceOf[akka.actor.ExtendedActorSystem].provider.getExternalAddressFor(akka.actor.Address.apply(scala.StringContext.apply("akka.", "").s(proto), "", "", 0)).get
[warn]     sys.asInstanceOf[ExtendedActorSystem].provider.getExternalAddressFor(Address(s"akka.$proto", "", "", 0)).get
[warn]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:150: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemotingSpec.this.addr(sys, proto).port.get
[warn]   def port(sys: ActorSystem, proto: String) = addr(sys, proto).port.get
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:387: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemotingSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       expectMsgType[ActorIdentity].ref.get should be theSameInstanceAs l
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:390: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemotingSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       expectMsgType[ActorIdentity].ref.get should be theSameInstanceAs l
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:580: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   localAddress.host.get
[warn]               local-address = "test://${localAddress.system}@${localAddress.host.get}:${localAddress.port.get}"
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:580: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   localAddress.port.get
[warn]               local-address = "test://${localAddress.system}@${localAddress.host.get}:${localAddress.port.get}"
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:639: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   localAddress.host.get
[warn]           local-address = "test://${localAddress.system}@${localAddress.host.get}:${localAddress.port.get}"
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:639: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   localAddress.port.get
[warn]           local-address = "test://${localAddress.system}@${localAddress.host.get}:${localAddress.port.get}"
[warn]                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:660: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   registry.transportFor(rawLocalAddress).get
[warn]         val testTransport = registry.transportFor(rawLocalAddress).get._1
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:681: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   registry.getRemoteReadHandlerFor(inboundHandle.asInstanceOf[akka.remote.transport.TestAssociationHandle]).get
[warn]           registry.getRemoteReadHandlerFor(inboundHandle.asInstanceOf[TestAssociationHandle]).get
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:718: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   localAddress.host.get
[warn]           local-address = "test://${localAddress.system}@${localAddress.host.get}:${localAddress.port.get}"
[warn]                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:718: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   localAddress.port.get
[warn]           local-address = "test://${localAddress.system}@${localAddress.host.get}:${localAddress.port.get}"
[warn]                                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:739: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   registry.transportFor(rawLocalAddress).get
[warn]         val testTransport = registry.transportFor(rawLocalAddress).get._1
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\RemotingSpec.scala:760: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   registry.getRemoteReadHandlerFor(inboundHandle.asInstanceOf[akka.remote.transport.TestAssociationHandle]).get
[warn]           registry.getRemoteReadHandlerFor(inboundHandle.asInstanceOf[TestAssociationHandle]).get
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\Ticket1978CommunicationSpec.scala:144: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Ticket1978CommunicationSpec.this.other.asInstanceOf[akka.actor.ExtendedActorSystem].provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]       val otherAddress = other.asInstanceOf[ExtendedActorSystem].provider.asInstanceOf[RemoteActorRefProvider].transport.defaultAddress
[warn]                                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\Ticket1978CommunicationSpec.scala:78: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   settings.SSLProtocol.get
[warn]       engine.getSupportedProtocols.contains(settings.SSLProtocol.get) ||
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\Ticket1978CommunicationSpec.scala:79: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   settings.SSLProtocol.get
[warn]         (throw new IllegalArgumentException("Protocol not supported: " + settings.SSLProtocol.get))
[warn]                                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\Ticket1978CommunicationSpec.scala:149: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Ticket1978CommunicationSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]           expectMsgType[ActorIdentity].ref.get
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\Ticket1978CommunicationSpec.scala:160: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Ticket1978CommunicationSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]           expectMsgType[ActorIdentity].ref.get
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\UntrustedSpec.scala:76: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   UntrustedSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val addr = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\UntrustedSpec.scala:84: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   p.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       p.expectMsgType[ActorIdentity].ref.get
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\UntrustedSpec.scala:92: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   p.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     p.expectMsgType[ActorIdentity].ref.get
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\UntrustedSpec.scala:156: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   p.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val clientReceptionistRef = p.expectMsgType[ActorIdentity].ref.get
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\AeronSinkSpec.scala:37: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   AeronSinkSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val r = new TaskRunner(system.asInstanceOf[ExtendedActorSystem], idleCpuLevel)
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\ArteryMultiNodeSpec.scala:49: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.remote.RARP.apply(system).provider.getDefaultAddress.port.get
[warn]   def port(system: ActorSystem): Int = RARP(system).provider.getDefaultAddress.port.get
[warn]                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\ArteryMultiNodeSpec.scala:63: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val config: com.typesafe.config.Config = extraConfig.fold[com.typesafe.config.Config](ArteryMultiNodeSpec.this.localSystem.settings.config)(((str: String) => com.typesafe.config.ConfigFactory.parseStr
[warn]     val config =
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\BindCanonicalAddressSpec.scala:20: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n        akka.remote.artery.canonical.port = 0\n      ").s()
[warn]       val config = ConfigFactory.parseString(s"""
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\BindCanonicalAddressSpec.scala:61: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n        akka.remote.artery.bind.hostname = \"0.0.0.0\"\n      ").s()
[warn]       val config = ConfigFactory.parseString(s"""
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\BindCanonicalAddressSpec.scala:67: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.remote.transport.netty.NettyTransportSpec.getExternal()(sys).port.get
[warn]       getInternal.flatMap(_.port) should contain(getExternal.port.get)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\BindCanonicalAddressSpec.scala:68: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   x$2.host.get
[warn]       getInternal.map(_.host.get should include regex "0.0.0.0".r) // regexp dot is intentional to match IPv4 and 6 addresses
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:410: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var randomAccessFile: RandomAccessFile = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:411: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var recorder: FlightRecorder = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:412: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var reader: FlightRecorderReader = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:413: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var channel: FileChannel = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:427: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   randomAccessFile.ne(null)
[warn]         if (randomAccessFile ne null) randomAccessFile.close()
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:428: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   recorder.ne(null)
[warn]         if (recorder ne null) recorder.close()
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:429: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   reader.ne(null)
[warn]         if (reader ne null) reader.close()
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlightRecorderSpec.scala:430: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   channel.ne(null)
[warn]         if (channel ne null) channel.close()
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\FlushOnShutdownSpec.scala:16: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka {\n       actor.provider = remote\n       actor.serialize-creators = off\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n     }\n  ").s()
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeDenySpec.scala:15: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka.loglevel = WARNING\n     akka {\n       actor.provider = remote\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n       remote.artery.advanced.handshake-timeout = 2s\n       remote.artery.advanced.image-liveness-timeout = 1.9s\n     }\n  ").s()
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeFailureSpec.scala:20: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka {\n       actor.provider = remote\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n       remote.artery.advanced.handshake-timeout = 2s\n       remote.artery.advanced.image-liveness-timeout = 1.9s\n     }\n  ").s()
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeFailureSpec.scala:39: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var systemB: ActorSystem = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeFailureSpec.scala:69: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   HandshakeFailureSpec.this.systemB.!=(null)
[warn]     if (systemB != null) shutdown(systemB)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeFailureSpec.scala:60: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HandshakeFailureSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val remoteRef = expectMsgType[ActorIdentity].ref.get
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeRetrySpec.scala:19: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka {\n       actor.provider = remote\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n       remote.artery.advanced.handshake-timeout = 10s\n       remote.artery.advanced.image-liveness-timeout = 7s\n     }\n  ").s()
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeRetrySpec.scala:38: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var systemB: ActorSystem = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeRetrySpec.scala:62: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   HandshakeRetrySpec.this.systemB.!=(null)
[warn]     if (systemB != null) shutdown(systemB)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\HandshakeRetrySpec.scala:53: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   HandshakeRetrySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val remoteRef = expectMsgType[ActorIdentity].ref.get
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\InboundHandshakeSpec.scala:38: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val timeout: scala.concurrent.duration.FiniteDuration = scala.concurrent.duration.`package`.DurationInt(5).seconds).
[warn]   private def setupStream(inboundContext: InboundContext, timeout: FiniteDuration = 5.seconds): (TestPublisher.Probe[AnyRef], TestSubscriber.Probe[Any]) = {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LargeMessagesStreamSpec.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   regularRemote.asInstanceOf[akka.remote.RemoteActorRef]
[warn]       regularRemote.asInstanceOf[RemoteActorRef].cachedSendQueueIndex should be >= (Association.OrdinaryQueueIndex)
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LargeMessagesStreamSpec.scala:80: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   largeRemote.asInstanceOf[akka.remote.RemoteActorRef]
[warn]       largeRemote.asInstanceOf[RemoteActorRef].cachedSendQueueIndex should ===(Association.LargeQueueIndex)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LargeMessagesStreamSpec.scala:117: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   largeRemote.asInstanceOf[akka.remote.RemoteActorRef]
[warn]       largeRemote.asInstanceOf[RemoteActorRef].cachedSendQueueIndex should ===(Association.LargeQueueIndex)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LargeMessagesStreamSpec.scala:118: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   regularRemote.asInstanceOf[akka.remote.RemoteActorRef]
[warn]       regularRemote.asInstanceOf[RemoteActorRef].cachedSendQueueIndex should be >= (Association.OrdinaryQueueIndex)
[warn]                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LargeMessagesStreamSpec.scala:16: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Ping(payload: ByteString = ByteString.empty) extends JavaSerializable
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LargeMessagesStreamSpec.scala:17: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Pong(bytesReceived: Long) extends JavaSerializable
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LateConnectSpec.scala:20: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka {\n       actor.provider = remote\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n       remote.artery.advanced.handshake-timeout = 3s\n       remote.artery.advanced.image-liveness-timeout = 2.9s\n     }\n  ").s()
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\LruBoundedCacheSpec.scala:210: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val _: Int = _
[warn]         for (_ ← 1 to 10000) cache.getOrCompute(Random.nextString(32))
[warn]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\MetaMetadataSerializerSpec.scala:12: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class KeyLen(k: Key, l: Len) {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\MetadataCarryingSpec.scala:25: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def get(system: akka.actor.ActorSystem): akka.remote.artery.MetadataCarryingSpy = MetadataCarryingSpy.super.get(system)
[info]   override def get(system: ActorSystem): MetadataCarryingSpy = super.get(system)
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorForSpec.scala:68: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   grandchild.asInstanceOf[akka.actor.ActorRefScope]
[warn]       grandchild.asInstanceOf[ActorRefScope].isLocal should ===(true)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorForSpec.scala:77: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   child.asInstanceOf[akka.remote.RemoteActorRef]
[warn]       child.asInstanceOf[RemoteActorRef].getParent should ===(l)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorForSpec.scala:72: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   myref.isInstanceOf[akka.remote.RemoteActorRef]
[warn]       myref.isInstanceOf[RemoteActorRef] should ===(true)
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:26: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sel.anchor.asInstanceOf[akka.actor.InternalActorRef]
[warn]       sel.anchor.asInstanceOf[InternalActorRef].isLocal should be(true)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:32: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sel.anchor.asInstanceOf[akka.actor.InternalActorRef]
[warn]       sel.anchor.asInstanceOf[InternalActorRef].isLocal should be(false)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:36: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteActorRefProviderSpec.this.localSystem.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val provider = localSystem.asInstanceOf[ExtendedActorSystem].provider
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:40: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ref1.asInstanceOf[akka.actor.ActorRefScope]
[warn]       ref1.asInstanceOf[ActorRefScope].isLocal should ===(true)
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:47: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteActorRefProviderSpec.this.localSystem.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val provider = localSystem.asInstanceOf[ExtendedActorSystem].provider
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:57: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteActorRefProviderSpec.this.localSystem.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val provider = localSystem.asInstanceOf[ExtendedActorSystem].provider
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:25: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressA.host.get
[warn]       val sel = system.actorSelection(s"akka://${system.name}@${addressA.host.get}:${addressA.port.get}/user/echo")
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:25: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressA.port.get
[warn]       val sel = system.actorSelection(s"akka://${system.name}@${addressA.host.get}:${addressA.port.get}/user/echo")
[warn]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:30: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressB.host.get
[warn]       val sel = system.actorSelection(s"akka://${systemB.name}@${addressB.host.get}:${addressB.port.get}/user/echo")
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:30: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressB.port.get
[warn]       val sel = system.actorSelection(s"akka://${systemB.name}@${addressB.host.get}:${addressB.port.get}/user/echo")
[warn]                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:37: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressA.host.get
[warn]       val path = s"akka://${system.name}@${addressA.host.get}:${addressA.port.get}/user/echo"
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:37: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressA.port.get
[warn]       val path = s"akka://${system.name}@${addressA.host.get}:${addressA.port.get}/user/echo"
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:48: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressA.host.get
[warn]       val path = s"akka://${system.name}@${addressA.host.get}:${addressA.port.get}/user/doesNotExist"
[warn]                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:48: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressA.port.get
[warn]       val path = s"akka://${system.name}@${addressA.host.get}:${addressA.port.get}/user/doesNotExist"
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:58: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressB.host.get
[warn]       val path = s"akka://${systemB.name}@${addressB.host.get}:${addressB.port.get}/user/echo"
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:58: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressB.port.get
[warn]       val path = s"akka://${systemB.name}@${addressB.host.get}:${addressB.port.get}/user/echo"
[warn]                                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:68: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressB.host.get
[warn]         val sel = system.actorSelection(s"akka.tcp://${systemB.name}@${addressB.host.get}:${addressB.port.get}/user/echo")
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorRefProviderSpec.scala:68: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorRefProviderSpec.this.addressB.port.get
[warn]         val sel = system.actorSelection(s"akka.tcp://${systemB.name}@${addressB.host.get}:${addressB.port.get}/user/echo")
[warn]                                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorSelectionSpec.scala:75: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   localGrandchild.asInstanceOf[akka.actor.ActorRefScope]
[warn]       localGrandchild.asInstanceOf[ActorRefScope].isLocal should ===(true)
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorSelectionSpec.scala:93: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorSelectionSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       expectMsgType[ActorIdentity].ref.get should be theSameInstanceAs localLooker2
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteActorSelectionSpec.scala:97: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteActorSelectionSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       expectMsgType[ActorIdentity].ref.get should be theSameInstanceAs localLooker2
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteDeployerSpec.scala:41: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteDeployerSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       val deployment = system.asInstanceOf[ActorSystemImpl].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteDeployerSpec.scala:46: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]           deployment.get.config,
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteDeploymentSpec.scala:45: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.remote.RARP.apply(RemoteDeploymentSpec.this.system).provider.getDefaultAddress.port.get
[warn]   val port = RARP(system).provider.getDefaultAddress.port.get
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteDeploymentSpec.scala:54: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.remote.RARP.apply(RemoteDeploymentSpec.this.masterSystem).provider.getDefaultAddress.port.get
[warn]   val masterPort = RARP(masterSystem).provider.getDefaultAddress.port.get
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteRouterSpec.scala:239: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteRouterSpec.this.masterSystem.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val parent = masterSystem.asInstanceOf[ExtendedActorSystem].systemActorOf(Props[Parent], "sys-parent")
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteRouterSpec.scala:46: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.remote.RARP.apply(RemoteRouterSpec.this.system).provider.getDefaultAddress.port.get
[warn]   val port = RARP(system).provider.getDefaultAddress.port.get
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteSendConsistencySpec.scala:20: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka {\n       actor.provider = remote\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n     }\n  ").s()
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteSendConsistencySpec.scala:57: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AbstractRemoteSendConsistencySpec.this.expectMsgType[akka.actor.ActorIdentity](scala.concurrent.duration.`package`.DurationInt(5).seconds)((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         expectMsgType[ActorIdentity](5.seconds).ref.get
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteSendConsistencySpec.scala:97: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AbstractRemoteSendConsistencySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         expectMsgType[ActorIdentity].ref.get
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteSendConsistencySpec.scala:101: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AbstractRemoteSendConsistencySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         expectMsgType[ActorIdentity].ref.get
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteSendConsistencySpec.scala:105: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AbstractRemoteSendConsistencySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         expectMsgType[ActorIdentity].ref.get
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteWatcherSpec.scala:98: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get.asInstanceOf[akka.actor.InternalActorRef]
[warn]     expectMsgType[ActorIdentity].ref.get.asInstanceOf[InternalActorRef]
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteWatcherSpec.scala:109: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.artery.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.artery.RemoteWatcherSpec.MyActor](classOf[akka.remote.artery.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.artery.RemoteWatcherSpec.MyActor])), "a1").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a1 = system.actorOf(Props[MyActor], "a1").asInstanceOf[InternalActorRef]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteWatcherSpec.scala:110: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.artery.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.artery.RemoteWatcherSpec.MyActor](classOf[akka.remote.artery.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.artery.RemoteWatcherSpec.MyActor])), "a2").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a2 = system.actorOf(Props[MyActor], "a2").asInstanceOf[InternalActorRef]
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteWatcherSpec.scala:173: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.artery.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.artery.RemoteWatcherSpec.MyActor](classOf[akka.remote.artery.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.artery.RemoteWatcherSpec.MyActor])), "a4").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a = system.actorOf(Props[MyActor], "a4").asInstanceOf[InternalActorRef]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteWatcherSpec.scala:212: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.artery.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.artery.RemoteWatcherSpec.MyActor](classOf[akka.remote.artery.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.artery.RemoteWatcherSpec.MyActor])), "a5").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a = system.actorOf(Props[MyActor], "a5").asInstanceOf[InternalActorRef]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteWatcherSpec.scala:246: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteWatcherSpec.this.system.actorOf(akka.actor.Props.apply[akka.remote.artery.RemoteWatcherSpec.MyActor]()((ClassTag.apply[akka.remote.artery.RemoteWatcherSpec.MyActor](classOf[akka.remote.artery.RemoteWatcherSpec$$MyActor]): scala.reflect.ClassTag[akka.remote.artery.RemoteWatcherSpec.MyActor])), "a6").asInstanceOf[akka.actor.InternalActorRef]
[warn]       val a = system.actorOf(Props[MyActor], "a6").asInstanceOf[InternalActorRef]
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\RemoteWatcherSpec.scala:98: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteWatcherSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get.asInstanceOf[InternalActorRef]
[warn]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SendQueueSpec.scala:23: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ProduceToQueue(from: Int, until: Int, queue: Queue[Msg])
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SendQueueSpec.scala:24: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class ProduceToQueueValue(from: Int, until: Int, queue: SendQueue.QueueValue[Msg])
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SendQueueSpec.scala:25: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Msg(fromProducer: String, value: Int)
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SerializationErrorSpec.scala:16: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka {\n       actor.provider = remote\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n       actor {\n         serialize-creators = false\n         serialize-messages = false\n       }\n     }\n  ").s()
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SerializationErrorSpec.scala:54: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SerializationErrorSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         expectMsgType[ActorIdentity].ref.get
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SerializationErrorSpec.scala:71: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SerializationErrorSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         expectMsgType[ActorIdentity].ref.get
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageAckerSpec.scala:32: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val timeout: scala.concurrent.duration.FiniteDuration = scala.concurrent.duration.`package`.DurationInt(5).seconds).
[warn]   private def setupStream(inboundContext: InboundContext, timeout: FiniteDuration = 5.seconds): (TestPublisher.Probe[AnyRef], TestSubscriber.Probe[Any]) = {
[warn]               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:162: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$1.message.asInstanceOf[akka.remote.artery.SystemMessageDeliverySpec.TestSysMsg]
[warn]         .map(_.message.asInstanceOf[TestSysMsg])
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:196: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$2.message.asInstanceOf[akka.remote.artery.SystemMessageDeliverySpec.TestSysMsg]
[warn]         .map(_.message.asInstanceOf[TestSysMsg])
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:225: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$3.message.asInstanceOf[akka.remote.artery.SystemMessageDeliverySpec.TestSysMsg]
[warn]         .map(_.message.asInstanceOf[TestSysMsg])
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:258: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$4.message.asInstanceOf[akka.remote.artery.SystemMessageDeliverySpec.TestSysMsg]
[warn]           .map(_.message.asInstanceOf[TestSysMsg])
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:277: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$5.message.asInstanceOf[akka.remote.artery.SystemMessageDeliverySpec.TestSysMsg]
[warn]           .map(_.message.asInstanceOf[TestSysMsg])
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:34: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka.loglevel=INFO\n     akka {\n       actor.provider = remote\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n     }\n     akka.actor.serialize-creators = off\n     akka.actor.serialize-messages = off\n  ").s()
[warn]   val config = ConfigFactory.parseString(s"""
[warn]                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:46: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class TestSysMsg(s: String) extends SystemMessageDelivery.AckedDeliveryMessage
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:120: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SystemMessageDeliverySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         expectMsgType[ActorIdentity].ref.get
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\SystemMessageDeliverySpec.scala:138: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SystemMessageDeliverySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]           expectMsgType[ActorIdentity].ref.get
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\TestContext.scala:51: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   TestInboundContext.this.association(peer.address).asInstanceOf[akka.remote.artery.TestOutboundContext]
[warn]     val a = association(peer.address).asInstanceOf[TestOutboundContext]
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\UntrustedSpec.scala:90: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   p.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       p.expectMsgType[ActorIdentity].ref.get
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\UntrustedSpec.scala:98: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   p.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     p.expectMsgType[ActorIdentity].ref.get
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\UntrustedSpec.scala:162: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   p.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val clientReceptionistRef = p.expectMsgType[ActorIdentity].ref.get
[warn]                                                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:13: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import com.typesafe.config.ConfigFactory
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:24: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka {\n       loglevel = INFO\n\n       actor {\n         serializers {\n           test-message = \"akka.remote.artery.compress.TestMessageSerializer\"\n         }\n         serialization-bindings {\n           \"akka.remote.artery.compress.TestMessage\" = test-message\n         }\n       }\n\n       remote.artery.advanced.compression {\n         actor-refs.advertisement-interval = 2 seconds\n         manifests.advertisement-interval = 2 seconds\n       }\n   
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:68: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CompressionIntegrationSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val echoRefA = expectMsgType[ActorIdentity].ref.get
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:147: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CompressionIntegrationSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     val fwRefA = expectMsgType[ActorIdentity].ref.get
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:174: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CompressionIntegrationSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     val fwRefA = expectMsgType[ActorIdentity].ref.get
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:194: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CompressionIntegrationSpec.this.address(CompressionIntegrationSpec.this.systemB).port.get
[warn]     val port = address(systemB).port.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:217: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   p.expectMsgType[akka.actor.ActorIdentity](scala.concurrent.duration.`package`.DurationInt(1).second)((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         p.expectMsgType[ActorIdentity](1.second).ref.get
[warn]                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:222: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CompressionIntegrationSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     val echoRefA = expectMsgType[ActorIdentity].ref.get
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionIntegrationSpec.scala:277: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   CompressionIntegrationSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       expectMsgType[ActorIdentity].ref.get
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\CompressionTestUtils.scala:13: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       override def provider: ActorRefProvider = system.asInstanceOf[ActorSystemImpl].provider
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HandshakeShouldDropCompressionTableSpec.scala:64: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.remote.RARP.apply(HandshakeShouldDropCompressionTableSpec.this.system).provider.transport.asInstanceOf[akka.remote.artery.ArteryTransport]
[warn]       val systemATransport = RARP(system).provider.transport.asInstanceOf[ArteryTransport]
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HandshakeShouldDropCompressionTableSpec.scala:65: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.remote.RARP.apply(HandshakeShouldDropCompressionTableSpec.this.systemB).provider.transport.asInstanceOf[akka.remote.artery.ArteryTransport]
[warn]       def systemBTransport = RARP(systemB).provider.transport.asInstanceOf[ArteryTransport]
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HandshakeShouldDropCompressionTableSpec.scala:25: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n     akka {\n       loglevel = INFO\n\n       actor.provider = remote\n       remote.artery.enabled = on\n       remote.artery.canonical.hostname = localhost\n       remote.artery.canonical.port = 0\n       remote.artery.advanced.handshake-timeout = 10s\n       remote.artery.advanced.image-liveness-timeout = 7s\n\n       remote.artery.advanced.compression {\n         actor-refs {\n           # we\'ll trigger advertisement manually\n           advertisement-interval =
[warn]   val commonConfig = ConfigFactory.parseString(s"""
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HandshakeShouldDropCompressionTableSpec.scala:128: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def waitForEcho(probe: akka.testkit.TestKit, m: String, max: scala.concurrent.duration.Duration = scala.concurrent.duration.`package`.DurationInt(3).seconds): Any = probe.fishForMessage(max, scala.StringContext.apply("waiting for \'", "\'").s(m))(({

[warn]   @SerialVersionUID(value = 0) final <synthetic> 
[warn]   def waitForEcho(probe: TestKit, m: String, max: Duration = 3.seconds): Any =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HandshakeShouldDropCompressionTableSpec.scala:55: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]   var systemB: ActorSystem = null
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HandshakeShouldDropCompressionTableSpec.scala:149: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   HandshakeShouldDropCompressionTableSpec.this.systemB.!=(null)
[warn]     if (systemB != null) shutdown(systemB)
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HandshakeShouldDropCompressionTableSpec.scala:138: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ref.get
[warn]     ref.get
[warn]         ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\artery\compress\HeavyHittersSpec.scala:69: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]       case class MockHashCode(override val toString: String, override val hashCode: Int)
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\ArteryMessageSerializerSpec.scala:52: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ArteryMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val serializer = new ArteryMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\ArteryMessageSerializerSpec.scala:59: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ArteryMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val serializer = new ArteryMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\ArteryMessageSerializerSpec.scala:65: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ArteryMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new ArteryMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\DaemonMsgCreateSerializerSpec.scala:96: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   DaemonMsgCreateSerializerSpec.this.ser.deserialize[akka.remote.DaemonMsgCreate](DaemonMsgCreateSerializerSpec.this.ser.serialize(msg).get, classOf[akka.remote.DaemonMsgCreate]).get.asInstanceOf[akka.remote.DaemonMsgCreate]
[warn]       assertDaemonMsgCreate(msg, ser.deserialize(ser.serialize(msg).get, classOf[DaemonMsgCreate]).get.asInstanceOf[DaemonMsgCreate])
[warn]                                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\DaemonMsgCreateSerializerSpec.scala:105: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (e.isInstanceOf[Function0[_]])

[warn]   ()

[warn] else

[warn]   DaemonMsgCreateSerializerSpec.this.convertToAnyShouldWrapper[Any](g)(org.scalactic.source.Position.apply("DaemonMsgCreateSerializerSpec.scala", "D:\\data\\akka-akka\\akka-akka-4f9dc51\\akka-remote\\src\\test\\scala\\akka\\remote\\serialization\\DaemonMsgCreateSerializerSpec.scala", 106), scalactic.this.Prettifier.default).should[Any](DaemonMsgCreateSerializerSpec.this.===[Any](e))(DaemonMsgCreateSerializerSpec.this.conversionCheckedConstraint[Any,
[warn]           if (e.isInstanceOf[Function0[_]]) ()
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\DaemonMsgCreateSerializerSpec.scala:105: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   e.isInstanceOf[Function0[_]]
[warn]           if (e.isInstanceOf[Function0[_]]) ()
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\DaemonMsgCreateSerializerSpec.scala:96: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   DaemonMsgCreateSerializerSpec.this.ser.deserialize[akka.remote.DaemonMsgCreate](DaemonMsgCreateSerializerSpec.this.ser.serialize(msg).get, classOf[akka.remote.DaemonMsgCreate]).get
[warn]       assertDaemonMsgCreate(msg, ser.deserialize(ser.serialize(msg).get, classOf[DaemonMsgCreate]).get.asInstanceOf[DaemonMsgCreate])
[warn]                                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\DaemonMsgCreateSerializerSpec.scala:22: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (ignore).
[warn]   class MyActorWithParam(ignore: String) extends Actor {
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MessageContainerSerializerSpec.scala:31: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MessageContainerSerializerSpec.this.ser.deserialize[?0](MessageContainerSerializerSpec.this.ser.serialize(msg).get, msg.getClass()).get
[warn]       ser.deserialize(ser.serialize(msg).get, msg.getClass).get should ===(msg)
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:98: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MiscMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val serializer = new MiscMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:105: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MiscMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val serializer = new MiscMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:111: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MiscMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new MiscMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:123: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MiscMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new MiscMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:125: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   serializer.fromBinary(serializer.toBinary(aiex), serializer.manifest(aiex)).asInstanceOf[akka.actor.ActorInitializationException]
[warn]         .asInstanceOf[ActorInitializationException]
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:134: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MiscMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new MiscMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:136: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   serializer.fromBinary(serializer.toBinary(aiex), serializer.manifest(aiex)).asInstanceOf[akka.actor.ActorInitializationException]
[warn]         .asInstanceOf[ActorInitializationException]
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:145: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MiscMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new MiscMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:147: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   serializer.fromBinary(serializer.toBinary(aiex), serializer.manifest(aiex)).asInstanceOf[akka.actor.ActorInitializationException]
[warn]         .asInstanceOf[ActorInitializationException]
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:43: [scapegoat] Incorrectly named exceptions
[warn]   Class named exception does not derive from Exception / class derived from Exception is not named *Exception.
[warn]   class TestExceptionNoStack extends MiscMessageSerializerSpec.this.TestException with scala.util.control.NoStackTrace {

[warn]   <paramaccessor> private[this] val msg: String = _;

[warn]   def <init>(msg: String): akka.remote.serialization.MiscMessageSerializerSpec.TestExceptionNoStack = {

[warn]     TestExceptionNoStack.super.<init>(msg);

[warn]     ()

[warn]   };

[warn]   override def equals(other: Any): Boolean = other match {

[warn]     case (e @ (_: akka.remote.serialization.MiscMessageSerializerSpec.TestExceptionNoStack)) => e.getM
[warn]   class TestExceptionNoStack(msg: String) extends TestException(msg) with NoStackTrace {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:30: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TestException.this.<init>(msg, null)
[warn]     def this(msg: String) = this(msg, null)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\MiscMessageSerializerSpec.scala:39: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   TestException.this.getStackTrace().==(null)
[warn]       if (getStackTrace == null) Nil
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:32: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$1.asInstanceOf[AnyRef]
[warn]     Seq(0L, 1L, -1L, Long.MinValue, Long.MinValue + 1L, Long.MaxValue, Long.MaxValue - 1L).map(_.asInstanceOf[AnyRef]).foreach {
[warn]                                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:49: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PrimitivesSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new LongSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:54: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PrimitivesSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new LongSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:63: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   x$2.asInstanceOf[AnyRef]
[warn]     Seq(0, 1, -1, Int.MinValue, Int.MinValue + 1, Int.MaxValue, Int.MaxValue - 1).map(_.asInstanceOf[AnyRef]).foreach {
[warn]                                                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:80: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PrimitivesSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new IntSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:85: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PrimitivesSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new IntSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:117: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PrimitivesSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new StringSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:122: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PrimitivesSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new StringSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:153: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PrimitivesSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new ByteStringSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\PrimitivesSerializationSpec.scala:158: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   PrimitivesSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new ByteStringSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\ProtobufSerializerSpec.scala:27: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ProtobufSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val protobufMessage = MessageSerializer.serialize(system.asInstanceOf[ExtendedActorSystem], "hello")
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\ProtobufSerializerSpec.scala:31: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ProtobufSerializerSpec.this.ser.deserialize[?0](bytes, protobufMessage.getClass()).get.asInstanceOf[akka.remote.WireFormats.SerializedMessage]
[warn]       val deserialized = ser.deserialize(bytes, protobufMessage.getClass).get.asInstanceOf[SerializedMessage]
[warn]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\ProtobufSerializerSpec.scala:29: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ProtobufSerializerSpec.this.ser.serialize(protobufMessage).get
[warn]       val bytes = ser.serialize(protobufMessage).get
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\ProtobufSerializerSpec.scala:31: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ProtobufSerializerSpec.this.ser.deserialize[?0](bytes, protobufMessage.getClass()).get
[warn]       val deserialized = ser.deserialize(bytes, protobufMessage.getClass).get.asInstanceOf[SerializedMessage]
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:31: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.testkit.TestProbe.apply()(SystemMessageSerializationSpec.this.system).ref.asInstanceOf[akka.actor.InternalActorRef]
[warn]   val testRef = TestProbe().ref.asInstanceOf[InternalActorRef]
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:32: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.testkit.TestProbe.apply()(SystemMessageSerializationSpec.this.system).ref.asInstanceOf[akka.actor.InternalActorRef]
[warn]   val testRef2 = TestProbe().ref.asInstanceOf[InternalActorRef]
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:60: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new SystemMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:68: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSerializationSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       val serializer = new SystemMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:69: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   serializer.fromBinary(serializer.toBinary(createMsg), scala.None).asInstanceOf[akka.dispatch.sysmsg.Create]
[warn]       val deserialized = serializer.fromBinary(serializer.toBinary(createMsg), None).asInstanceOf[Create]
[warn]                                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:71: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deserialized.failure.get
[warn]       deserialized.failure.get.getCause should ===(aiex.getCause)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:72: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deserialized.failure.get
[warn]       deserialized.failure.get.getMessage should ===(aiex.getMessage)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:73: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deserialized.failure.get
[warn]       deserialized.failure.get.getActor should ===(aiex.getActor)
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\serialization\SystemMessageSerializationSpec.scala:20: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (msg).
[warn]   class TestException(msg: String) extends RuntimeException {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\AkkaProtocolSpec.scala:91: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   registry.logSnapshot.last
[warn]     if (registry.logSnapshot.isEmpty) false else registry.logSnapshot.last match {
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\AkkaProtocolSpec.scala:101: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   registry.logSnapshot.last
[warn]     if (registry.logSnapshot.isEmpty) false else registry.logSnapshot.last match {
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\AkkaProtocolSpec.scala:112: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   registry.logSnapshot.last
[warn]     if (registry.logSnapshot.isEmpty) false else registry.logSnapshot.last match {
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\AkkaProtocolStressTest.scala:94: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   AkkaProtocolStressTest.this.systemB.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val addressB = systemB.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\AkkaProtocolStressTest.scala:99: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AkkaProtocolStressTest.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\GenericTransportSpec.scala:30: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   GenericTransportSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem].provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]       val provider = system.asInstanceOf[ExtendedActorSystem].provider.asInstanceOf[RemoteActorRefProvider]
[warn]                                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:84: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageSender.this.target.asInstanceOf[akka.actor.InternalActorRef]
[warn]     val targetRef = target.asInstanceOf[InternalActorRef]
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:123: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageDeliveryStressTest.this.systemA.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val addressA = systemA.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:124: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SystemMessageDeliveryStressTest.this.systemB.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val addressB = systemB.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:10: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.testkit.{ TimingTest, DefaultTimeout, ImplicitSender, AkkaSpec }
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:10: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.testkit.{ TimingTest, DefaultTimeout, ImplicitSender, AkkaSpec }
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:10: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.testkit.{ TimingTest, DefaultTimeout, ImplicitSender, AkkaSpec }
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:20: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.testkit.AkkaSpec
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:25: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.transport.FailureInjectorTransportAdapter.One
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:26: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.transport.FailureInjectorTransportAdapter.Drop
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:79: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val msgCount: Int = _
[warn]   class SystemMessageSender(val msgCount: Int, val burstSize: Int, val burstDelay: FiniteDuration, val target: ActorRef) extends Actor {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:79: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val burstSize: Int = _
[warn]   class SystemMessageSender(val msgCount: Int, val burstSize: Int, val burstDelay: FiniteDuration, val target: ActorRef) extends Actor {
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\SystemMessageDeliveryStressTest.scala:79: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <paramaccessor> private[this] val burstDelay: scala.concurrent.duration.FiniteDuration = _
[warn]   class SystemMessageSender(val msgCount: Int, val burstSize: Int, val burstDelay: FiniteDuration, val target: ActorRef) extends Actor {
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:71: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ThrottlerTransportAdapterSpec.this.systemB.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val rootB = RootActorPath(systemB.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress)
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:79: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ThrottlerTransportAdapterSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem].provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]     val transport = system.asInstanceOf[ExtendedActorSystem].provider.asInstanceOf[RemoteActorRefProvider].transport
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:85: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ThrottlerTransportAdapterSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem].provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]     val transport = system.asInstanceOf[ExtendedActorSystem].provider.asInstanceOf[RemoteActorRefProvider].transport
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:155: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ThrottlerTransportAdapterGenericSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     new ThrottlerTransportAdapter(testTransport, system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:74: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ThrottlerTransportAdapterSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:78: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ThrottlerTransportAdapterSpec.this.rootB.address.port.get
[warn]     val rootBAddress = Address("akka", "systemB", "localhost", rootB.address.port.get)
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\ThrottlerTransportAdapterSpec.scala:84: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ThrottlerTransportAdapterSpec.this.rootB.address.port.get
[warn]     val rootBAddress = Address("akka", "systemB", "localhost", rootB.address.port.get)
[warn]                                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:23: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   sys.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     sys.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:44: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n        akka.remote.netty.tcp {\n          port = 0\n        }\n        ").s()
[warn]       val bindConfig = ConfigFactory.parseString(s"""
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:91: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n        akka.remote {\n          netty.tcp.port = 0\n          netty.udp.port = 0\n          enabled-transports = [\"akka.remote.netty.tcp\", \"akka.remote.netty.udp\"]\n        }\n        ").s()
[warn]       val bindConfig = ConfigFactory.parseString(s"""
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:107: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n        akka.remote {\n          netty.tcp.bind-hostname = \"0.0.0.0\"\n        }\n        ").s()
[warn]       val bindConfig = ConfigFactory.parseString(s"""
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:114: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   akka.remote.transport.netty.NettyTransportSpec.getExternal()(sys).port.get
[warn]       getInternal.flatMap(_.port) should contain(getExternal.port.get)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   x$2.host.get
[warn]       getInternal.map(_.host.get should include regex "0.0.0.0".r) // regexp dot is intentional to match IPv4 and 6 addresses
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote\src\test\scala\akka\remote\transport\netty\NettyTransportSpec.scala:31: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val system: akka.actor.ActorSystem = _).
[warn]     def withProtocol(protocol: String)(implicit system: ActorSystem) =
[warn]         ^
[info] [warn] [scapegoat] Analysis complete: 87 files - 0 errors 248 warns 17 infos
[warn] there were 28 deprecation warnings; re-run with -deprecation for details
[warn] 249 warnings found
[info] Compiling 2 Java sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-docs\target\classes...
[info] Compiling 6 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\target\test-classes...
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\test\scala\akka\remote\testconductor\BarrierSpec.scala:43: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.remote.testconductor.Controller.NodeInfo]()
[info]       expectMsg(Failed(b, BarrierEmpty(Data(Set(), "", Nil, null), "cannot remove RoleName(a): no client to remove")))
[info]                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\test\scala\akka\remote\testconductor\BarrierSpec.scala:185: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.remote.testconductor.Controller.NodeInfo]()
[info]         case Failed(barrier, thr: BarrierEmpty) if (thr == BarrierEmpty(Data(Set(), "", Nil, thr.data.deadline), "cannot remove RoleName(a): no client to remove")) ?
[info]                                                                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\test\scala\akka\remote\testconductor\BarrierSpec.scala:186: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[akka.remote.testconductor.Controller.NodeInfo]()
[info]         case x ? fail("Expected " + Failed(barrier, BarrierEmpty(Data(Set(), "", Nil, null), "cannot remove RoleName(a): no client to remove")) + " but got " + x)
[info]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\test\scala\akka\remote\testkit\LogRoleReplace.scala:56: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   contents.getTransferData(java.awt.datatransfer.DataFlavor.stringFlavor).asInstanceOf[String]
[warn]         val text = contents.getTransferData(DataFlavor.stringFlavor).asInstanceOf[String]
[warn]                                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\test\scala\akka\remote\testkit\LogRoleReplace.scala:54: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   clipboard.getContents(null)
[warn]       val contents = clipboard.getContents(null)
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\test\scala\akka\remote\testkit\LogRoleReplace.scala:104: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   line.ne(null)
[warn]       if (line ne null) {
[warn]                ^
[info] [warn] [scapegoat] Analysis complete: 6 files - 0 errors 3 warns 3 infos
[warn] three warnings found
[info] Formatting 33 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-remote-tests(multi-jvm) ...
[info] Compiling 31 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\target\test-classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterDeployerSpec.scala:51: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterDeployerSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       val deployment = system.asInstanceOf[ActorSystemImpl].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterDeployerSpec.scala:67: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterDeployerSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       val deployment = system.asInstanceOf[ActorSystemImpl].provider.deployer.lookup(service.split("/").drop(1))
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterDeployerSpec.scala:82: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterDeployerSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]       val mapping = system.asInstanceOf[ActorSystemImpl].provider.deployer.routerTypeMapping
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterDeployerSpec.scala:57: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]           deployment.get.config,
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterDeployerSpec.scala:73: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   deployment.get
[warn]           deployment.get.config,
[warn]                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterDomainEventSpec.scala:78: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]       diffUnreachable(g1, g2, bDown.uniqueAddress) should ===(Seq())
[info]                                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterDomainEventSpec.scala:95: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]       diffUnreachable(g1, g2, cUp.uniqueAddress) should ===(Seq())
[info]                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterDomainEventSpec.scala:98: [scapegoat] Prefer Seq.empty
[info]   `Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.
[info]   collection.this.Seq.apply[Nothing]()
[info]       diffReachable(g1, g2, bUp.uniqueAddress) should ===(Seq())
[info]                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterHeartbeatSenderStateSpec.scala:58: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   state.failureDetector.asInstanceOf[akka.remote.DefaultFailureDetectorRegistry[akka.actor.Address]].failureDetector(node.address).get.asInstanceOf[akka.cluster.ClusterHeartbeatSenderStateSpec.FailureDetectorStub]
[warn]       get.asInstanceOf[FailureDetectorStub]
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterHeartbeatSenderStateSpec.scala:156: [scapegoat] Catch throwable
[warn]   Did you intend to catch all throwables? Consider catching a more specific exception class.
[warn]   try {

[warn]   operation match {

[warn]     case Add => if (node.!=(selfUniqueAddress).&&(state.ring.nodes.contains(node).unary_!))

[warn]       {

[warn]         val oldUnreachable: Set[akka.cluster.UniqueAddress] = state.oldReceiversNowUnreachable;

[warn]         state = state.addMember(node);

[warn]         ClusterHeartbeatSenderSta
[warn]         try {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterHeartbeatSenderStateSpec.scala:58: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   state.failureDetector.asInstanceOf[akka.remote.DefaultFailureDetectorRegistry[akka.actor.Address]].failureDetector(node.address).get
[warn]       get.asInstanceOf[FailureDetectorStub]
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ClusterSpec.scala:39: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val selfAddress = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\DowningProviderSpec.scala:75: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   Cluster.apply(system).downingProvider.asInstanceOf[akka.cluster.DummyDowningProvider]
[warn]       awaitCond(Cluster(system).downingProvider.asInstanceOf[DummyDowningProvider].actorPropsAccessed.get(), 3.seconds)
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\DowningProviderSpec.scala:18: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn] class FailingDowningProvider(system: ActorSystem) extends DowningProvider {
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\DowningProviderSpec.scala:25: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (system).
[warn] class DummyDowningProvider(system: ActorSystem) extends DowningProvider {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\FailureDetectorPuppet.scala:15: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn] class FailureDetectorPuppet(config: Config, ev: EventStream) extends FailureDetector {
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\FailureDetectorPuppet.scala:15: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (ev).
[warn] class FailureDetectorPuppet(config: Config, ev: EventStream) extends FailureDetector {
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\HeartbeatNodeRingPerfSpec.scala:12: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   scala.sys.`package`.props.get("akka.cluster.HeartbeatNodeRingPerfSpec.nodesSize").getOrElse[String]("250")
[warn]   val nodesSize = sys.props.get("akka.cluster.HeartbeatNodeRingPerfSpec.nodesSize").getOrElse("250").toInt
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\HeartbeatNodeRingPerfSpec.scala:13: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   scala.sys.`package`.props.get("akka.cluster.HeartbeatNodeRingPerfSpec.iterations").getOrElse[String]("10000")
[warn]   val iterations = sys.props.get("akka.cluster.HeartbeatNodeRingPerfSpec.iterations").getOrElse("10000").toInt
[warn]                                                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\HeartbeatNodeRingSpec.scala:56: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[Nothing]()
[info]       ring.myReceivers should ===(Set())
[info]                                      ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MemberOrderingSpec.scala:36: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import Member.ordering
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricNumericConverterSpec.scala:20: [scapegoat] Use of Either.right or Either.left projection followed by a get
[warn]   Method .get on a Left and a Right projection is deprecated since 2.13, use Either.getOrElse or Either.swap.getOrElse instead.
[warn]   MetricNumericConverterSpec.this.convertNumber(1).left.get
[warn]       convertNumber(1).left.get should ===(1)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricValuesSpec.scala:32: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MetricValuesSpec.this.node2.metric("heap-memory-committed").get
[warn]       val stream1 = node2.metric(HeapMemoryCommitted).get.value.longValue
[warn]                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricValuesSpec.scala:33: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MetricValuesSpec.this.node1.metric("heap-memory-used").get
[warn]       val stream2 = node1.metric(HeapMemoryUsed).get.value.longValue
[warn]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricValuesSpec.scala:54: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   systemLoadAverageOption.get
[warn]               systemLoadAverageOption.get should be >= (0.0)
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricValuesSpec.scala:56: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   cpuCombinedOption.get
[warn]               cpuCombinedOption.get should be <= (1.0)
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricValuesSpec.scala:57: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   cpuCombinedOption.get
[warn]               cpuCombinedOption.get should be >= (0.0)
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricsCollectorSpec.scala:90: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MetricsCollectorSpec.this.collector.asInstanceOf[akka.cluster.JmxMetricsCollector]
[warn]       val c = collector.asInstanceOf[JmxMetricsCollector]
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricsCollectorSpec.scala:112: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MetricsCollectorFactory.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   private def extendedActorSystem = system.asInstanceOf[ExtendedActorSystem]
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricsCollectorSpec.scala:127: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   collector.isInstanceOf[akka.cluster.SigarMetricsCollector]
[warn]   private[cluster] def isSigar(collector: MetricsCollector): Boolean = collector.isInstanceOf[SigarMetricsCollector]
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricsCollectorSpec.scala:77: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   used.get
[warn]           used.get.longValue should be <= (b.longValue)
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricsCollectorSpec.scala:78: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   committed.get
[warn]           committed.get.longValue should be <= (b.longValue)
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricsCollectorSpec.scala:62: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   scala.util.Try.apply[akka.cluster.MetricsCollector](MetricsCollectorSpec.this.createMetricsCollector).get
[warn]       Try(createMetricsCollector).get should not be null
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\MetricsCollectorSpec.scala:125: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   scala.util.Try.apply[akka.cluster.SigarMetricsCollector](new SigarMetricsCollector(MetricsCollectorFactory.this.selfAddress, MetricsCollectorFactory.this.defaultDecayFactor, MetricsCollectorFactory.this.extendedActorSystem.dynamicAccess.createInstanceFor[AnyRef]("org.hyperic.sigar.Sigar", immutable.this.Nil)((ClassTag.AnyRef: scala.reflect.ClassTag[AnyRef])))).recover[akka.cluster.JmxMetricsCollector](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.Abstr
[warn]       }.get
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ReachabilityPerfSpec.scala:12: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   scala.sys.`package`.props.get("akka.cluster.ReachabilityPerfSpec.nodesSize").getOrElse[String]("250")
[warn]   val nodesSize = sys.props.get("akka.cluster.ReachabilityPerfSpec.nodesSize").getOrElse("250").toInt
[warn]                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ReachabilityPerfSpec.scala:13: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   scala.sys.`package`.props.get("akka.cluster.ReachabilityPerfSpec.iterations").getOrElse[String]("10000")
[warn]   val iterations = sys.props.get("akka.cluster.ReachabilityPerfSpec.iterations").getOrElse("10000").toInt
[warn]                                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ReachabilityPerfSpec.scala:58: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   r1.records.head
[warn]     val record = r1.records.head
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ReachabilityPerfSpec.scala:63: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   r1.records.head
[warn]     val record = r1.records.head
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ReachabilityPerfSpec.scala:68: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   r1.records.head
[warn]     val record = r1.records.head
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\ReachabilityPerfSpec.scala:73: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   r1.records.head
[warn]     val record = r1.records.head
[warn]                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\VectorClockPerfSpec.scala:60: [scapegoat] Avoid operator overload
[info]   Scala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.
[info]   def !==(vc1: VectorClock, vc2: VectorClock): Unit = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\VectorClockPerfSpec.scala:34: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   scala.sys.`package`.props.get("akka.cluster.VectorClockPerfSpec.clockSize").getOrElse[String]("1000")
[warn]   val clockSize = sys.props.get("akka.cluster.VectorClockPerfSpec.clockSize").getOrElse("1000").toInt
[warn]                                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\VectorClockPerfSpec.scala:35: [scapegoat] Use of Map.get().getOrElse instead of Map.getOrElse
[warn]   Map.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.
[warn]   scala.sys.`package`.props.get("akka.cluster.VectorClockPerfSpec.iterations").getOrElse[String]("10000")
[warn]   val iterations = sys.props.get("akka.cluster.VectorClockPerfSpec.iterations").getOrElse("10000").toInt
[warn]                                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\VectorClockPerfSpec.scala:38: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   VectorClockPerfSpec.this.nodes.head
[warn]   val firstNode = nodes.head
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\VectorClockPerfSpec.scala:39: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   VectorClockPerfSpec.this.nodes.last
[warn]   val lastNode = nodes.last
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\VectorClockPerfSpec.scala:40: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   VectorClockPerfSpec.this.nodes.drop(VectorClockPerfSpec.this.clockSize./(2)).head
[warn]   val middleNode = nodes.drop(clockSize / 2).head
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\protobuf\ClusterMessageSerializerSpec.scala:16: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val serializer = new ClusterMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\protobuf\ClusterMessageSerializerSpec.scala:23: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   obj.asInstanceOf[akka.cluster.GossipEnvelope]
[warn]         val env2 = obj.asInstanceOf[GossipEnvelope]
[warn]                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\test\scala\akka\cluster\routing\ClusterRouterSupervisorSpec.scala:13: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (testActor).
[warn]   class KillableActor(testActor: ActorRef) extends Actor {
[warn]                       ^
[info] [warn] [scapegoat] Analysis complete: 31 files - 0 errors 43 warns 6 infos
[warn] there were 95 deprecation warnings; re-run with -deprecation for details
[warn] 44 warnings found
[info] Compiling 33 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\target\multi-jvm-classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\AttemptSysMsgRedeliverySpec.scala:68: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AttemptSysMsgRedeliverySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val firstRef: ActorRef = expectMsgType[ActorIdentity].ref.get
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\AttemptSysMsgRedeliverySpec.scala:70: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AttemptSysMsgRedeliverySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val secondRef: ActorRef = expectMsgType[ActorIdentity].ref.get
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\LookupRemoteActorSpec.scala:62: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LookupRemoteActorSpec.this.awaitHelper[Any](akka.pattern.`package`.ask(hello).?("identify")(LookupRemoteActorSpec.this.timeout, LookupRemoteActorSpec.this.self)).await.asInstanceOf[akka.actor.ActorRef]
[warn]         (hello ? "identify").await.asInstanceOf[ActorRef].path.address should ===(masterAddress)
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\LookupRemoteActorSpec.scala:60: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   hello.isInstanceOf[akka.remote.RemoteActorRef]
[warn]         hello.isInstanceOf[RemoteActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\LookupRemoteActorSpec.scala:58: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   LookupRemoteActorSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]           expectMsgType[ActorIdentity].ref.get
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\NewRemoteActorSpec.scala:72: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.remote.RemoteActorRef]
[warn]         actor.isInstanceOf[RemoteActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\NewRemoteActorSpec.scala:87: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.remote.RemoteActorRef]
[warn]         actor.isInstanceOf[RemoteActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\NewRemoteActorSpec.scala:102: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.remote.RemoteActorRef]
[warn]         actor.isInstanceOf[RemoteActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\NewRemoteActorSpec.scala:116: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.remote.RemoteActorRef]
[warn]         actor.isInstanceOf[RemoteActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\NewRemoteActorSpec.scala:50: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (ignored).
[warn]   class SomeActorWithParam(ignored: String) extends Actor {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteDeliverySpec.scala:59: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteDeliverySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteDeliverySpec.scala:45: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   route.tail
[warn]       case Letter(n, route) ? route.head ! Letter(n, route.tail)
[warn]                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteDeploymentDeathWatchSpec.scala:100: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteDeploymentDeathWatchSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]               system.asInstanceOf[ActorSystemImpl].printTree))
[warn]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteGatePiercingSpec.scala:19: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.testconductor.RoleName
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteGatePiercingSpec.scala:62: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteGatePiercingSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeDeathWatchSpec.scala:110: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteNodeDeathWatchSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeDeathWatchSpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteNodeDeathWatchSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartDeathWatchSpec.scala:106: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteNodeRestartDeathWatchSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val addr = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartDeathWatchSpec.scala:74: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteNodeRestartDeathWatchSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartDeathWatchSpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]           akka.remote.netty.tcp.port = ${addr.port.get}
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartDeathWatchSpec.scala:116: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]           akka.remote.artery.canonical.port = ${addr.port.get}
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartGateSpec.scala:92: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteNodeRestartGateSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val addr = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartGateSpec.scala:19: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.testconductor.RoleName
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartGateSpec.scala:57: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteNodeRestartGateSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartGateSpec.scala:84: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteNodeRestartGateSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]             expectMsgType[ActorIdentity].ref.get
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartGateSpec.scala:102: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.host.get
[warn]                       hostname = ${addr.host.get}
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartGateSpec.scala:103: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]                       port = ${addr.port.get}
[warn]                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeRestartGateSpec.scala:113: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   probe.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]             probe.expectMsgType[ActorIdentity].ref.get
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeShutdownAndComesBackSpec.scala:126: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteNodeShutdownAndComesBackSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val addr = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeShutdownAndComesBackSpec.scala:17: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.testconductor.RoleName
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeShutdownAndComesBackSpec.scala:58: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteNodeShutdownAndComesBackSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeShutdownAndComesBackSpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteNodeShutdownAndComesBackSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         val subjectNew = expectMsgType[ActorIdentity].ref.get
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeShutdownAndComesBackSpec.scala:137: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]           akka.remote.netty.tcp.port = ${addr.port.get}
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteNodeShutdownAndComesBackSpec.scala:138: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]           akka.remote.artery.canonical.port = ${addr.port.get}
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteQuarantinePiercingSpec.scala:106: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteQuarantinePiercingSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val addr = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteQuarantinePiercingSpec.scala:17: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.testconductor.RoleName
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteQuarantinePiercingSpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]           akka.remote.netty.tcp.port = ${addr.port.get}
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteQuarantinePiercingSpec.scala:116: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]           akka.remote.artery.canonical.port = ${addr.port.get}
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteReDeploymentSpec.scala:149: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       var sys: ActorSystem = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteRestartedQuarantinedSpec.scala:100: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteRestartedQuarantinedSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val addr = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteRestartedQuarantinedSpec.scala:19: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.testconductor.RoleName
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteRestartedQuarantinedSpec.scala:92: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteRestartedQuarantinedSpec.this.expectMsgType[akka.actor.ActorIdentity](scala.concurrent.duration.`package`.DurationInt(1).second)((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]             expectMsgType[ActorIdentity](1.second).ref.get
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteRestartedQuarantinedSpec.scala:128: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.host.get
[warn]                       hostname = ${addr.host.get}
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\RemoteRestartedQuarantinedSpec.scala:129: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]                       port = ${addr.port.get}
[warn]                                          ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\Ticket15109Spec.scala:17: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.testconductor.RoleName
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamConcistencySpec.scala:67: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   AeronStreamConsistencySpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val r = new TaskRunner(system.asInstanceOf[ExtendedActorSystem], idleCpuLevel)
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamConcistencySpec.scala:36: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n       akka {\n         loglevel = INFO\n         actor {\n           provider = remote\n         }\n         remote.artery.enabled = off\n       }\n       ").s()
[warn]     ConfigFactory.parseString(s"""
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamConcistencySpec.scala:81: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   a.host.get
[warn]     s"aeron:udp?endpoint=${a.host.get}:${a.port.get}"
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamConcistencySpec.scala:81: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   a.port.get
[warn]     s"aeron:udp?endpoint=${a.host.get}:${a.port.get}"
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamLatencySpec.scala:103: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   AeronStreamLatencySpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val r = new TaskRunner(system.asInstanceOf[ExtendedActorSystem], idleCpuLevel)
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamLatencySpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   a.host.get
[warn]     s"aeron:udp?endpoint=${a.host.get}:${a.port.get}"
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamLatencySpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   a.port.get
[warn]     s"aeron:udp?endpoint=${a.host.get}:${a.port.get}"
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamLatencySpec.scala:254: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val rep: Int = _
[warn]       for (rep ← 1 to repeat) {
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamMaxThroughputSpec.scala:101: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   AeronStreamMaxThroughputSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val r = new TaskRunner(system.asInstanceOf[ExtendedActorSystem], idleCpuLevel)
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamMaxThroughputSpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   a.host.get
[warn]     s"aeron:udp?endpoint=${a.host.get}:${a.port.get}"
[warn]                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamMaxThroughputSpec.scala:115: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   a.port.get
[warn]     s"aeron:udp?endpoint=${a.host.get}:${a.port.get}"
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\AeronStreamMaxThroughputSpec.scala:58: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   private[this] var first: Boolean = true
[warn]     private[this] var first = true
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\HandshakeRestartReceiverSpec.scala:78: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.remote.RARP.apply(HandshakeRestartReceiverSpec.this.system).provider.transport.asInstanceOf[akka.remote.artery.ArteryTransport]
[warn]         val secondAssociation = RARP(system).provider.transport.asInstanceOf[ArteryTransport].association(secondAddress)
[warn]                                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\HandshakeRestartReceiverSpec.scala:102: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   HandshakeRestartReceiverSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val addr = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\HandshakeRestartReceiverSpec.scala:24: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n       akka {\n         loglevel = INFO\n         actor.provider = remote\n         remote.artery {\n           enabled = on\n         }\n       }\n       ").s()
[warn]     ConfigFactory.parseString(s"""
[warn]                               ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\HandshakeRestartReceiverSpec.scala:54: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def afterAll(): Unit = HandshakeRestartReceiverSpec.super.afterAll()
[info]   override def afterAll(): Unit = {
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\HandshakeRestartReceiverSpec.scala:108: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]               akka.remote.artery.canonical.port = ${addr.port.get}
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\LatencySpec.scala:65: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     var cachedSender: ActorRef = null
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\LatencySpec.scala:69: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]         cachedSender = null
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\LatencySpec.scala:72: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   Echo.this.cachedSender.==(null)
[warn]         if (cachedSender == null) cachedSender = sender()
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\LatencySpec.scala:198: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   LatencySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\LatencySpec.scala:122: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val payloadSize: Long = _).
[warn]     def printTotal(testName: String, payloadSize: Long, histogram: Histogram, totalDurationNanos: Long): Unit = {
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\LatencySpec.scala:122: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val histogram: org.HdrHistogram.Histogram = _
[warn]     def printTotal(testName: String, payloadSize: Long, histogram: Histogram, totalDurationNanos: Long): Unit = {
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\MaxThroughputSpec.scala:293: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MaxThroughputSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem].provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]   def remoteSettings = system.asInstanceOf[ExtendedActorSystem].provider.asInstanceOf[RemoteActorRefProvider].remoteSettings
[warn]                                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\MaxThroughputSpec.scala:182: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (true)

[warn]   ",compression"

[warn] else

[warn]   ""
[warn]             (if (RARP(context.system).provider.remoteSettings.Artery.Advanced.Compression.Enabled) ",compression" else "") + "), " +
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\MaxThroughputSpec.scala:237: [scapegoat] Constant if expression
[warn]   An if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.
[warn]   if (true)

[warn]   38

[warn] else

[warn]   110
[warn]     def totalSize(system: ActorSystem) = payloadSize + (if (RARP(system).provider.remoteSettings.Artery.Advanced.Compression.Enabled) 38 else 110)
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\MaxThroughputSpec.scala:124: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.remote.RARP.apply(Sender.this.context.system).provider.transport.isInstanceOf[akka.remote.artery.ArteryTransport]
[warn]       RARP(context.system).provider.transport.isInstanceOf[ArteryTransport] &&
[warn]                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\MaxThroughputSpec.scala:312: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   MaxThroughputSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\MaxThroughputSpec.scala:237: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val system: akka.actor.ActorSystem = _).
[warn]     def totalSize(system: ActorSystem) = payloadSize + (if (RARP(system).provider.remoteSettings.Artery.Advanced.Compression.Enabled) 38 else 110)
[warn]         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\RemoteRestartedQuarantinedSpec.scala:92: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   RemoteRestartedQuarantinedSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val addr = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\RemoteRestartedQuarantinedSpec.scala:106: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.remote.RARP.apply(RemoteRestartedQuarantinedSpec.this.system).provider.transport.asInstanceOf[akka.remote.artery.ArteryTransport]
[warn]         val firstAssociation = RARP(system).provider.transport.asInstanceOf[ArteryTransport].association(firstAddress)
[warn]                                                                            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\RemoteRestartedQuarantinedSpec.scala:19: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.remote.testconductor.RoleName
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\RemoteRestartedQuarantinedSpec.scala:84: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RemoteRestartedQuarantinedSpec.this.expectMsgType[akka.actor.ActorIdentity](scala.concurrent.duration.`package`.DurationInt(1).second)((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]             expectMsgType[ActorIdentity](1.second).ref.get
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\RemoteRestartedQuarantinedSpec.scala:117: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   addr.port.get
[warn]               akka.remote.artery.canonical.port = ${addr.port.get}
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\SurviveNetworkPartitionSpec.scala:53: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SurviveNetworkPartitionSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         val ref = expectMsgType[ActorIdentity].ref.get
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\artery\SurviveNetworkPartitionSpec.scala:90: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   SurviveNetworkPartitionSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         val ref = expectMsgType[ActorIdentity].ref.get
[warn]                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\routing\RemoteRandomSpec.scala:76: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.routing.RoutedActorRef]
[warn]         actor.isInstanceOf[RoutedActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\routing\RemoteRoundRobinSpec.scala:146: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(actor).?(akka.routing.GetRoutees)(RemoteRoundRobinSpec.this.timeout, RemoteRoundRobinSpec.this.self), RemoteRoundRobinSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]             Await.result(actor ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees.size should ===(n)
[warn]                                                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\routing\RemoteRoundRobinSpec.scala:93: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.routing.RoutedActorRef]
[warn]         actor.isInstanceOf[RoutedActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\routing\RemoteRoundRobinSpec.scala:136: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.routing.RoutedActorRef]
[warn]         actor.isInstanceOf[RoutedActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\routing\RemoteRoundRobinSpec.scala:178: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.routing.RoutedActorRef]
[warn]         actor.isInstanceOf[RoutedActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\routing\RemoteScatterGatherSpec.scala:79: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actor.isInstanceOf[akka.routing.RoutedActorRef]
[warn]         actor.isInstanceOf[RoutedActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-remote-tests\src\multi-jvm\scala\akka\remote\testconductor\TestConductorSpec.scala:42: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   TestConductorSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[info] [warn] [scapegoat] Analysis complete: 33 files - 0 errors 81 warns 8 infos
[warn] there was one deprecation warning; re-run with -deprecation for details
[warn] 81 warnings found
[info] Formatting 47 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-cluster(multi-jvm) ...
[info] Compiling 17 Scala sources and 1 Java source to D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\target\test-classes...
[info] [info] [scapegoat] 118 activated inspections
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\ORSetSpec.scala:303: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[Nothing]()
[info]       b2.elements should be(Set())
[info]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\VersionVectorSpec.scala:23: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def afterAll: Unit = VersionVectorSpec.this.shutdown(VersionVectorSpec.this.shutdown$default$1, VersionVectorSpec.this.shutdown$default$2, VersionVectorSpec.this.shutdown$default$3)
[warn]   override def afterAll {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\WriteAggregatorSpec.scala:34: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   TestWriteAggregator.this.probes.find(((x0$1: (akka.actor.Address, akka.actor.ActorRef)) => x0$1 match {

[warn]   case (_1: akka.actor.Address, _2: akka.actor.ActorRef)(akka.actor.Address, akka.actor.ActorRef)((a @ _), (r @ _)) => r.==(TestWriteAggregator.this.sender())

[warn] })).get
[warn]       probes.find { case (a, r) ? r == sender() }.get._1
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializerSpec.scala:36: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatedDataSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val serializer = new ReplicatedDataSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatedDataSerializerSpec.scala:44: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def afterAll: Unit = ReplicatedDataSerializerSpec.this.shutdown(ReplicatedDataSerializerSpec.this.shutdown$default$1, ReplicatedDataSerializerSpec.this.shutdown$default$2, ReplicatedDataSerializerSpec.this.shutdown$default$3)
[warn]   override def afterAll {
[warn]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializerSpec.scala:34: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ReplicatorMessageSerializerSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]   val serializer = new ReplicatorMessageSerializer(system.asInstanceOf[ExtendedActorSystem])
[warn]                                                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializerSpec.scala:178: [scapegoat] Method returning Any
[warn]   Method returns Any. Consider using a more specialized type.
[warn]   def createValue(a: akka.cluster.ddata.Replicator.Internal.Read): AnyRef = {

[warn]   n = n.+(1);

[warn]   {

[warn]     final class $anon extends scala.AnyRef {

[warn]       def <init>(): <$anon: AnyRef> = {

[warn]         $anon.super.<init>();

[warn]         ()

[warn]       };

[warn]       private[this] val toString: String = "v".+(n);

[warn]       ove
[warn]       def createValue(a: Read): AnyRef = {
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\test\scala\akka\cluster\ddata\protobuf\ReplicatorMessageSerializerSpec.scala:44: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   override def afterAll: Unit = ReplicatorMessageSerializerSpec.this.shutdown(ReplicatorMessageSerializerSpec.this.shutdown$default$1, ReplicatorMessageSerializerSpec.this.shutdown$default$2, ReplicatorMessageSerializerSpec.this.shutdown$default$3)
[warn]   override def afterAll {
[warn]                ^
[info] [warn] [scapegoat] Analysis complete: 17 files - 0 errors 8 warns 1 infos
[warn] there were 39 deprecation warnings; re-run with -deprecation for details
[warn] 8 warnings found
[info] Compiling 47 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\target\multi-jvm-classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\AttemptSysMsgRedeliverySpec.scala:54: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AttemptSysMsgRedeliverySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val firstRef: ActorRef = expectMsgType[ActorIdentity].ref.get
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\AttemptSysMsgRedeliverySpec.scala:56: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   AttemptSysMsgRedeliverySpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val secondRef: ActorRef = expectMsgType[ActorIdentity].ref.get
[warn]                                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\ClusterDeathWatchSpec.scala:234: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterDeathWatchSpec.this.system.asInstanceOf[akka.actor.ActorSystemImpl]
[warn]               system.asInstanceOf[ActorSystemImpl].printTree))
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\ClusterDeathWatchSpec.scala:214: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   hello.isInstanceOf[akka.remote.RemoteActorRef]
[warn]         hello.isInstanceOf[RemoteActorRef] should ===(true)
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\ClusterDeathWatchSpec.scala:58: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ClusterDeathWatchSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]     expectMsgType[ActorIdentity].ref.get
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\ClusterDeathWatchSpec.scala:157: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   ClusterDeathWatchSpec.this.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]         val subject5 = expectMsgType[ActorIdentity].ref.get
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\ClusterMetricsSpec.scala:36: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   collector.isInstanceOf[akka.cluster.SigarMetricsCollector]
[warn]   private[cluster] def isSigar(collector: MetricsCollector): Boolean = collector.isInstanceOf[SigarMetricsCollector]
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\DeterministicOldestWhenJoiningSpec.scala:49: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   DeterministicOldestWhenJoiningSpec.this.seedNodes.head
[warn]       runOn(roleByAddress(seedNodes.head)) {
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\DeterministicOldestWhenJoiningSpec.scala:60: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   DeterministicOldestWhenJoiningSpec.this.seedNodes.head
[warn]         ups.map(_.member).sorted(Member.ageOrdering).head.address should ===(seedNodes.head)
[warn]                                                                                        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\LeaderElectionSpec.scala:63: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]       currentRoles.size should be >= (2)
[info]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\LeaderElectionSpec.scala:105: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]           awaitMembersUp(currentRoles.size - 1)
[info]                                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\LeaderElectionSpec.scala:54: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   LeaderElectionSpec.this.sortedRoles.head
[warn]         clusterView.isLeader should ===(myself == sortedRoles.head)
[warn]                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\LeaderElectionSpec.scala:64: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   currentRoles.head
[warn]       val leader = currentRoles.head
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\LeaderElectionSpec.scala:65: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   currentRoles.last
[warn]       val aUser = currentRoles.last
[warn]                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\LeaderElectionSpec.scala:66: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   currentRoles.tail
[warn]       val remainingRoles = currentRoles.tail
[warn]                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\LeaderElectionSpec.scala:106: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   remainingRoles.head
[warn]           val nextExpectedLeader = remainingRoles.head
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\LeaderLeavingSpec.scala:44: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   LeaderLeavingSpec.this.clusterView.leader.get
[warn]       val oldLeaderAddress = clusterView.leader.get
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MBeanSpec.scala:62: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MBeanSpec.this.mbeanServer.getAttribute(MBeanSpec.this.mbeanName, "Available").asInstanceOf[Boolean]
[warn]         mbeanServer.getAttribute(mbeanName, "Available").asInstanceOf[Boolean] should ===(false)
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MBeanSpec.scala:63: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MBeanSpec.this.mbeanServer.getAttribute(MBeanSpec.this.mbeanName, "Singleton").asInstanceOf[Boolean]
[warn]         mbeanServer.getAttribute(mbeanName, "Singleton").asInstanceOf[Boolean] should ===(false)
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MBeanSpec.scala:73: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MBeanSpec.this.mbeanServer.getAttribute(MBeanSpec.this.mbeanName, "Singleton").asInstanceOf[Boolean]
[warn]         mbeanServer.getAttribute(mbeanName, "Singleton").asInstanceOf[Boolean] should ===(true)
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MBeanSpec.scala:76: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MBeanSpec.this.mbeanServer.getAttribute(MBeanSpec.this.mbeanName, "Available").asInstanceOf[Boolean]
[warn]         mbeanServer.getAttribute(mbeanName, "Available").asInstanceOf[Boolean] should ===(true)
[warn]                                                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MBeanSpec.scala:94: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   MBeanSpec.this.mbeanServer.getAttribute(MBeanSpec.this.mbeanName, "Singleton").asInstanceOf[Boolean]
[warn]       mbeanServer.getAttribute(mbeanName, "Singleton").asInstanceOf[Boolean] should ===(false)
[warn]                                                                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MultiNodeClusterSpec.scala:308: [scapegoat] !isEmpty can be replaced with nonEmpty
[info]   !.isEmpty can be replaced with.nonEmpty to make it easier to reason about.
[info]   canNotBePartOfMemberRing.isEmpty.unary_!
[info]       if (!canNotBePartOfMemberRing.isEmpty) // don't run this on an empty set
[info]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MultiNodeClusterSpec.scala:220: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   roles.head
[warn]     runOn(roles.head) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MultiNodeClusterSpec.scala:226: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   roles.head
[warn]       cluster.join(roles.head)
[warn]                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\MultiNodeClusterSpec.scala:337: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   nodesInCluster.sorted[akka.remote.testconductor.RoleName](MultiNodeClusterSpec.this.clusterOrdering).head
[warn]     nodesInCluster.sorted.head
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\NodeChurnSpec.scala:83: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Cluster(s).self:").s()
[warn]           withClue(s"Cluster(s).self:") {
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\NodeChurnSpec.scala:55: [scapegoat] Noop override
[info]   This method is overridden yet only calls super.
[info]   override def afterAll(): Unit = NodeChurnSpec.super.afterAll()
[info]   override def afterAll(): Unit = {
[info]                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\NodeMembershipSpec.scala:63: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   NodeMembershipSpec.this.clusterView.members.find(((x$3: akka.cluster.Member) => x$3.address.==(NodeMembershipSpec.this.address(NodeMembershipMultiJvmSpec.first)))).get
[warn]       val firstMember = clusterView.members.find(_.address == address(first)).get
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\NodeMembershipSpec.scala:64: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   NodeMembershipSpec.this.clusterView.members.find(((x$4: akka.cluster.Member) => x$4.address.==(NodeMembershipSpec.this.address(NodeMembershipMultiJvmSpec.second)))).get
[warn]       val secondMember = clusterView.members.find(_.address == address(second)).get
[warn]                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\NodeMembershipSpec.scala:65: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   NodeMembershipSpec.this.clusterView.members.find(((x$5: akka.cluster.Member) => x$5.address.==(NodeMembershipSpec.this.address(NodeMembershipMultiJvmSpec.third)))).get
[warn]       val thirdMember = clusterView.members.find(_.address == address(third)).get
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\QuickRestartSpec.scala:57: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]       var restartingSystem: ActorSystem = null // only used on second
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\QuickRestartSpec.scala:75: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Cluster.apply(restartingSystem).selfAddress.port.get
[warn]                        akka.remote.artery.canonical.port = ${Cluster(restartingSystem).selfAddress.port.get}
[warn]                                                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\QuickRestartSpec.scala:80: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Cluster.apply(restartingSystem).selfAddress.port.get
[warn]                       akka.remote.netty.tcp.port = ${Cluster(restartingSystem).selfAddress.port.get}
[warn]                                                                                                 ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\QuickRestartSpec.scala:110: [scapegoat] Prefer Set.empty
[info]   `Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.
[info]   scala.this.Predef.Set.apply[Nothing]()
[info]         Cluster(system).state.unreachable should ===(Set())
[info]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\RestartFirstSeedNodeSpec.scala:59: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RestartFirstSeedNodeSpec.this.seedNodes.head.port.get
[warn]         "akka.remote.artery.canonical.port=" + seedNodes.head.port.get
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\RestartFirstSeedNodeSpec.scala:61: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RestartFirstSeedNodeSpec.this.seedNodes.head.port.get
[warn]         "akka.remote.netty.tcp.port=" + seedNodes.head.port.get
[warn]                                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\RestartNode2Spec.scala:59: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RestartNode2SpecSpec.this.seedNodes.head.port.get
[warn]       akka.remote.netty.tcp.port= ${seedNodes.head.port.get}
[warn]                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\RestartNode3Spec.scala:55: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RestartNode3Spec.this.secondUniqueAddress.address.port.get
[warn]         "akka.remote.artery.canonical.port=" + secondUniqueAddress.address.port.get
[warn]                                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\RestartNode3Spec.scala:57: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RestartNode3Spec.this.secondUniqueAddress.address.port.get
[warn]         "akka.remote.netty.tcp.port=" + secondUniqueAddress.address.port.get
[warn]                                                                          ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\RestartNodeSpec.scala:74: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   RestartNodeSpec.this.secondUniqueAddress.address.port.get
[warn]     ConfigFactory.parseString("akka.remote.netty.tcp.port=" + secondUniqueAddress.address.port.get).
[warn]                                                                                                ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\SplitBrainSpec.scala:14: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import scala.concurrent.duration._
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:902: [scapegoat] Use of apply method on a non-indexed Seq
[warn]   Using an index to access elements of an IndexedSeq may cause performance problems.
[warn]   StressSpec.this.roles.apply(StressSpec.this.nbrUsedRoles.-(1))
[warn]     val removeRole = roles(nbrUsedRoles - 1)
[warn]                           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:265: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import akka.cluster.Member.addressOrdering
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:911: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   StressSpec.this.identifyProbe.expectMsgType[akka.actor.ActorIdentity]((ClassTag.apply[akka.actor.ActorIdentity](classOf[akka.actor.ActorIdentity]): scala.reflect.ClassTag[akka.actor.ActorIdentity])).ref.get
[warn]       val watchee = identifyProbe.expectMsgType[ActorIdentity].ref.get
[warn]                                                                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:798: [scapegoat] Parameterless methods returns unit
[warn]   Methods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().
[warn]   <stable> <accessor> lazy def createWorker: Unit = {

[warn]   StressSpec.this.system.actorOf(akka.actor.Props.apply[akka.cluster.StressMultiJvmSpec.Worker]()((ClassTag.apply[akka.cluster.StressMultiJvmSpec.Worker](classOf[akka.cluster.StressMultiJvmSpec$$Worker]): scala.reflect.ClassTag[akka.cluster.Stress
[warn]   lazy val createWorker: Unit =
[warn]            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:301: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   ClusterResultAggregator.this.results.map[scala.concurrent.duration.Duration, scala.collection.immutable.Vector[scala.concurrent.duration.Duration]](((x$4: akka.cluster.StressMultiJvmSpec.ClusterResult) => x$4.duration))(immutable.this.Vector.canBuildFrom[scala.concurrent.duration.Duration]).max
[warn]     def maxDuration = results.map(_.duration).max
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:802: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]     runOn(roles.head) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:831: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]     runOn(roles.head) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:859: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   currentRoles.last
[warn]         runOn(currentRoles.last) {
[warn]                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:860: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]           cluster.join(roles.head)
[warn]                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:880: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]             else cluster.join(roles.head)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:909: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]     runOn(roles.head) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:918: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]         runOn(roles.head) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:930: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]     runOn(roles.head) {
[warn]                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:953: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]           runOn(roles.head) {
[warn]                       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:1159: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   StressSpec.this.roles.head
[warn]         runOn(roles.head) {
[warn]                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:307: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   <synthetic> val nodeMetrics: akka.cluster.NodeMetrics = _
[warn]       (formatMetricsHeader +: (nodeMetrics.toSeq.sortBy(_.address) map formatMetricsLine)).mkString("\n")
[warn]                                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:312: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val nodeMetrics: akka.cluster.NodeMetrics = _
[warn]     def formatMetricsLine(nodeMetrics: NodeMetrics): String = {
[warn]                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\StressSpec.scala:1101: [scapegoat] Var in closure
[warn]   Closing over a var can lead to subtle bugs.
[warn]   StressSpec.this.createResultAggregator(title, StressSpec.this.nbrUsedRoles, false)
[warn]         createResultAggregator(title, expectedResults = nbrUsedRoles, includeInHistory = false)
[warn]                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\SurviveNetworkInstabilitySpec.scala:270: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   SurviveNetworkInstabilitySpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem].provider.asInstanceOf[akka.remote.RemoteActorRefProvider]
[warn]         val sysMsgBufferSize = system.asInstanceOf[ExtendedActorSystem].provider.asInstanceOf[RemoteActorRefProvider].
[warn]                                                                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\SurviveNetworkInstabilitySpec.scala:54: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class Targets(refs: Set[ActorRef])
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\TransitionSpec.scala:45: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   roles.sorted[akka.remote.testconductor.RoleName](TransitionSpec.this.clusterOrdering).head
[warn]   def leader(roles: RoleName*) = roles.sorted.head
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\TransitionSpec.scala:46: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   roles.toSeq.sorted[akka.remote.testconductor.RoleName](TransitionSpec.this.clusterOrdering).tail
[warn]   def nonLeader(roles: RoleName*) = roles.toSeq.sorted.tail
[warn]                                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\TransitionSpec.scala:190: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   tmp.head
[warn]       val (other1, other2) = { val tmp = roles.filterNot(_ == leader12); (tmp.head, tmp.tail.head) }
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\TransitionSpec.scala:190: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   tmp.tail.head
[warn]       val (other1, other2) = { val tmp = roles.filterNot(_ == leader12); (tmp.head, tmp.tail.head) }
[warn]                                                                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\TransitionSpec.scala:46: [scapegoat] Unnecessary conversion
[warn]   Unnecessary toSeq on a Seq.
[warn]   roles.toSeq
[warn]   def nonLeader(roles: RoleName*) = roles.toSeq.sorted.tail
[warn]                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\UnreachableNodeJoinsAgainSpec.scala:163: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   UnreachableNodeJoinsAgainSpec.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]         val victimAddress = system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                                ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\UnreachableNodeJoinsAgainSpec.scala:169: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   victimAddress.host.get
[warn]                   hostname = ${victimAddress.host.get}
[warn]                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\UnreachableNodeJoinsAgainSpec.scala:170: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   victimAddress.port.get
[warn]                   port = ${victimAddress.port.get}
[warn]                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\UnreachableNodeJoinsAgainSpec.scala:175: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   victimAddress.host.get
[warn]                 hostname = ${victimAddress.host.get}
[warn]                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\UnreachableNodeJoinsAgainSpec.scala:176: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   victimAddress.port.get
[warn]                 port = ${victimAddress.port.get}
[warn]                                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\AdaptiveLoadBalancingRouterSpec.scala:99: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(router).?(akka.routing.GetRoutees)(AdaptiveLoadBalancingRouterSpec.this.timeout, AdaptiveLoadBalancingRouterSpec.this.self), AdaptiveLoadBalancingRouterSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]     Await.result(router ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\AdaptiveLoadBalancingRouterSpec.scala:85: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn] class TestCustomMetricsSelector(config: Config) extends MetricsSelector {
[warn]                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingGroupSpec.scala:62: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(router).?(akka.routing.GetRoutees)(ClusterConsistentHashingGroupSpec.this.timeout, ClusterConsistentHashingGroupSpec.this.self), ClusterConsistentHashingGroupSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]     Await.result(router ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees
[warn]                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingGroupSpec.scala:95: [scapegoat] List.size is O(n)
[info]   List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.
[info]       (a.size + b.size + c.size) should ===(keys.size)
[info]                                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingRouterSpec.scala:72: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(router).?(akka.routing.GetRoutees)(ClusterConsistentHashingRouterSpec.this.timeout, ClusterConsistentHashingRouterSpec.this.self), ClusterConsistentHashingRouterSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]     Await.result(router ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterConsistentHashingRouterSpec.scala:40: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\n      common-router-settings = {\n        router = consistent-hashing-pool\n        cluster {\n          enabled = on\n          max-nr-of-instances-per-node = 2\n          max-total-nr-of-instances = 10\n        }\n      }\n\n      akka.actor.deployment {\n        /router1 = ${common-router-settings}\n        /router3 = ${common-router-settings}\n        /router4 = ${common-router-settings}\n      }\n      ").s()
[warn]     withFallback(ConfigFactory.parseString(s"""
[warn]                                            ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterRoundRobinSpec.scala:134: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(router).?(akka.routing.GetRoutees)(ClusterRoundRobinSpec.this.timeout, ClusterRoundRobinSpec.this.self), ClusterRoundRobinSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]     Await.result(router ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterRoundRobinSpec.scala:145: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterRoundRobinSpec.this.router1.isInstanceOf[akka.routing.RoutedActorRef]
[warn]         router1.isInstanceOf[RoutedActorRef] should ===(true)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterRoundRobinSpec.scala:291: [scapegoat] Use of isInstanceOf
[warn]   Use of isInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ClusterRoundRobinSpec.this.router2.isInstanceOf[akka.routing.RoutedActorRef]
[warn]         router2.isInstanceOf[RoutedActorRef] should ===(true)
[warn]                             ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterRoundRobinSpec.scala:348: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   routeeAddresses.find(((x$4: akka.actor.Address) => x$4.!=(ClusterRoundRobinSpec.this.address(ClusterRoundRobinMultiJvmSpec.first)))).get
[warn]         val downAddress = routeeAddresses.find(_ != address(first)).get
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterRoundRobinSpec.scala:351: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   routees.collectFirst[akka.actor.ActorRef](({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[akka.routing.Routee,akka.actor.ActorRef] with Serializable {

[warn]     def <init>(): <$anon: akka.routing.Routee => akka.actor.ActorRef> = {

[warn]       $anonfun.super.<init>();

[warn]       ()

[warn]     };

[warn]     final override def applyOrElse[A1 <: akka.routing.Routee, B1 >: akka.actor.ActorRef](x3: A1, default: A1 => B1): B1 = ((x3.asInstanceOf[akka.routing.Rout
[warn]         }.get
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\ClusterRoundRobinSpec.scala:347: [scapegoat] Use of unsafe Traversable methods.
[warn]   The following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).
[warn]   ClusterRoundRobinSpec.this.roles.map[akka.actor.Address, scala.collection.immutable.Seq[akka.actor.Address]]({

[warn]   ((role: akka.remote.testconductor.RoleName) => ClusterRoundRobinSpec.this.address(role))

[warn] })(immutable.this.Seq.canBuildFrom[akka.actor.Address]).toSet[akka.actor.Address].diff(routeeAddresses).head
[warn]         val notUsedAddress = ((roles map address).toSet diff routeeAddresses).head
[warn]                                                                               ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-cluster\src\multi-jvm\scala\akka\cluster\routing\UseRoleIgnoredSpec.scala:83: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[Any](akka.pattern.`package`.ask(router).?(akka.routing.GetRoutees)(UseRoleIgnoredSpec.this.timeout, UseRoleIgnoredSpec.this.self), UseRoleIgnoredSpec.this.timeout.duration).asInstanceOf[akka.routing.Routees]
[warn]     Await.result(router ? GetRoutees, timeout.duration).asInstanceOf[Routees].routees
[warn]                                                                     ^
[info] [warn] [scapegoat] Analysis complete: 47 files - 0 errors 76 warns 9 infos
[warn] there were 10 deprecation warnings; re-run with -deprecation for details
[warn] 77 warnings found
[info] Formatting 6 Scala sources {file:/D:/data/akka-akka/akka-akka-4f9dc51/}akka-distributed-data-experimental(multi-jvm) ...
[info] Compiling 44 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\target\classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\BenchRunner.scala:9: [scapegoat] Java conversions
[warn]   Use of Java conversions can lead to unusual behaviour. It is recommended to use JavaConverters.
[warn]     import scala.collection.JavaConversions._
[warn]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\ActorPathValidationBenchmark.scala:46: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def oldActor_1: Option[List[String]] = ElementRegex.unapplySeq(a)
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\ActorPathValidationBenchmark.scala:49: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def handLoopActor_1: Boolean = ActorPath.isValidPathElement(a)
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\ForkJoinActorBenchmark.scala:108: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Pipe.this.next.get
[warn]         if (next.isDefined) next.get forward m
[warn]                                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\ForkJoinActorBenchmark.scala:111: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   Pipe.this.next.get
[warn]         if (next.isDefined) next.get forward s
[warn]                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:115: [scapegoat] Empty case class
[info]   An empty case class can be rewritten as a case object.
[info]   case class UnboundedDroppingMailbox() extends MailboxType with ProducesMessageQueue[DroppingMessageQueue] {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:30: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("| akka {\n          |   log-dead-letters = off\n          |   actor {\n          |     default-dispatcher {\n          |       executor = \"fork-join-executor\"\n          |       fork-join-executor {\n          |         parallelism-min = 1\n          |         parallelism-max = 4\n          |       }\n          |       throughput = 1\n          |     }\n          |   }\n          | }\n          | dropping-dispatcher {\n          |   fork-join-executor.parallelism-min
[warn]       s"""| akka {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:115: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class UnboundedDroppingMailbox() extends MailboxType with ProducesMessageQueue[DroppingMessageQueue] {
[info]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:80: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     actor = null
[warn]           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:81: [scapegoat] Null assignment
[warn]   Use an Option instead when the value can be empty.
[warn]     probe = null
[warn]           ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:119: [scapegoat] Redundant final modifier on a method
[info]   A final modifier on methods that cannot be overridden is redundant.
[info]     final override def create(owner: Option[ActorRef], system: Option[ActorSystem]): MessageQueue =
[info]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:117: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (settings).
[warn]     def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\actor\TellOnlyBenchmark.scala:117: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused constructor parameter (config).
[warn]     def this(settings: ActorSystem.Settings, config: Config) = this()
[warn]                                              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\dispatch\CachingConfigBenchmark.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @Benchmark def deep_config = deepConfig.hasPath(deepKey)
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\dispatch\CachingConfigBenchmark.scala:25: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @Benchmark def deep_caching = deepCaching.hasPath(deepKey)
[info]                  ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\event\LogLevelAccessBenchmark.scala:34: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   akka.event.Logging.apply[String](LogLevelAccessBenchmark.this.NoopBus, "")(event.this.LogSource.fromString).asInstanceOf[akka.event.BusLogging]
[warn]   var log: BusLogging = akka.event.Logging(NoopBus, "").asInstanceOf[BusLogging]
[warn]                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\event\LogLevelAccessBenchmark.scala:44: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def setLogLevel_1(): Unit =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\event\LogLevelAccessBenchmark.scala:49: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def setLogLevel_2(): Unit =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBenchmark.scala:64: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def single_request(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBenchmark.scala:71: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def single_request_pool(): Unit = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBenchmark.scala:74: [scapegoat] Use of Try.get
[warn]   Using Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   response.get
[warn]     Await.result(Unmarshal(response.get.entity).to[String], 1.second)
[warn]                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBlueprintBenchmark.scala:88: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("HTTP/1.1 200 OK\\r\\n").s()
[warn]     s"HTTP/1.1 200 OK\r\n" +
[warn]     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBlueprintBenchmark.scala:89: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("Content-Length: 0\\r\\n").s()
[warn]       s"Content-Length: 0\r\n" +
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBlueprintBenchmark.scala:90: [scapegoat] Empty interpolated string
[warn]   String declared as interpolated but has no parameters can be turned into a regular string.
[warn]   scala.StringContext.apply("\\r\\n").s()
[warn]       s"\r\n"
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBlueprintBenchmark.scala:93: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def TCPPlacebo(requests: Int): Flow[ByteString, ByteString, NotUsed] =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpBlueprintBenchmark.scala:114: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def run_10000_reqs() = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpMessageMatchingBenchmark.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def res_matching: HttpResponse = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpMessageMatchingBenchmark.scala:31: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def req_matching: HttpRequest = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpRequestParsingBenchmark.scala:14: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.event.NoLogging
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpRequestParsingBenchmark.scala:93: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def parse_10000_requests_val(blackhole: Blackhole): Unit = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpRequestParsingBenchmark.scala:86: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val bytes: akka.stream.TLSProtocol.SessionBytes = _).
[warn]   def flow(bytes: SessionBytes, n: Int): RunnableGraph[Future[Done]] =
[warn]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpRequestParsingBenchmark.scala:93: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (val blackhole: org.openjdk.jmh.infra.Blackhole = _).
[warn]   def parse_10000_requests_val(blackhole: Blackhole): Unit = {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpResponseRenderingBenchmark.scala:61: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def TCPPlacebo(requests: Int): Flow[ByteString, ByteString, NotUsed] =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpResponseRenderingBenchmark.scala:67: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def TlsPlacebo = TLSPlacebo()
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpResponseRenderingBenchmark.scala:194: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def simple_response(blackhole: Blackhole): Unit =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpResponseRenderingBenchmark.scala:199: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def json_response(blackhole: Blackhole): Unit =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpResponseRenderingBenchmark.scala:211: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def json_long_raw_response(blackhole: Blackhole): Unit =
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpResponseRenderingBenchmark.scala:224: [scapegoat] Null parameter
[warn]   Use an Option instead when the value can be empty and pass down a None instead.
[warn]   JitSafeLatch.this.blackhole.ne(null)
[warn]           if (blackhole ne null) blackhole.consume(grab(in))
[warn]                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\http\HttpResponseRenderingBenchmark.scala:236: [scapegoat] Unused parameter
[warn]   Unused constructor or method parameters should be removed.
[warn]   Unused method parameter (implicit val mat: akka.stream.Materializer = _).
[warn]   def renderToImpl(ctx: ResponseRenderingContext, blackhole: Blackhole, n: Int)(implicit mat: Materializer): CountDownLatch = {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\LevelDbBatchingBenchmark.scala:69: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def write_1(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\LevelDbBatchingBenchmark.scala:77: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def writeBatch_10(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\LevelDbBatchingBenchmark.scala:85: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def writeBatch_100(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\LevelDbBatchingBenchmark.scala:93: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def writeBatch_200(): Unit = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\LevelDbBatchingBenchmark.scala:100: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val sys: akka.actor.ActorSystem = _
[warn]   private def deleteStorage(sys: ActorSystem) {
[warn]                             ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistenceActorDeferBenchmark.scala:83: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] class `persistAsync, defer`(respondAfter: Int) extends PersistentActor {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistenceActorDeferBenchmark.scala:96: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] class `persistAsync, defer, respond ASAP`(respondAfter: Int) extends PersistentActor {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistenceActorDeferBenchmark.scala:67: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def tell_persistAsync_defer_persistAsync_reply(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistenceActorDeferBenchmark.scala:75: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def tell_persistAsync_defer_persistAsync_replyASAP(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorBenchmark.scala:65: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def actor_normalActor_reply_baseline(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorBenchmark.scala:73: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def persistentActor_persist_reply(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorBenchmark.scala:81: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def persistentActor_persistAsync_reply(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorBenchmark.scala:89: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def persistentActor_noPersist_reply(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorBenchmark.scala:97: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def persistentActor_persistAsync_replyRightOnCommandReceive(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:13: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import scala.concurrent.duration._
[info]        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:205: [scapegoat] Empty if expression
[warn]   An empty if block is considered as dead code.
[warn]   if (DestinationActor.this.seqNr.%(11).==(0))

[warn]   ()

[warn] else

[warn]   akka.actor.`package`.actorRef2Scala(DestinationActor.this.sender()).!(Confirm.apply(deliveryId))(DestinationActor.this.self)
[warn]       if (seqNr % 11 == 0) {
[warn]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:187: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class Msg(deliveryId: Long, n: Int)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:189: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class Confirm(deliveryId: Long)
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:193: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class MsgSent(n: Int) extends Event
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:195: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info] case class MsgConfirmed(deliveryId: Long) extends Event
[info]            ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:64: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def persistentActor_persistAsync_with_AtLeastOnceDelivery(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:72: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def persistentActor_persist_with_AtLeastOnceDelivery(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\persistence\PersistentActorWithAtLeastOnceDeliveryBenchmark.scala:80: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def persistentActor_noPersist_with_AtLeastOnceDelivery(): Unit = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:66: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CodecBenchmark.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     system.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress,
[warn]                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:97: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CodecBenchmark.this.systemB.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]     val addressB = systemB.asInstanceOf[ExtendedActorSystem].provider.getDefaultAddress
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:101: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   scala.concurrent.Await.result[akka.actor.ActorRef](CodecBenchmark.this.system.actorSelection(rootB./("user")./("b")).resolveOne(scala.concurrent.duration.`package`.DurationInt(5).seconds), scala.concurrent.duration.`package`.DurationInt(5).seconds).asInstanceOf[akka.remote.RemoteActorRef]
[warn]         .asInstanceOf[RemoteActorRef]
[warn]                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:102: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   actorOnSystemA.asInstanceOf[akka.actor.InternalActorRef]
[warn]     resolvedRef = actorOnSystemA.asInstanceOf[InternalActorRef]
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:143: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CodecBenchmark.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       Flow.fromGraph(new Encoder(uniqueLocalAddress, system.asInstanceOf[ExtendedActorSystem], outboundEnvelopePool, envelopePool, false))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:171: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CodecBenchmark.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       Flow.fromGraph(new Decoder(inboundContext, system.asInstanceOf[ExtendedActorSystem],
[warn]                                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:200: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CodecBenchmark.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       Flow.fromGraph(new Encoder(uniqueLocalAddress, system.asInstanceOf[ExtendedActorSystem], outboundEnvelopePool, envelopePool, false))
[warn]                                                                         ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:212: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   CodecBenchmark.this.system.asInstanceOf[akka.actor.ExtendedActorSystem]
[warn]       Flow.fromGraph(new Decoder(inboundContext, system.asInstanceOf[ExtendedActorSystem],
[warn]                                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\CodecBenchmark.scala:195: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def encode_decode(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\FlightRecorderBench.scala:10: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import java.util.concurrent.TimeUnit
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\FlightRecorderBench.scala:46: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def flight_recorder_writes(): Unit = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\LiteralEncodingBenchmark.scala:65: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LiteralEncodingBenchmark.this.literalChars.apply(i).asInstanceOf[Byte]
[warn]       literalBytes(i) = literalChars(i).asInstanceOf[Byte]
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\LiteralEncodingBenchmark.scala:76: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LiteralEncodingBenchmark.this.literalBytes.apply(i).asInstanceOf[Char]
[warn]       literalChars(i) = literalBytes(i).asInstanceOf[Char]
[warn]                                                     ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\LiteralEncodingBenchmark.scala:87: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LiteralEncodingBenchmark.this.unsafe.getObject(LiteralEncodingBenchmark.this.str, LiteralEncodingBenchmark.this.stringValueFieldOffset).asInstanceOf[Array[Char]]
[warn]     val chars = unsafe.getObject(str, stringValueFieldOffset).asInstanceOf[Array[Char]]
[warn]                                                                           ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\LiteralEncodingBenchmark.scala:90: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   chars.apply(i).asInstanceOf[Byte]
[warn]       literalBytes(i) = chars(i).asInstanceOf[Byte]
[warn]                                              ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\LiteralEncodingBenchmark.scala:101: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   LiteralEncodingBenchmark.this.literalBytes.apply(i).asInstanceOf[Char]
[warn]       literalChars(i) = literalBytes(i).asInstanceOf[Char]
[warn]                                                     ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\compress\InvertCompressionTableBenchmark.scala:25: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @Benchmark def invert_comp_to_decomp_256 = compTable_256.invert
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\remote\artery\compress\InvertCompressionTableBenchmark.scala:26: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   @Benchmark def invert_comp_to_decomp_1024 = compTable_1024.invert
[info]                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FlatMapMergeBenchmark.scala:52: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def flat_map_merge_100k_elements(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FlowMapBenchmark.scala:121: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def flow_map_100k_elements(): Unit = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FlowMapBenchmark.scala:131: [scapegoat] Variable shadowing
[warn]   Variable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.
[warn]   val flow: => akka.stream.Graph[akka.stream.FlowShape[O,O], _] = _
[warn]   private def mkMaps[O, Mat](source: Source[O, Mat], count: Int)(flow: => Graph[FlowShape[O, O], _]): Source[O, Mat] = {
[warn]                                                                  ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:258: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def single_identity(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:265: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def chain_of_identities(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:272: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def single_map(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:279: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def chain_of_maps(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:286: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def repeat_take_map_and_fold(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:293: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def single_buffer(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:300: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def chain_of_buffers(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:307: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def broadcast_zip(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:314: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def balance_merge(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\FusedGraphsBenchmark.scala:321: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def boradcast_zip_balance_merge(blackhole: org.openjdk.jmh.infra.Blackhole): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\GraphBuilderBenchmark.scala:19: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def flow_with_map(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\GraphBuilderBenchmark.scala:24: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def graph_with_junctions(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\GraphBuilderBenchmark.scala:29: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def graph_with_nested_imports(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\GraphBuilderBenchmark.scala:34: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def graph_with_imported_flow(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\InterpreterBenchmark.scala:5: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info] import akka.stream.impl.fusing.GraphStages
[info]        ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\InterpreterBenchmark.scala:52: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class GraphDataSource[T](override val toString: String, data: Vector[T]) extends UpstreamBoundaryStageLogic[T] {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\InterpreterBenchmark.scala:70: [scapegoat] Missing final modifier on case class
[info]   Using case classes without final modifier can lead to surprising breakage.
[info]   case class GraphDataSink[T](override val toString: String, var expected: Int) extends DownstreamBoundaryStageLogic[T] {
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\InterpreterBenchmark.scala:26: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def graph_interpreter_100k_elements(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:47: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def counting_1: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:52: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def counting_offer_5: ByteString = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:48: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   JsonFramingBenchmark.this.bracket.poll().get
[warn]     bracket.poll().get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:54: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   JsonFramingBenchmark.this.bracket.poll().get
[warn]     bracket.poll().get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:55: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   JsonFramingBenchmark.this.bracket.poll().get
[warn]     bracket.poll().get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:56: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   JsonFramingBenchmark.this.bracket.poll().get
[warn]     bracket.poll().get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:57: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   JsonFramingBenchmark.this.bracket.poll().get
[warn]     bracket.poll().get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:58: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   JsonFramingBenchmark.this.bracket.poll().get
[warn]     bracket.poll().get
[warn]                    ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\JsonFramingBenchmark.scala:59: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   JsonFramingBenchmark.this.bracket.poll().get
[warn]     bracket.poll().get
[warn]                    ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\MaterializationBenchmark.scala:52: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import GraphDSL.Implicits._
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\MaterializationBenchmark.scala:60: [scapegoat] Duplicate import
[info]   Duplicate imports should be removed.
[info]       import GraphDSL.Implicits._
[info]              ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\MaterializationBenchmark.scala:104: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def flow_with_map(): Unit = flowWithMap.run()
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\MaterializationBenchmark.scala:107: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def graph_with_junctions(): Unit = graphWithJunctions.run()
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\MaterializationBenchmark.scala:110: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def graph_with_nested_imports(): Unit = graphWithNestedImports.run()
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\MaterializationBenchmark.scala:113: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def graph_with_imported_flow(): Unit = graphWithImportedFlow.run()
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\io\FileSourcesBenchmark.scala:76: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def fileChannel_noReadAhead(): Unit = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\stream\io\FileSourcesBenchmark.scala:95: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def naive_ioSourceLinesIterator(): Unit = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_copyToBuffer_Benchmark.scala:25: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ByteString_copyToBuffer_Benchmark.this.bs_mini.asInstanceOf[akka.util.ByteString.ByteString1C]
[warn]   val bss_mini = ByteStrings(Vector.fill(4)(bs_mini.asInstanceOf[ByteString1C].toByteString1), 4 * bs_mini.length)
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_copyToBuffer_Benchmark.scala:26: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ByteString_copyToBuffer_Benchmark.this.bs_small.asInstanceOf[akka.util.ByteString.ByteString1C]
[warn]   val bss_small = ByteStrings(Vector.fill(4)(bs_small.asInstanceOf[ByteString1C].toByteString1), 4 * bs_small.length)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_copyToBuffer_Benchmark.scala:27: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ByteString_copyToBuffer_Benchmark.this.bs_large.asInstanceOf[akka.util.ByteString.ByteString1C]
[warn]   val bss_large = ByteStrings(Vector.fill(4)(bs_large.asInstanceOf[ByteString1C].toByteString1), 4 * bs_large.length)
[warn]                                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_copyToBuffer_Benchmark.scala:15: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] class ByteString_copyToBuffer_Benchmark {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_copyToBuffer_Benchmark.scala:75: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_copyToBuffer(): Int = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_copyToBuffer_Benchmark.scala:81: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_copyToBuffer(): Int = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_copyToBuffer_Benchmark.scala:88: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_pc_copyToBuffer(): Int = {
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_decode_Benchmark.scala:20: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ByteString_decode_Benchmark.this.bs_large.asInstanceOf[akka.util.ByteString.ByteString1C]
[warn]   val bss_large = ByteStrings(Vector.fill(4)(bs_large.asInstanceOf[ByteString1C].toByteString1), 4 * bs_large.length)
[warn]                                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_decode_Benchmark.scala:14: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] class ByteString_decode_Benchmark {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_decode_Benchmark.scala:45: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bc_large_decodeString_stringCharset_utf8: String =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_decode_Benchmark.scala:48: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_decodeString_stringCharset_utf8: String =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_decode_Benchmark.scala:51: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_decodeString_stringCharset_utf8: String =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_decode_Benchmark.scala:55: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bc_large_decodeString_charsetCharset_utf8: String =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_decode_Benchmark.scala:58: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_decodeString_charsetCharset_utf8: String =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_decode_Benchmark.scala:61: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_decodeString_charsetCharset_utf8: String =
[info]       ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:24: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ByteString_dropSliceTake_Benchmark.this.bs_mini.asInstanceOf[akka.util.ByteString.ByteString1C]
[warn]   val bss_mini = ByteStrings(Vector.fill(4)(bs_mini.asInstanceOf[ByteString1C].toByteString1), 4 * bs_mini.length)
[warn]                                                                 ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:25: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ByteString_dropSliceTake_Benchmark.this.bs_small.asInstanceOf[akka.util.ByteString.ByteString1C]
[warn]   val bss_small = ByteStrings(Vector.fill(4)(bs_small.asInstanceOf[ByteString1C].toByteString1), 4 * bs_small.length)
[warn]                                                                   ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:26: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   ByteString_dropSliceTake_Benchmark.this.bs_large.asInstanceOf[akka.util.ByteString.ByteString1C]
[warn]   val bss_large = ByteStrings(Vector.fill(4)(bs_large.asInstanceOf[ByteString1C].toByteString1), 4 * bs_large.length)
[warn]                                                                   ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:14: [scapegoat] Class name not recommended
[info]   Class names should begin with uppercase letter.
[info] class ByteString_dropSliceTake_Benchmark {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:81: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_drop_0: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:84: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_drop_0: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:88: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_drop_18: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:91: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_drop_18: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:95: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_drop_100: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:98: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_drop_100: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:102: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_drop_256: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:105: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_drop_256: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:109: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_drop_2000: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:112: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_drop_2000: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:118: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_slice_129_129: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:121: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_slice_129_129: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:127: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_slice_80_80: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:130: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_slice_80_80: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:136: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_dropRight_100: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:139: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_dropRight_100: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:143: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_dropRight_256: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:146: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_dropRight_256: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:150: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bs_large_dropRight_2000: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\ByteString_dropSliceTake_Benchmark.scala:153: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def bss_large_dropRight_2000: ByteString =
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\LruBoundedCacheBench.scala:61: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def addOne_lruCache(): String = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\LruBoundedCacheBench.scala:66: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def addOne_hashMap(): String = {
[info]       ^
[info] D:\data\akka-akka\akka-akka-4f9dc51\akka-bench-jmh\src\main\scala\akka\util\LruBoundedCacheBench.scala:72: [scapegoat] Method name not recommended
[info]   Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.
[info]   def addOne_hashMap_remove_put_get(): String = {
[info]       ^
[info] [warn] [scapegoat] Analysis complete: 44 files - 0 errors 49 warns 113 infos
[warn] there were 11 deprecation warnings; re-run with -deprecation for details
[warn] 48 warnings found
[info] Compiling 6 Scala sources to D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\target\multi-jvm-classes...
[info] [info] [scapegoat] 118 activated inspections
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:121: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   x$3.request.get
[warn]       successWriteAcks.map(_.request.get).toSet should be(myData.toSet)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:154: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   x$5.request.get
[warn]       successWriteAcks.map(_.request.get).toSet should be(myData.toSet)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:198: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   x$7.request.get
[warn]       successWriteAcks.map(_.request.get).toSet should be(myData.toSet)
[warn]                                      ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\JepsenInspiredInsertSpec.scala:244: [scapegoat] Use of Option.get
[warn]   Using Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.
[warn]   x$9.request.get
[warn]         successWriteAcks.map(_.request.get).toSet should be(myData.toSet)
[warn]                                        ^
[warn] D:\data\akka-akka\akka-akka-4f9dc51\akka-distributed-data\src\multi-jvm\scala\akka\cluster\ddata\ReplicatorPruningSpec.scala:79: [scapegoat] Use of asInstanceOf
[warn]   Use of asInstanceOf is considered a bad practice - consider using pattern matching instead.
[warn]   memberProbe.fishForMessage(scala.concurrent.duration.`package`.DurationInt(3).seconds, memberProbe.fishForMessage$default$2)(({

[warn]   @SerialVersionUID(value = 0) final <synthetic> class $anonfun extends scala.runtime.AbstractPartialFunction[Any,Boolean] with Serializable {

[warn]     def <init>(): <$anon: Any => Boolean> = {

[warn]       $anonfun.super.<init>();

[warn]       ()

[warn]     };

[warn]     final override def applyOrElse[A1, B1 >: Boolean](x1: A1, default: A1 => B1): B1 = ((x1.asInstanceOf[Any]: Any): Any @unchecke
[warn]         }.asInstanceOf[MemberUp].member
[warn]                       ^
[info] [warn] [scapegoat] Analysis complete: 6 files - 0 errors 5 warns 0 infos
[warn] 5 warnings found
[success] Total time: 489 s, completed 2020-11-5 14:46:58
